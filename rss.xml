<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
  <channel>
    <title>暗无天日</title>
    <link>https://lujun9972.github.io</link>
    <description>=============&gt;DarkSun的个人博客</description>
    <pubDate>Fri, 18 Feb 2022 03:09:03 UTC</pubDate>
    <lastBuildDate>Fri, 18 Feb 2022 03:09:03 UTC</lastBuildDate>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <generator>ego static site generator (https://github.com/emacs-china/ego)</generator>
<item>
<title>emacs-lisp中如何创建整数列表</title>
<link>https://lujun9972.github.io/blog/2022/02/17/emacs-lisp中如何创建整数列表/index.html</link>
<description>emacs-lisp中提供了一堆 =seq-*= 函数对序列进行操作，但却缺少类似 Python 中的 =range= 函数那样的生成序列的函数。

在网上搜索了一下才知道 emacs-lisp 中是可以使用 =number-sequence= 来实现类似的功能的。

#+begin_example
  number-sequence is a compiled Lisp function in ‘subr.el’.

  (number-sequence FROM &amp;optional TO INC)

    Probably introduced at or before Emacs version 22.1.

  Return a sequence of numbers from FROM to TO (both inclusive) as a list.
  INC is the increment used between numbers in the sequence and defaults to 1.
  So, the Nth element of the list is (+ FROM (* N INC)) where N counts from
  zero.  TO is included only if there is an N for which TO = FROM + N * INC.
  If TO is nil or numerically equal to FROM, return (FROM).
  If INC is positive and TO is less than FROM, or INC is negative
  and TO is larger than FROM, return nil.
  If INC is zero and TO is neither nil nor numerically equal to
  FROM, signal an error.

  This function is primarily designed for integer arguments.
  Nevertheless, FROM, TO and INC can be integer or float.  However,
  floating point arithmetic is inexact.  For instance, depending on
  the machine, it may quite well happen that
  (number-sequence 0.4 0.6 0.2) returns the one element list (0.4),
  whereas (number-sequence 0.4 0.8 0.2) returns a list with three
  elements.  Thus, if some of the arguments are floats and one wants
  to make sure that TO is included, one may have to explicitly write
  TO as (+ FROM (* N INC)) or use a variable whose value was
  computed with this exact expression.  Alternatively, you can,
  of course, also replace TO with a slightly larger value
  (or a slightly more negative value if INC is negative).
#+end_example

而且 =number-sequence= 函数还支持小数，这个就比较牛逼了。
#+begin_src emacs-lisp
  (number-sequence 0.1 1 0.1)
#+end_src

#+RESULTS:
| 0.1 | 0.2 | 0.30000000000000004 | 0.4 | 0.5 | 0.6 | 0.7000000000000001 | 0.8 | 0.9 | 1.0 |

当然了，小数的表示不是那个准确的。

另外，我们还可以借助它实现其他生成序列的函数，比如
#+begin_src emacs-lisp
  (defun my/repeat (x c)
    (mapcar (lambda (_)
              c)
            (number-sequence 1 x)))

  (my/repeat 5 1)
#+end_src

#+RESULTS:
| 1 | 1 | 1 | 1 | 1 |
</description>
<pubDate>2022-02-17</pubDate>
<guid>https://lujun9972.github.io/blog/2022/02/17/emacs-lisp中如何创建整数列表/index.html</guid>
</item>
<item>
<title>如何更改url package访问HTTP时的user-agent header</title>
<link>https://lujun9972.github.io/blog/2021/09/24/如何更改url-package访问http时的user-agent-header/index.html</link>
<description>有些网站会根据 http request 中的 user-agent header 的值返回不同的response，例如 http://wttr.in 会根据就会根据 user-agent 是否为 curl 来决定是返回带图片的HTML，还是字符拼接图案的文本。

一开始我以为修改 =url package= 中的 =user-agent= 就是直接把相应的 header 内容加到 =url-request-extra-headers= 中就行了，事实证明我还是太天真了，这样做的后果是会产生两个 =user-agent= header...
#+begin_src emacs-lisp :results org
  (let ((url-debug t)
        (url-request-extra-headers &#39;((&quot;User-Agent&quot; . &quot;curl/7.78.0&quot;))))
    (kill-buffer (url-retrieve-synchronously &quot;http://wttr.in&quot;))
    (with-current-buffer &quot;*URL-DEBUG*&quot;
      (keep-lines &quot;^User-Agent&quot; (point-min) (point-max))
      (buffer-substring-no-properties (point-min) (point-max))))
#+end_src

#+RESULTS:
#+begin_src org
User-Agent: URL/Emacs Emacs/28.0.50 (X11; x86_64-pc-linux-gnu)
User-Agent: curl/7.78.0
#+end_src

在翻阅了 [[https://www.gnu.org/software/emacs/manual/html_mono/url.html][url manual]] 之后才知道，原来 =url= 专门有个变量用来控制 user-agent:
#+begin_example
  url-user-agent is a variable defined in ‘url-vars.el’.

  Its value is ‘default’

    You can customize this variable.
    This variable was introduced, or its default value was changed, in
    version 26.1 of Emacs.
    Probably introduced at or before Emacs version 25.1.

  User Agent used by the URL package for HTTP/HTTPS requests.
  Should be one of:
  ,* A string (not including the &quot;User-Agent:&quot; prefix)
  ,* A function of no arguments, returning a string
  ,* ‘default’ (to compute a value according to ‘url-privacy-level’)
  ,* nil (to omit the User-Agent header entirely)
#+end_example

所以修改 =user-agent= header 的正确方法是修改 =url-user-agent= 这个变量的值:
#+begin_src emacs-lisp :results org
  (let ((url-debug t)
        (url-user-agent &quot;curl/7.78.0&quot;))
    (kill-buffer (url-retrieve-synchronously &quot;http://wttr.in&quot;))
    (with-current-buffer &quot;*URL-DEBUG*&quot;
      (keep-lines &quot;^User-Agent&quot; (point-min) (point-max))
      (buffer-substring-no-properties (point-min) (point-max))))
#+end_src

#+RESULTS:
#+begin_src org
User-Agent: curl/7.78.0
#+end_src
</description>
<pubDate>2021-09-24</pubDate>
<guid>https://lujun9972.github.io/blog/2021/09/24/如何更改url-package访问http时的user-agent-header/index.html</guid>
</item>
<item>
<title>如何让Emacs使用Firefox的Cookie文件</title>
<link>https://lujun9972.github.io/blog/2021/08/17/如何让emacs使用firefox的cookie文件/index.html</link>
<description>* Firefox cookie 文件的位置与格式
+ 在 Windows 系统中， Firefox cookie 文件为 =%APPDATA%\Mozilla\Firefox\Profiles\&lt;profile name&gt;\cookies.sqlite=
+ 在 Linux 系统中， Firefox cookie 文件为 =~/.mozilla/firefox/&lt;profile name&gt;/cookies.sqlite=

Firefox cookie 文件是一个 SQLite3 的数据库，可以通过 =sqlite3= 打开，其中有一个名为 =moz_cookies= 的表存储着 cookie 的每条记录。
该表的阿结构如下：
#+begin_src sqlite :db ~/work/cookies.sqlite :header
PRAGMA table_info(moz_cookies);
#+end_src

#+RESULTS:
| cid | name             | type    | notnull | dflt_value | pk |
|   0 | id               | INTEGER |       0 |            |  1 |
|   1 | originAttributes | TEXT    |       1 |         &#39;&#39; |  0 |
|   2 | name             | TEXT    |       0 |            |  0 |
|   3 | value            | TEXT    |       0 |            |  0 |
|   4 | host             | TEXT    |       0 |            |  0 |
|   5 | path             | TEXT    |       0 |            |  0 |
|   6 | expiry           | INTEGER |       0 |            |  0 |
|   7 | lastAccessed     | INTEGER |       0 |            |  0 |
|   8 | creationTime     | INTEGER |       0 |            |  0 |
|   9 | isSecure         | INTEGER |       0 |            |  0 |
|  10 | isHttpOnly       | INTEGER |       0 |            |  0 |
|  11 | inBrowserElement | INTEGER |       0 |          0 |  0 |
|  12 | sameSite         | INTEGER |       0 |          0 |  0 |
|  13 | rawSameSite      | INTEGER |       0 |          0 |  0 |
|  14 | schemeMap        | INTEGER |       0 |          0 |  0 |

* Cookie 文件格式
Cookie 文件其实就是一个文本文件，每行存储着一个 cookie 记录（＃ 开头的行除外，这是注释）。每条 cookie 记录由7个字段组成，通过 =TAB= 进行分隔。

这些字段分别为：

+ domain - cookie 所适用的域名
+ flag - TRUE/FALSE 值，表示是否适用于所有 =domain= 下的子域名。
+ path - 该cookie 适用的域名路径， =/= 表示任意路径都适用
+ secure - TRUE/FALSE 值，表示是否只能通过 HTTPS 协议传递该 cookie 值。
+ expiration - cookie 过期时间，它是从1970年1月1日起开始的秒数，或者0表示永不过期
+ name - cookie 名
+ value - cookie 值

* 导出 Cookie 文件
由于 Emacs 不支持直接读写 =sqlite= 数据库，因此需要通过 =sqlite3= 命令将 =cookies.sqlite= 转换为标准的 Cookie 文件。

脚本如下：
#+begin_src shell :var COOKIEDB=&quot;/home/lujun9972/work/cookies.sqlite&quot; :var COOKIEFILE=&quot;/tmp/cookie.txt&quot; :results org
  echo &quot;# Netscape HTTP Cookie File&quot; &gt; $COOKIEFILE  # url package 在加载外部 Cookie 文件时会检查这一行Cookie标志，因此这行注释不可缺少。
  sqlite3 -separator &quot;\t&quot; $COOKIEDB &gt;&gt; $COOKIEFILE &lt;&lt;- EOF
  .mode tabs
  .header off
  select host,
  case substr(host,1,1)=&#39;.&#39; when 0 then &#39;FALSE&#39; else &#39;TRUE&#39; end,
  path,
  case isSecure when 0 then &#39;FALSE&#39; else &#39;TRUE&#39; end,
  expiry,
  name,
  value
  from moz_cookies;
  EOF
#+end_src


* Emacs 中使用 Cookie 文件

** url package
=url= 是 Emacs 自带的网络访问package,它将 Cookie 内容以 =elisp form= 的形式存储在了 =url-cookie-file= 所指代的文件中。不过它同时也提供了函数 =url-cookie-parse-file-netscape= 来加载外部的 Cookie 文件。

#+begin_example
  (url-cookie-parse-file-netscape FILENAME &amp;optional LONG-SESSION)

  Load cookies from FILENAME in Netscape/Mozilla format.
  When LONG-SESSION is non-nil, session cookies (expiring at t=0
  i.e. 1970-1-1) are loaded as expiring one year from now instead.
#+end_example

例如：
#+begin_src emacs-lisp :var COOKIEFILE=&quot;/tmp/cookie.txt&quot;
  (url-cookie-parse-file-netscape COOKIEFILE)
#+end_src

#+RESULTS:
: added 1073 cookies from file /tmp/cookie.txt

** request package
request 有两个后端，一个是 =url= package 一个 =curl= 命令，当使用 =url= package 时使用 Cookie 文件的方式跟上面一样的。

当使用 =curl= 命令是，它会从从 =request-storage-directory= 所指目录下的 =curl-cookie-jar= 中读取 Cookie 记录。
因此，只需要将外部 Cookie 文件的内容添加到这个文件中就行了：
#+begin_src emacs-lisp :var COOKIEFILE=&quot;/tmp/cookie.txt&quot;
  (with-temp-file (request--curl-cookie-jar)
    (insert-file-contents (request--curl-cookie-jar))
    (goto-char (point-max))
    (insert-file-contents COOKIEFILE))
#+end_src

#+RESULTS:
| /tmp/cookie.txt | 109313 |

</description>
<pubDate>2021-08-17</pubDate>
<guid>https://lujun9972.github.io/blog/2021/08/17/如何让emacs使用firefox的cookie文件/index.html</guid>
</item>
<item>
<title>AIX中的timeout脚本</title>
<link>https://lujun9972.github.io/blog/2021/07/27/aix中的timeout脚本/index.html</link>
<description>AIX 下没有现成的 =timeout= 命令来限时运行命令，于是就想着自己实现一个类似的脚本。本来以为挺简单的一件事情，结果埋者一堆坑。

最初的结果如下：
#+begin_src shell 
  #! /usr/bin/ksh
  waitfor=$1
  shift
  command=$*
  $command &amp;
  commandpid=$!
  (sleep $waitfor;kill $commandpid) &amp; # 坑1
  watchdogpid=$!
  wait $commandpid
  kill $watchdogpid               # 坑2
#+end_src

这里有两个需要关注的地方：
1. =(sleep $waitof;kill $commandpid) &amp;= 在超时杀掉工作命令后就退出了，工作命令被杀掉之后 =wait $commandpid= 执行完成，主进程继续执行 =kill $watchdogpid=.
   然而由于监控进程早已退出，在忙碌的系统中，可能出现 =$watchdogpid= 被其他进程重复使用，导致误杀其他进程的风险。
   要解决这一风险，可以让监控进程在杀掉工作进程后再等待一段时间，以便让主进程杀掉监控进程。
2. =kill $watchdogpid= 在 =ksh= 中并不会把子进程一起杀掉，也就是说 =sleep $waitfor= 这个进程依然在运行，只不过父进程从 =$watchdogpid= 变成了 =1=.
   不仅如此 =AIX= 上的 =kill= 居然不支持 =PID= 为负数的情况，这使得妄想通过 =kill -$watchdogpid= 杀掉整个进程组变得不可能。


最后经过尝试，发现在ksh交互模式下，用 =kill %jobID= 的方式是能够将整个 =JOB= 杀干净的，因此最后的结果如下：
#+begin_src shell 
  #! /usr/bin/ksh -i
  waitfor=$1
  shift
  command=$*
  $command &amp;
  commandpid=$!
  (sleep $waitfor;kill $commandpid;sleep 1) &amp;
  wait $commandpid
  kill %2 &gt;/dev/null 2&gt;&amp;1
#+end_src

不过这种实现有个比较大的缺点就是由于整个实现实在交互式ksh环境中执行的，因此会污染 ksh 的 history 命令历史。


* UPDATE:
教新的 AIX 上搭载的 kill 命令是支持通过将 =PID= 设置为负值来杀掉整个进程组的，这样一来 =timeout= 的实现就简单很多了：
#+begin_src shell 
  timeout()
  {
      waitfor=$1
      shift
      command=$*
      $command &amp;
      commandpid=$!
      (sleep $waitfor;kill $commandpid;sleep 1) &amp;
      watchdogpid=$!
      wait $commandpid
      kill -$watchdogpid               # 杀掉整个进程组
  }
#+end_src
</description>
<pubDate>2021-08-07</pubDate>
<guid>https://lujun9972.github.io/blog/2021/07/27/aix中的timeout脚本/index.html</guid>
</item>
<item>
<title>从命令行追踪新冠肺炎全球疫情数据</title>
<link>https://lujun9972.github.io/blog/2021/08/07/从命令行追踪新冠肺炎全球疫情数据/index.html</link>
<description>今天发现一个好牛逼的网站，可以让我们通过命令行查看新冠肺炎全球疫情数据

1. 查看指定国家的今日疫情数据

通过访问 `https://corona-stats.online/国家名称` 可以获得指定国家的今日疫情数据，例如下面命令查看中国的当前疫情数据：
#+begin_src shell
curl https://corona-stats.online/china
#+end_src

[[file:images/corona19-01.png]]

2. 获取新冠肺炎全球TOP排行榜数据

通过访问 `https://corona-stats.online?top=N` 可以获得感染人数前N的国家今日疫情数据，例如下面命令查看感染人数前5的国家及其疫情数据：
#+begin_src shell
curl https://corona-stats.online?top=5
#+end_src

[[file:images/corona19-02.png]]

3. 指定返回 JSON 格式的数据

通过在访问URL后加上 ~?format=json~ 可以获取 JSON 格式的数据，例如下面命令获取中国今日新冠感染人数的JSON数据集:

#+begin_src shell
curl &quot;https://corona-stats.online/china?format=json&quot; |jq
#+end_src
输出结果为
#+begin_src json
{
  &quot;data&quot;: [
    {
      &quot;updated&quot;: 1628329931927,
      &quot;country&quot;: &quot;China&quot;,
      &quot;countryInfo&quot;: {
        &quot;_id&quot;: 156,
        &quot;iso2&quot;: &quot;CN&quot;,
        &quot;iso3&quot;: &quot;CHN&quot;,
        &quot;lat&quot;: 35,
        &quot;long&quot;: 105,
        &quot;flag&quot;: &quot;https://disease.sh/assets/img/flags/cn.png&quot;
      },
      &quot;cases&quot;: 93605,
      &quot;todayCases&quot;: 107,
      &quot;deaths&quot;: 4636,
      &quot;todayDeaths&quot;: 0,
      &quot;recovered&quot;: 87525,
      &quot;todayRecovered&quot;: 33,
      &quot;active&quot;: 1444,
      &quot;critical&quot;: 39,
      &quot;casesPerOneMillion&quot;: 65,
      &quot;deathsPerOneMillion&quot;: 3,
      &quot;tests&quot;: 160000000,
      &quot;testsPerOneMillion&quot;: 111163,
      &quot;population&quot;: 1439323776,
      &quot;continent&quot;: &quot;Asia&quot;,
      &quot;oneCasePerPeople&quot;: 15377,
      &quot;oneDeathPerPeople&quot;: 310467,
      &quot;oneTestPerPeople&quot;: 9,
      &quot;activePerOneMillion&quot;: 1,
      &quot;recoveredPerOneMillion&quot;: 60.81,
      &quot;criticalPerOneMillion&quot;: 0.03,
      &quot;confirmed&quot;: 93605,
      &quot;countryCode&quot;: &quot;CN&quot;
    }
  ],
  &quot;worldStats&quot;: {
    &quot;country&quot;: &quot;World&quot;,
    &quot;countryCode&quot;: &quot;World&quot;,
    &quot;cases&quot;: 202490517,
    &quot;todayCases&quot;: 130727,
    &quot;deaths&quot;: 4292020,
    &quot;todayDeaths&quot;: 2305,
    &quot;recovered&quot;: 180258478,
    &quot;active&quot;: 17940019,
    &quot;critical&quot;: 95654,
    &quot;casesPerOneMillion&quot;: &quot;25980.31&quot;,
    &quot;confirmed&quot;: 202490517
  }
}
#+end_src
</description>
<pubDate>2021-08-07</pubDate>
<guid>https://lujun9972.github.io/blog/2021/08/07/从命令行追踪新冠肺炎全球疫情数据/index.html</guid>
</item>
<item>
<title>脚本获取TLS/SSL证书失效日期</title>
<link>https://lujun9972.github.io/blog/2021/07/21/脚本获取tls-ssl证书失效日期/index.html</link>
<description>从 https://www.cyberciti.biz/faq/find-check-tls-ssl-certificate-expiry-date-from-linux-unix/ 上看到的使用小脚本，记录一下

在 Web 服务器上可以通过 TLS/SSL 来对服务器和浏览器之间的连接进行加密，TLS/SSL 使用 X509 证书来进行加密，当证书失效后浏览器访问该 Web 服务器就会出现错误提示。
通过下面这个脚本能够获取 TLS/SSL 证书的生效日期和失效日期
#+begin_src shell :var SERVER_NAME=&quot;www.baidu.com&quot; :var PORT=&quot;443&quot; :results org
  exec 2&gt;/dev/null
  openssl s_client -servername ${SERVER_NAME} -connect ${SERVER_NAME}:${PORT} | openssl x509 -noout -dates
#+end_src

#+RESULTS:
#+begin_src org
notBefore=Jul  1 01:16:03 2021 GMT
notAfter=Aug  2 01:16:03 2022 GMT
#+end_src

openssl 是一款非常好用的 TLS/SSL 诊断工具，这里用到了以下参数：

+ s_client :: 将 openssl 作为 TLS/SSL 客户端工具使用
+ -servername ${SERVER_NAME} :: 设置 TLS 的 SNI(Server Name Indication)扩展，该字段用来解决一个服务器拥有多个域名的情况
+ -connect ${SERVER_NAME}:${PORT} :: 指定要连接的TLS/SSL服务器的地址与端口
+ x509 :: X509证书数据解析工具
+ -noout :: 不显示证书内容，只显示证书的状态
+ -dates :: 输出 TLS/SSL 证书的生效日期与实效日期

我们还可以使用 =openssl x509= 直接解析 PEM格式的证书文件：
#+begin_src shell
openssl x509 -noout -dates ${PEM_FILE_PATH}
#+end_src

我们甚至可以直接检查证书是否会在多少秒后失效，从而达到预警的效果：
#+begin_src shell :var SERVER_NAME=&quot;www.baidu.com&quot; :var PORT=&quot;443&quot; :results org
  exec 2&gt;/dev/null
  openssl s_client -servername ${SERVER_NAME} -connect ${SERVER_NAME}:${PORT} | openssl x509 -noout -checkend $((365*24*3600))
#+end_src

#+RESULTS:
#+begin_src org
Certificate will not expire
#+end_src
</description>
<pubDate>2021-07-22</pubDate>
<guid>https://lujun9972.github.io/blog/2021/07/21/脚本获取tls-ssl证书失效日期/index.html</guid>
</item>
<item>
<title>笑话理解之Fission</title>
<link>https://lujun9972.github.io/blog/2021/06/24/笑话理解之fission/index.html</link>
<description>#+begin_example
  What can you do in radiation-contaminated rivers?

  Nuclear fission.
#+end_example

=fission= 音同 =fishing=
</description>
<pubDate>2021-06-24</pubDate>
<guid>https://lujun9972.github.io/blog/2021/06/24/笑话理解之fission/index.html</guid>
</item>
<item>
<title>笑话理解之Funny</title>
<link>https://lujun9972.github.io/blog/2021/06/24/笑话理解之funny/index.html</link>
<description>* taste of clowns

#+begin_example
  Why don&#39;t cannibals eat clowns?

  Because they taste funny!
#+end_example

=funny= 既有 =好笑= 也有 =古怪= 的意思
</description>
<pubDate>2021-06-24</pubDate>
<guid>https://lujun9972.github.io/blog/2021/06/24/笑话理解之funny/index.html</guid>
</item>
<item>
<title>笑话理解之Move</title>
<link>https://lujun9972.github.io/blog/2021/06/24/笑话理解之move/index.html</link>
<description>* When will my baby move?
#+begin_example
  I&#39;m two months pregnant now. When will my baby move?

  With any luck, right after it finishes college.
#+end_example

=move= 既有 =动= 的意思，也有 =离家= 的意思
</description>
<pubDate>2021-06-24</pubDate>
<guid>https://lujun9972.github.io/blog/2021/06/24/笑话理解之move/index.html</guid>
</item>
<item>
<title>笑话理解之Muffin</title>
<link>https://lujun9972.github.io/blog/2021/06/24/笑话理解之muffin/index.html</link>
<description>#+begin_example
  A little girl goes to the barbers with her dad and stands next to the chair eating a muffin while her dad gets a haircut.

  The barber smiles at her and says: &quot;Your gonna get hair on your muffin!&quot;

  &quot;I know&quot; she says &quot;im gonna get tits too you dirty old bastard!&quot;
#+end_example

=hair= 即可以指 =头发=,也可以统指 =毛发=, =muffin= 是 =松饼= 的意思，同时也是 =女阴= 的粗俗说法。
</description>
<pubDate>2021-06-24</pubDate>
<guid>https://lujun9972.github.io/blog/2021/06/24/笑话理解之muffin/index.html</guid>
</item>
</channel>
</rss>