<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
  <channel>
    <title>暗无天日</title>
    <link>https://lujun9972.github.io</link>
    <description>=============&gt;DarkSun的个人博客</description>
    <pubDate>Sat, 15 Aug 2020 11:49:47 UTC</pubDate>
    <lastBuildDate>Sat, 15 Aug 2020 11:49:47 UTC</lastBuildDate>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <generator>ego static site generator (https://github.com/emacs-china/ego)</generator>
<item>
<title>如何禁止eww生成cookie</title>
<link>https://lujun9972.github.io/blog/2020/08/15/如何禁止eww生成cookie/index.html</link>
<description>通过阅读 =eww= 的源代码可以看到 =eww= 是通过 =url= 库来获取HTML页面的，其关键代码如下：
#+begin_src emacs-lisp
  (let ((url-mime-accept-string eww-accept-content-types))
    (url-retrieve url &#39;eww-render
                  (list url nil (current-buffer))))
#+end_src

而 =url= 是通过 =url-cookie= 库来管理cookie的，这个库提供了两个变量来让我们设置哪些URL可以设置Cookie，哪些URL不允许设置Cookie：
+ url-cookie-trusted-urls :: A list of regular expressions matching URLs to always accept cookies from.
+ url-cookie-untrusted-urls :: A list of regular expressions matching URLs to never accept cookies from.

所以可以通过如下设置来完全禁止 eww 生成 cookie.
#+begin_src emacs-lisp
  (setq url-cookie-trusted-urls &#39;()       ;不设置白名单
        url-cookie-untrusted-urls &#39;(&quot;.*&quot;)) ;所有内容都匹配黑名单
#+end_src
</description>
<pubDate>2020-08-15</pubDate>
<guid>https://lujun9972.github.io/blog/2020/08/15/如何禁止eww生成cookie/index.html</guid>
</item>
<item>
<title>为Linux系统开启多因素认证</title>
<link>https://lujun9972.github.io/blog/2020/08/15/为linux系统开启多因素认证/index.html</link>
<description>通常我们登陆系统时只需要输入用户名和密码即可（若是通过SSH登陆则还可以通过密钥对来登陆）。
而多因素认证可以要求用户提供附加的认证信息来加强安全性，这个附加信息可能是一条短信验证码，安全令牌应用生成的一次性密码，指纹等内容。

本文要做的就是通过 google-authenticator 为Linux增加基于安全令牌的多因素认证

* 安装
首先在Linux上安装PAM模块google-authenticator
#+begin_src shell
  sudo pacman -S libpam-google-authenticator
#+end_src

然后，在手机上安装 =小米安全令牌= 应用

* 配置 google-authenticator 模块
运行 =google-authenticator= 来生成 OTP code。该命令会询问是否基于时间生成认证码，并生成一个二维码供你扫描。

[[file:images/OTP.png]]

在手机上打开 =小米安全令牌= 扫描这个二维码就能看认证码了，输入认证码后，再回答几个问题就完成了google-authentiator模块的配置了
#+begin_example
  Enter code from app (-1 to skip): 383791
  Code confirmed
  Your emergency scratch codes are:
    28577389
    12044244
    52789565
    81786311
    51903013

  Do you want me to update your &quot;/home/lujun9972/.google_authenticator&quot; file? (y/n) y

  Do you want to disallow multiple uses of the same authentication
  token? This restricts you to one login about every 30s, but it increases
  your chances to notice or even prevent man-in-the-middle attacks (y/n) y

  By default, a new token is generated every 30 seconds by the mobile app.
  In order to compensate for possible time-skew between the client and the server,
  we allow an extra token before and after the current time. This allows for a
  time skew of up to 30 seconds between authentication server and client. If you
  experience problems with poor time synchronization, you can increase the window
  from its default size of 3 permitted codes (one previous code, the current
  code, the next code) to 17 permitted codes (the 8 previous codes, the current
  code, and the 8 next codes). This will permit for a time skew of up to 4 minutes
  between client and server.
  Do you want to do so? (y/n) y

  If the computer that you are logging into isn&#39;t hardened against brute-force
  login attempts, you can enable rate-limiting for the authentication module.
  By default, this limits attackers to no more than 3 login attempts every 30s.
  Do you want to enable rate-limiting? (y/n) y
#+end_example

* 启用google-authenticator模块
一般来说，通过 =login= 登陆系统要求接触到物理机器，本身安全性已经足够高了，开启多因素认证意义不大，我们主要对通过网络认证的 =sshd= 进行约束。

1. 为 =sshd= PAM启用google-authenticator认证

   往 =/etc/pam.d/sshd= 中添加如下内容:
   #+begin_src conf
     auth required pam_google_authenticator.so nullok
   #+end_src
   
   其中 =nullok= 的意思是对于未配置多因素认证的用户不需要输入认证码。若没有这个参数则会强制要求主机上的所有用户都必须启用多因素认证。

2. 配置 =sshd= 使用PAM进行认证

   编辑 =/etc/ssh/sshd_config= 确定 =UsePAM= 的值为 =yes=

3. 配置 =sshd= 提示输入认证码

   编辑 =/etc/ssh/sshd_config= 确定 =ChallengeResponseAuthentication= 的值为 =yes=

4. 重启 =sshd= 服务
   
   #+begin_src shell
     sudo systemctl restart sshd
   #+end_src


这样一来，通过 =sshd= 登陆 =lujun9972= 这个用户时就会要求输入认证码了，而登陆其他用户时则无需输入验证码:
#+begin_example
  lujun9972@orangepipc2:~$ ssh 192.168.1.206 -p 8022
  The authenticity of host &#39;[192.168.1.206]:8022 ([192.168.1.206]:8022)&#39; can&#39;t be established.
  ECDSA key fingerprint is SHA256:zIiiOyKuX/q7d+CI5HKNTTiqcHQ+QSf+caivgdS/OG8.
  Are you sure you want to continue connecting (yes/no/[fingerprint])? yes
  Warning: Permanently added &#39;[192.168.1.206]:8022&#39; (ECDSA) to the list of known hosts.
  Password: 
  Verification code: 
  Last login: Sat Aug 15 19:35:37 2020 from 127.0.0.1
  Test whether fcitx is running correctly with dbus...
  Fcitx is running correctly.

  =========================================================
  Launch fbterm...
  stdin isn&#39;t a interactive tty!
  lujun9972:~/ $ exit
  logout
  Connection to 192.168.1.206 closed.
  lujun9972@orangepipc2:~$ ssh daddy@192.168.1.206 -p 8022
  Password: 
  Last login: Sat Aug 15 19:37:50 2020 from 127.0.0.1
  [daddy@T520 /]$ exit
  logout
  Connection to 192.168.1.206 closed.
  lujun9972@orangepipc2:~$ 
#+end_example
</description>
<pubDate>2020-08-15</pubDate>
<guid>https://lujun9972.github.io/blog/2020/08/15/为linux系统开启多因素认证/index.html</guid>
</item>
<item>
<title>使用systemd-detect-virt判断Linux是否运行在虚拟机中</title>
<link>https://lujun9972.github.io/blog/2020/08/08/使用systemd-detect-virt判断linux是否运行在虚拟机中/index.html</link>
<description>之前我一直是用 =dmidecode= 来判断Linux是否运行在虚拟环境：

在物理机上：
#+begin_src shell :dir /sudo:: :results org
  sudo dmidecode -s system-product-name
#+end_src

#+RESULTS:
#+begin_src org
2353ABU
#+end_src

在虚拟机上：
#+begin_src shell :dir /ssh:192.168.1.85|sudo:192.168.1.85: :results org
  sudo dmidecode -s system-product-name
#+end_src

#+RESULTS:
#+begin_src org
VirtualBox
#+end_src

但是它有个缺陷，就是不支持容器的检查。在容器中运行 =dmidecode= 会提示错误信息 =/dev/mem: No such file or directory=
若你把 =/dev= 挂载进容器，则又会被识别为物理急。

不过今天我发现，原来 =systemd= 已经提供了一个命令来帮你完成这项任务了，那就是 =systemd-detect-virt=.

在物理机上：
#+begin_src shell :dir /sudo:: :results org
  systemd-detect-virt;exit 0
#+end_src

#+RESULTS:
#+begin_src org
none
#+end_src

在虚拟机上：
#+begin_src shell :dir /ssh:192.168.1.85|sudo:192.168.1.85: :results org
  systemd-detect-virt;exit 0
#+end_src

#+RESULTS:
#+begin_src org
oracle
#+end_src

在容器上:
#+begin_src shell :dir /docker:a4622369efdd: :results org
  systemd-detect-virt;exit 0
#+end_src

#+RESULTS:
#+begin_src org
docker
#+end_src
</description>
<pubDate>2020-08-08</pubDate>
<guid>https://lujun9972.github.io/blog/2020/08/08/使用systemd-detect-virt判断linux是否运行在虚拟机中/index.html</guid>
</item>
<item>
<title>为什么排序数组比未排序数组的处理速度要快?</title>
<link>https://lujun9972.github.io/blog/2020/07/22/为什么排序数组比未排序数组的处理速度要快-/index.html</link>
<description>今天在 Stack Overflow 上看到一个有趣的问题： Why is processing a sorted array faster than processing an unsorted array?

提问者列了一段代码：
#+begin_src C++ :results org
  #include &lt;algorithm&gt;
  #include &lt;ctime&gt;
  #include &lt;iostream&gt;

  int main()
  {
    // 生成数据
    const unsigned arraySize = 32768;
    int data[arraySize];

    for (unsigned c = 0; c &lt; arraySize; ++c)
      data[c] = std::rand() % 256;

    // !!! 这一行会导致后面的循环运行速度变快.
    // std::sort(data, data + arraySize);

    // 测试运算速度
    clock_t start = clock();
    long long sum = 0;

    for (unsigned i = 0; i &lt; 100000; ++i)
      {
        // 主循环
        for (unsigned c = 0; c &lt; arraySize; ++c)
          {
            if (data[c] &gt;= 128)
              sum += data[c];
          }
      }

    double elapsedTime = static_cast&lt;double&gt;(clock() - start) / CLOCKS_PER_SEC;

    std::cout &lt;&lt; elapsedTime &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;sum = &quot; &lt;&lt; sum &lt;&lt; std::endl;
  }
#+end_src

这段代码奇就奇怪在当注释掉 =std::sort(data, data + arraySize);= 这行代码后，循环运算的速度有了明显的提升。

比如在我Win10 的 WSL 上加上排序代码后的运算时间为 =6.65907= 秒，去掉排序代码后的运算时间为 =20.5398=.

那么产生这一现象的原因是什么呢？那就是分支预测。

分支预测(Branch Prediction)是一种用来解决分支指令导致流水线失败的方法。
即CPU的分支预测器预测条件表达式中哪一路最可能发生，然后根据预测结果进行取指令和执行指令等操作。
这样一来，在预测成功的情况下，CPU就避免了由于流水线停顿而导致的时间浪费。而在分支预测错误的情况下，则需要将流水线中推测执行的所有中间结果全部放弃，重新从另一个分支出发取指令和执行指令。
由于现代的CPU使用的流水线普遍很长，一般分支预测失败会损失大约10-20个时钟周期。

那么回到上面的这段代码。代码中有且仅有一个分支语句就是 ~if (data[c] &gt;= 128)~,而这个语句就是导致两个数组运算速度差距如此之大的罪魁祸首。

现代的CPU普遍采用动态预测器，即根据历史的分支执行信息来进行预测。
比如最简单的1 bit 动态预测就是直接根据该指令上次是否跳转来预测此次是否跳转。如果上次跳转，则预测此次也会跳转。
当然实际使用的动态预测模型不会这么简单啦。

当预先对数组进行排序后，预测变得十分简单，因此在执行过程中CPU可以充分利用流水线的能力进行加速。
而在完全随机的情况下，预测变得不可能，CPU猜错的概率为 50%,也就是有一半的概率需要清空流水线，损失那10-20个时钟周期。

由于条件语句能够极大的干扰 CPU 流水线的运行，因此一个常用的提速方法就是去掉条件语句，比如在最高赞的那个答案中，给出的解决方案就是把
#+begin_src C
  if (data[c] &gt;= 128)
    sum += data[c];
#+end_src

改写成
#+begin_src C
  int t = (data[c] - 128) &gt;&gt; 31;
  sum += ~t &amp; data[c];
#+end_src

不过这个可读性不是一般的差～～～

随便一提，在这个问题后面还有一个高赞答案是使用 =?:= (据说会编译成条件传送指令cmov)进行改写:
#+begin_src C
  sum += data[c] &gt;=128 ? data[c] : 0;
#+end_src

但是我测试的结果发现这样修改后的速度并没有变快,不知道是什么原因。
</description>
<pubDate>2020-07-22</pubDate>
<guid>https://lujun9972.github.io/blog/2020/07/22/为什么排序数组比未排序数组的处理速度要快-/index.html</guid>
</item>
<item>
<title>笑话理解之blow</title>
<link>https://lujun9972.github.io/blog/2020/07/17/笑话理解之blow/index.html</link>
<description>#+begin_example
  What&#39;s the difference between your paycheck and your dict?

  You don&#39;t have to beg your wife to blow your paycheck!
#+end_example

=blow= 有 =挥霍= 的意思，另一个意思 =blowjob=, 你懂得。
</description>
<pubDate>2020-07-17</pubDate>
<guid>https://lujun9972.github.io/blog/2020/07/17/笑话理解之blow/index.html</guid>
</item>
<item>
<title>笑话理解之crane</title>
<link>https://lujun9972.github.io/blog/2020/07/17/笑话理解之crane/index.html</link>
<description>* What kind of bird can carry the most weight?

#+begin_example
  What kind of bird can carry the most weight?

  The crane!
#+end_example

=crane= 即可以表示 =鹤=,也可以表示 =起重机=
</description>
<pubDate>2020-07-17</pubDate>
<guid>https://lujun9972.github.io/blog/2020/07/17/笑话理解之crane/index.html</guid>
</item>
<item>
<title>笑话理解之cum</title>
<link>https://lujun9972.github.io/blog/2020/07/17/笑话理解之cum/index.html</link>
<description>* How do you cancel an appointment at the sperm bank?
#+begin_example
  How do you cancel an appointment at the sperm bank?

  Ring up and say you cannot cum.
#+end_example

=cum= 音同 =come=, 其中一个意思是：
#+begin_example
  Cum is a vulgar slang word for the liquid that comes out of the penis during ejaculation.
  Sometimes spelled com, this is very inappropriate word.

  When a man cums, he produces cum: this word can be a noun or verb.
#+end_example
</description>
<pubDate>2020-07-17</pubDate>
<guid>https://lujun9972.github.io/blog/2020/07/17/笑话理解之cum/index.html</guid>
</item>
<item>
<title>笑话理解之honey</title>
<link>https://lujun9972.github.io/blog/2020/07/17/笑话理解之honey/index.html</link>
<description>* What did the bee say to the flower?
#+begin_example
  What did the bee say to the flower?

  Hello honey!
#+end_example

honey: =蜂蜜=, =爱人=
</description>
<pubDate>2020-07-17</pubDate>
<guid>https://lujun9972.github.io/blog/2020/07/17/笑话理解之honey/index.html</guid>
</item>
<item>
<title>笑话理解之lay</title>
<link>https://lujun9972.github.io/blog/2019/06/09/笑话理解之lay/index.html</link>
<description>* Three Nuns
#+begin_example
  Three Italian nuns die and go to heaven.

  At the Pearly Gates, they are met by St. Peter.

  He says, &quot;Sisters, you all led such exemplary lives that the Lord is granting you six months to go back to earth and be anyone you wish to be.

  The first nun says, &quot;I want to be Sophia Loren..&quot; and *poof* she&#39;s gone.

  The second says, &quot;I want to be Madonna and *poof* she&#39;s gone.

  The third says, &quot;I want to be Sara Pipalini...&quot;

  St. Peter looks perplexed, &quot;Who?&quot;

  &quot;Sara Pipalini,&quot; replies the nun.

  St Peter shakes his head and says, &quot;I&#39;m sorry, but that name just doesn&#39;t ring a bell.&quot;

  The nun then takes a newspaper out of her habit and hands it to St. Peter. St. Peter reads the paper and starts laughing. He hands it back to her and says.

  &quot;No sister, the paper says it was the &#39;Sahara Pipeline&#39; that was laid by 1,400 men in 6 months.&quot;
#+end_example

=lay= 既有 =铺设= 也有 =与...性交= 的意思。

* Why do chickens lay eggs
#+begin_example
  Why do chickens lay eggs?

  Because if they drop them they will break!
#+end_example

=lay= 既有 =下蛋= 也有 =放置，铺设= 的意思。
</description>
<pubDate>2020-07-13</pubDate>
<guid>https://lujun9972.github.io/blog/2019/06/09/笑话理解之lay/index.html</guid>
</item>
<item>
<title>笑话理解之divide与multiply</title>
<link>https://lujun9972.github.io/blog/2020/06/22/笑话理解之divide与multiply/index.html</link>
<description>#+begin_example
  One attractive young businesswoman to another over lunch: &quot;My life is all math. I am trying to add to my income, subtract from my weight, divide my time, and avoid multiplying.&quot;
#+end_example

=divide=  在数学用语中是 =除法=, 同时也有 =分割= 的意思。

=multiply= 在数学用于中是 =乘法=, 同时也有 =繁殖= 的意思。
</description>
<pubDate>2020-06-22</pubDate>
<guid>https://lujun9972.github.io/blog/2020/06/22/笑话理解之divide与multiply/index.html</guid>
</item>
</channel>
</rss>