<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
  <channel>
    <title>暗无天日</title>
    <link>https://lujun9972.github.io</link>
    <description>=============&gt;DarkSun的个人博客</description>
    <pubDate>Mon, 26 Apr 2021 03:45:51 UTC</pubDate>
    <lastBuildDate>Mon, 26 Apr 2021 03:45:51 UTC</lastBuildDate>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <generator>ego static site generator (https://github.com/emacs-china/ego)</generator>
<item>
<title>为ping命令增加时间信息的正确方法</title>
<link>https://lujun9972.github.io/blog/2021/04/26/为ping命令增加时间信息的正确方法/index.html</link>
<description>不知道为什么，在网上搜索为 ping 命令增加时间信息方法时，给出来得解决方案都是将 ping 命令的结果传递给一个循环，然后在循环内生成时间。

这个循环可能是一个流式处理命令，比如 awk:
#+begin_src shell :results org
  ping www.baidu.com -c 5 | awk &#39;{ print strftime(&quot;%Y-%m-%d %H:%M:%S&quot;,systime())&quot;\t&quot;$0 }&#39;
#+end_src

#+RESULTS:
#+begin_src org
2021-04-26 11:26:24	PING www.a.shifen.com (14.215.177.38) 56(84) bytes of data.
2021-04-26 11:26:24	64 bytes from 14.215.177.38 (14.215.177.38): icmp_seq=1 ttl=52 time=12.1 ms
2021-04-26 11:26:24	64 bytes from 14.215.177.38 (14.215.177.38): icmp_seq=2 ttl=52 time=9.51 ms
2021-04-26 11:26:25	64 bytes from 14.215.177.38 (14.215.177.38): icmp_seq=3 ttl=52 time=18.4 ms
2021-04-26 11:26:26	64 bytes from 14.215.177.38 (14.215.177.38): icmp_seq=4 ttl=52 time=15.4 ms
2021-04-26 11:26:27	64 bytes from 14.215.177.38 (14.215.177.38): icmp_seq=5 ttl=52 time=9.81 ms
2021-04-26 11:26:27	
2021-04-26 11:26:27	--- www.a.shifen.com ping statistics ---
2021-04-26 11:26:27	5 packets transmitted, 5 received, 0% packet loss, time 10077ms
2021-04-26 11:26:27	rtt min/avg/max/mdev = 9.519/13.089/18.481/3.432 ms
#+end_src

也可能是一个 while 循环语句：
#+begin_src shell :results org
  ping www.baidu.com -c 5 |while read result
  do
      echo &quot;$(date) ${result}&quot;
  done
#+end_src

#+RESULTS:
#+begin_src org
2021年 04月 26日 星期一 11:25:09 CST PING www.a.shifen.com (14.215.177.38) 56(84) bytes of data.
2021年 04月 26日 星期一 11:25:09 CST 64 bytes from 14.215.177.38 (14.215.177.38): icmp_seq=1 ttl=52 time=8.73 ms
2021年 04月 26日 星期一 11:25:09 CST 64 bytes from 14.215.177.38 (14.215.177.38): icmp_seq=2 ttl=52 time=16.4 ms
2021年 04月 26日 星期一 11:25:10 CST 64 bytes from 14.215.177.38 (14.215.177.38): icmp_seq=3 ttl=52 time=9.98 ms
2021年 04月 26日 星期一 11:25:11 CST 64 bytes from 14.215.177.38 (14.215.177.38): icmp_seq=4 ttl=52 time=10.8 ms
2021年 04月 26日 星期一 11:25:12 CST 64 bytes from 14.215.177.38 (14.215.177.38): icmp_seq=5 ttl=52 time=17.3 ms
2021年 04月 26日 星期一 11:25:12 CST 
2021年 04月 26日 星期一 11:25:12 CST --- www.a.shifen.com ping statistics ---
2021年 04月 26日 星期一 11:25:12 CST 5 packets transmitted, 5 received, 0% packet loss, time 7043ms
2021年 04月 26日 星期一 11:25:12 CST rtt min/avg/max/mdev = 8.731/12.684/17.392/3.548 ms
#+end_src

但是这有个问题，那就是时间戳不是由 =ping= 命令生成的，而是在循环体内生成的。这就导致若我们在时间戳生成之前用 =sed= 和 =awk= 之类的命令对 =ping= 结果加工后，由于它们的缓存机制会使得输出到循环的时间比实际 ping 命令产生结果的时间产生较大差别。

例如下面命令的输出中，生成的时间是同一秒，这明显是不对的。
#+begin_src shell :results org
  ping www.baidu.com -c 5|awk &#39;1&#39; | awk &#39;{ print strftime(&quot;%Y-%m-%d %H:%M:%S&quot;,systime())&quot;\t&quot;$0 }&#39;
#+end_src

#+RESULTS:
#+begin_src org
2021-04-26 11:27:01	PING www.a.shifen.com (14.215.177.39) 56(84) bytes of data.
2021-04-26 11:27:01	64 bytes from 14.215.177.39 (14.215.177.39): icmp_seq=1 ttl=52 time=13.2 ms
2021-04-26 11:27:01	64 bytes from 14.215.177.39 (14.215.177.39): icmp_seq=2 ttl=52 time=8.32 ms
2021-04-26 11:27:01	64 bytes from 14.215.177.39 (14.215.177.39): icmp_seq=3 ttl=52 time=18.1 ms
2021-04-26 11:27:01	64 bytes from 14.215.177.39 (14.215.177.39): icmp_seq=4 ttl=52 time=8.61 ms
2021-04-26 11:27:01	64 bytes from 14.215.177.39 (14.215.177.39): icmp_seq=5 ttl=52 time=9.09 ms
2021-04-26 11:27:01	
2021-04-26 11:27:01	--- www.a.shifen.com ping statistics ---
2021-04-26 11:27:01	5 packets transmitted, 5 received, 0% packet loss, time 4052ms
2021-04-26 11:27:01	rtt min/avg/max/mdev = 8.322/11.492/18.191/3.794 ms
#+end_src


事实上，通过查看 =ping= 命令的 manual, 我们可以发现 ping 命令的 =-D= 选项本身就会为每一行输出生成时间戳：
#+begin_example
   -D     Print timestamp (unix time + microseconds as in gettimeofday) before each line.
#+end_example

#+begin_src shell :results org
  ping -c 5 www.baidu.com -D
#+end_src

#+RESULTS:
#+begin_src org
PING www.a.shifen.com (14.215.177.39) 56(84) bytes of data.
[1619407749.478198] 64 bytes from 14.215.177.39 (14.215.177.39): icmp_seq=1 ttl=52 time=8.86 ms
[1619407749.492436] 64 bytes from 14.215.177.39 (14.215.177.39): icmp_seq=2 ttl=52 time=13.8 ms
[1619407750.493666] 64 bytes from 14.215.177.39 (14.215.177.39): icmp_seq=3 ttl=52 time=13.4 ms
[1619407751.492797] 64 bytes from 14.215.177.39 (14.215.177.39): icmp_seq=4 ttl=52 time=10.5 ms
[1619407752.501662] 64 bytes from 14.215.177.39 (14.215.177.39): icmp_seq=5 ttl=52 time=17.1 ms

--- www.a.shifen.com ping statistics ---
5 packets transmitted, 5 received, 0% packet loss, time 4042ms
rtt min/avg/max/mdev = 8.861/12.776/17.120/2.861 ms
#+end_src

唯一的问题就是这个时间戳采取的是是从1970年1月1日（UTC/GMT的午夜）开始所经过的秒数，不方便理解，但是没关系，我们可以用 =date= 进行一下转换：
#+begin_src shell :results org
  ping -c 5 www.baidu.com -D |awk &#39;1&#39; |while read result
  do
      if [[ &quot;${result}&quot; =~ &quot;[&quot; ]] # 以 [ 开头的行带时间戳
      then
         read timestamp rest &lt; &lt;(echo ${result}|tr -d &#39;[]&#39;)
         echo $(date -d @${timestamp}) &quot;${rest}&quot;
         else
             echo &quot;${result}&quot;
      fi
  done
#+end_src

#+RESULTS:
#+begin_src org
PING www.a.shifen.com (14.215.177.39) 56(84) bytes of data.
2021年 04月 26日 星期一 11:41:25 CST 64 bytes from 14.215.177.39 (14.215.177.39): icmp_seq=1 ttl=52 time=8.97 ms
2021年 04月 26日 星期一 11:41:25 CST 64 bytes from 14.215.177.39 (14.215.177.39): icmp_seq=2 ttl=52 time=7.89 ms
2021年 04月 26日 星期一 11:41:26 CST 64 bytes from 14.215.177.39 (14.215.177.39): icmp_seq=3 ttl=52 time=27.3 ms
2021年 04月 26日 星期一 11:41:27 CST 64 bytes from 14.215.177.39 (14.215.177.39): icmp_seq=4 ttl=52 time=20.6 ms
2021年 04月 26日 星期一 11:41:28 CST 64 bytes from 14.215.177.39 (14.215.177.39): icmp_seq=5 ttl=52 time=22.2 ms

--- www.a.shifen.com ping statistics ---
5 packets transmitted, 5 received, 0% packet loss, time 4069ms
rtt min/avg/max/mdev = 7.897/17.425/27.343/7.671 ms
#+end_src
</description>
<pubDate>2021-04-26</pubDate>
<guid>https://lujun9972.github.io/blog/2021/04/26/为ping命令增加时间信息的正确方法/index.html</guid>
</item>
<item>
<title>在Linux下创建内存磁盘的不同方法及区别</title>
<link>https://lujun9972.github.io/blog/2021/04/16/在linux下创建内存磁盘的不同方法及区别/index.html</link>
<description>内存磁盘具有读写速度快和断电即删的特性，非常适用于临时性的测试新鲜应用。
在Linux中提供了 =tmpfs= 和 =ramfs= 两种内存文件系统用于创建内存磁盘，用它们创建内存磁盘的方法几乎一样：
#+begin_src shell
  # 使用 tmpfs 创建内存磁盘
  mount -t tmpfs -o size=1G tmpfs /mnt
  # 使用 ramfs 创建内存磁盘
  mount -t ramfs -o size=1G ramfs /mnt
#+end_src
但在效果上是有一些不同的。

tmpfs 的特点包括：
1. 使用 tmpfs 创建的内存磁盘并不百分百保证是存储在RAM芯片上的，它实际上是存储在 Linux 内核的内存池中，也就是即包含内存也包含虚拟内存。
   由于虚拟内存一般存储在磁盘上，因此速度会比实际的内存慢很多。
2. 由于特点1,tmpfs 的最大可用存储空间为实际内存＋虚拟内存的大小。默认为实际内存的一半。
3. tmpfs 实际使用的空间是随着实际存储的数据而变化的，其 =-size= 参数只是告诉内核这个挂载点最多能用多少内存池中的内存而已，并不是实际占有量。
4. tmpfs 默认挂载的权限为 777


ramfs 的特点包括：
1. 使用 ramfs 创建的内存磁盘百分百存储在实际内存上，因此读写效率可以保证。
2. ramfs 的最大可用存储空间不能超过实际内存大小
3. ramfs 立即占用实际内存，可能会因此而影响主机性能
4. ramfs 默认工作权限为 755
5. *挂载 ramfs 不会在 =df= 命令中显示出来！但能在 =mount= 命令中显示出来*
6. *ramfs 的 =size= 选项其实没什么作用，你可以往里面写大于 =size= 大小的文件，因此要小心不要写入太多东西导致内存耗尽。*
</description>
<pubDate>2021-04-16</pubDate>
<guid>https://lujun9972.github.io/blog/2021/04/16/在linux下创建内存磁盘的不同方法及区别/index.html</guid>
</item>
<item>
<title>使用awk查找并修复数据中一对多的不一致问题</title>
<link>https://lujun9972.github.io/blog/2021/04/15/使用awk查找并修复数据中一对多的不一致问题/index.html</link>
<description>从 https://www.datafix.com.au/BASHing/2021-03-17.html 上看到的一个 =awk= 小技巧。

所谓“一对多”的不一致问题是指这么一种情况：属性1与属性2本来应该是 =1:1= 或者 =N:1= 的关系，但是由于数据错误导致同一个属性1有了多个属性2与之对应。

例如下面数据中， 每个 =item= 本来应该只有唯一的一个 =class=,但是实际上 =banana= 和 =potato= 有多个 =class= 与之对应。
#+begin_example
  saleID	date	item	class	kg
  001	2021-01-02	capsicum	vegetable	11.9
  002	2021-01-02	banana	fruit	12.7
  003	2021-01-02	capsicum	vegetable	3.7
  004	2021-01-02	potato	vegetable	4.1
  005	2021-01-02	capsicum	vegetable	6.0
  006	2021-01-02	potato	fruit	13.0
  007	2021-01-02	banana	vegetable	9.1
  008	2021-01-02	potato	vegetable	15.0
  009	2021-01-02	apple	fruit	5.6
  010	2021-01-02	banana	fruit	7.7
  011	2021-01-02	pumpkin	vegetable	8.3
  012	2021-01-02	pumpkin	vegetable	5.6
  013	2021-01-02	apple	fruit	3.5
  014	2021-01-02	pumpkin	vegetable	5.3
  015	2021-01-02	capsicum	vegetable	10.3
  016	2021-01-03	apple	fruit	12.2
  017	2021-01-03	pumpkin	vegetable	12.6
  018	2021-01-03	potato	vegetable	4.4
  019	2021-01-03	apple	fruit	12.5
  020	2021-01-03	pumpkin	vegetable	11.6
  021	2021-01-03	banana	vegetable	14.5
  022	2021-01-03	capsicum	vegetable	4.1
  023	2021-01-03	banana		5.9
  024	2021-01-03	potato	vegetable	4.8
  025	2021-01-03	apple	fruit	15.6
#+end_example

为了找出一对多的关系，我们需要使用二维数组来保存 =属性1= 和 =属性2= 的关系，然后判断 =属性1= 这个一维数组中是否包含数组个数大于1的数值就行了（原文的判断方法比这要复杂，我简化了一下）。awk 程序如下
#+begin_src shell :results org
awk &#39;{b[$3][$4]++}
END {for (i in b) {if (length(b[i])&gt;1){
            for (j in b[i]){
                print b[i][j] &quot;|&quot; i FS j}}}}&#39; /tmp/test.txt

#+end_src

#+RESULTS:
#+begin_src org
4|potato vegetable
1|potato fruit
2|banana vegetable
1|banana 5.9
2|banana fruit
#+end_src
这里第一列是每个 =属性1 属性2= 对的数量，第二列是重复的 =属性1 属性2= 对的值。

为了方便复用，我们可以定义一个 =one2many= 的函数：
#+NAME: one2many
#+begin_src shell :tangle /tmp/one2many.sh
  one2many() {
      sep=&quot;$1&quot;                    # 数据分隔符
      one=&quot;$2&quot;                    # 属性1
      many=&quot;$3&quot;                   # 属性2
      file=&quot;$4&quot;                   # 数据文件路径
      awk -F&quot;${sep}&quot; -v one=&quot;${one}&quot; -v many=&quot;${many}&quot; &#39;$one != &quot;&quot; {b[$one][$many]++}
  END {for (i in b)
           {if (length(b[i]) &gt; 1) {
              for (j in b[i])
                  {print b[i][j] FS i FS j}}}}&#39; &quot;${file}&quot;
  }
#+end_src

这个函数与上面命令不同之处在于通过 =-F= 指定数据分隔符，通过 =-v= 将函数参数传递给 awk 变量，使用 =FS= 变量替代 =|= 作为数量与重复属性对之间的分隔符。

那么，我们可以直接使用该函数进行数据检测：
#+begin_src shell :noweb eval :results org
  &lt;&lt;one2many&gt;&gt;
  one2many &quot; &quot; 3 4 /tmp/test.txt
#+end_src

#+RESULTS:
#+begin_src org
4 potato vegetable
1 potato fruit
2 banana vegetable
1 banana 5.9
2 banana fruit
#+end_src

修复相对来说就比较简单了，我们首先创建一个查询表，用来查询 =属性1= 对应的 =属性2=,这个查询可以从 =one2many= 函数的结果中截取：
#+begin_src shell :noweb eval :results org
  &lt;&lt;one2many&gt;&gt;
  one2many &quot; &quot; 3 4 /tmp/test.txt |sed -n &#39;1p;5p&#39; |tee /tmp/lookup
#+end_src

#+RESULTS:
#+begin_src org
4 potato vegetable
2 banana fruit
#+end_src

然后在 awk 中查询 =属性1= 的值若在查询表中则将 =属性2= 的值直接改为查询表中的对应结果：
#+begin_src shell :results org
  awk &#39;FNR==NR {lookup[$1]=$2; next} # 通过FNR==NR判断是否在遍历查询表文件
  $3 in lookup {$4=lookup[$3]} 1&#39; /tmp/lookup /tmp/test.txt # awk 最后那个1表示执行awk 的默认操作，即输出$0
#+end_src

#+RESULTS:
#+begin_src org
saleID	date	item	class	kg
001	2021-01-02	capsicum	vegetable	11.9
002	2021-01-02	banana	fruit	12.7
003	2021-01-02	capsicum	vegetable	3.7
004	2021-01-02	potato	vegetable	4.1
005	2021-01-02	capsicum	vegetable	6.0
006	2021-01-02	potato	fruit	13.0
007	2021-01-02	banana	vegetable	9.1
008	2021-01-02	potato	vegetable	15.0
009	2021-01-02	apple	fruit	5.6
010	2021-01-02	banana	fruit	7.7
011	2021-01-02	pumpkin	vegetable	8.3
012	2021-01-02	pumpkin	vegetable	5.6
013	2021-01-02	apple	fruit	3.5
014	2021-01-02	pumpkin	vegetable	5.3
015	2021-01-02	capsicum	vegetable	10.3
016	2021-01-03	apple	fruit	12.2
017	2021-01-03	pumpkin	vegetable	12.6
018	2021-01-03	potato	vegetable	4.4
019	2021-01-03	apple	fruit	12.5
020	2021-01-03	pumpkin	vegetable	11.6
021	2021-01-03	banana	vegetable	14.5
022	2021-01-03	capsicum	vegetable	4.1
023	2021-01-03	banana		5.9
024	2021-01-03	potato	vegetable	4.8
025	2021-01-03	apple	fruit	15.6
#+end_src
</description>
<pubDate>2021-04-15</pubDate>
<guid>https://lujun9972.github.io/blog/2021/04/15/使用awk查找并修复数据中一对多的不一致问题/index.html</guid>
</item>
<item>
<title>升级库文件后如何查找需要重启的服务</title>
<link>https://lujun9972.github.io/blog/2021/04/14/升级库文件后如何查找需要重启的服务/index.html</link>
<description>从 https://www.cyberciti.biz/faq/how-to-restart-systemd-without-rebooting-linux-when-critical-libraries-installed/ 上看到的一个小技巧。

当升级库文件后，那些使用该库的服务需要重启后才会真正使用该库文件中的内容。一个常用的方法是直接重启系统，这样所有服务在启动时自然使用的是最新库的内容，但是作为服务器是不可能允许随意重启的，那么在不重启的情况下如何找出受到影像的服务呢？

这里有个简单的方法：
#+begin_src shell :dir /ssh:lujun9972@tencent_cloud.lujun9972.win#8022: :results org
  sudo lsof -d &#39;DEL&#39; | grep &#39;lib&#39; | cut -f 1 -d &#39; &#39; | sort -u
#+end_src

#+RESULTS:
#+begin_src org
  acpid
  agetty
  atd
  dbus-daem
  dhclient
  dictd
  gdbus
  gmain
  JS
  lsmd
  master
  polkitd
  qmgr
  sshd
  systemd-l
#+end_src

其原理就是用 lsof 查出所有 FD 为 =DEL(已删除的映射文件)= 且路径中带 =lib= 的命令。然后就可以使用 =systemctl restart= 重启服务了。

不过 =systemd= 本身作为1号进程不能通过 =systemctl restart= 来进行重启，而需要使用 =sudo systemctl daemon-reexec= 来重启。

关于 =systemctl daemon-reexec= 的说明如下：
#+begin_example
  daemon-reexec  Reexecute the systemd manager. This will serialize the manager state, reexecute the process and deserialize the state again. This command is of little use except for debugging and package upgrades. Sometimes, it might be helpful as a heavy-weight daemon-reload. While the daemon is being reexecuted, all sockets systemd listening on behalf of user configuration will stay accessible.
#+end_example
</description>
<pubDate>2021-04-14</pubDate>
<guid>https://lujun9972.github.io/blog/2021/04/14/升级库文件后如何查找需要重启的服务/index.html</guid>
</item>
<item>
<title>Bash中的TryCatch语句</title>
<link>https://lujun9972.github.io/blog/2021/04/14/bash中的trycatch语句/index.html</link>
<description>Bash 中是没有原生的Try Catch 语句的，但是今天从 https://www.xmodulo.com/catch-handle-errors-bash.html 上我看到了一种模拟 Try Catch 的方法。

函数定义如下（经过了一些改造，更好理解一些，而且原文是有一点小错误的）：

#+begin_src shell :tangle :~/bin/lib/trycatch.sh
  function try()
  {
      if [[ $SHELLOPTS = *errexit* ]];then      # $SHELLOPTS 中包含了 shell 的配置项
         ERREXIT_P=&quot;Y&quot;                          # 保存ERREXIT的启用情况
         set +e                                 # 若开启了ERREXIT则需要关闭该配置项，否则后面throw()返回非0值时会直接终止代码运行，也就没法运行后面的catch()语句了
      fi
  }

  function throw()
  {
      exit $1
  }

  function catch()
  {
      export exception_code=$?
      if [[ ${ERREXIT_P} == &quot;Y&quot; ]];then
       set -e                     # 恢复原ERREXIT配置项
      fi
      return $exception_code
  }
#+end_src

这套函数的使用方法如下例子所示：
#+begin_src shell
  # 引入 trycatch 语句
  source ./trycatch.sh

  # 定义异常类型
  export ERR_BAD=100
  export ERR_WORSE=101
  export ERR_CRITICAL=102

  try
  (                               # 注意这里进入子shell执行命令
      echo &quot;Start of the try block&quot;

      # 当命令执行出错（返回非0值），则throw 会退出子shell 的执行，并返回异常.
      run-command || throw $ERR_BAD
      run-command2 || throw $ERR_WORSE
      run-command3 || throw $ERR_CRITICAL

      echo &quot;End of the try block&quot;
  )
  catch || {                      # 若子shell执行有异常，则执行后面 {} 中的语句
      case $exception_code in     # exception_code 中存放的是子 shell 的返回值，在有异常的情况下也就是throw 出来的异常码
          $ERR_BAD)
              echo &quot;This error is bad&quot;
          ;;
          $ERR_WORSE)
              echo &quot;This error is worse&quot;
          ;;
          $ERR_CRITICAL)
              echo &quot;This error is critical&quot;
          ;;
          ,*)
              echo &quot;Unknown error: $exit_code&quot;
              throw $exit_code    # re-throw an unhandled exception
          ;;
      esac
  }
#+end_src

这套TryCatch模拟语句最大的坑莫过于 try 的语句是在子shell 中执行了，这使得 try 中的执行内容无法修改其他代码块中的变量。
</description>
<pubDate>2021-04-14</pubDate>
<guid>https://lujun9972.github.io/blog/2021/04/14/bash中的trycatch语句/index.html</guid>
</item>
<item>
<title>笑话理解之Seeman</title>
<link>https://lujun9972.github.io/blog/2021/03/09/笑话理解之seeman/index.html</link>
<description>
#+begin_example
  What do blondes and the Bermuda Triangle have in common?

  They&#39;ve both swallowed a lot of semen.
#+end_example

=see men=, =semen= 傻傻分不清楚
</description>
<pubDate>2021-03-09</pubDate>
<guid>https://lujun9972.github.io/blog/2021/03/09/笑话理解之seeman/index.html</guid>
</item>
<item>
<title>笑话理解之Denomination</title>
<link>https://lujun9972.github.io/blog/2021/02/24/笑话理解之denomination/index.html</link>
<description>
* Buy stamps
#+begin_example
  A woman walks into the Post Office to buy stamps for her Christmas cards.

  &quot;What denomination?&quot; asks the clerk.

  &quot;Oh, good heavens! Have we come to this?&quot; said the woman. &quot;Well, give me 50 Baptist and 50 Catholic and one Methodist.&quot;
#+end_example

=denomination= 即有 =面额= 也有 =教派= 的意思。
</description>
<pubDate>2021-02-24</pubDate>
<guid>https://lujun9972.github.io/blog/2021/02/24/笑话理解之denomination/index.html</guid>
</item>
<item>
<title>笑话理解之Nail</title>
<link>https://lujun9972.github.io/blog/2021/02/24/笑话理解之nail/index.html</link>
<description>* Nailed it
[[file:images/joke_nail.jpg]]

=nail= 是 =钉牢= 的意思，但是 =nailed it= 是 =搞定= 的意思
</description>
<pubDate>2021-02-24</pubDate>
<guid>https://lujun9972.github.io/blog/2021/02/24/笑话理解之nail/index.html</guid>
</item>
<item>
<title>笑话理解之bday</title>
<link>https://lujun9972.github.io/blog/2021/02/24/笑话理解之bday/index.html</link>
<description>* bday or dday
[[file:images/joke_bday.jpg]]

=bday= 指 =生日=, =D-day= 特指 =诺曼底登陆=
</description>
<pubDate>2021-02-24</pubDate>
<guid>https://lujun9972.github.io/blog/2021/02/24/笑话理解之bday/index.html</guid>
</item>
<item>
<title>笑话理解之letter</title>
<link>https://lujun9972.github.io/blog/2021/02/01/笑话理解之letter/index.html</link>
<description>* envelope
#+begin_example
  What starts with &quot;e&quot;, ends with &quot;e&quot;, and contains one letter?

  An envelope.
#+end_example

=letter= 既有 =字母= 的意思，也有 =信封= 的意思。
</description>
<pubDate>2021-02-01</pubDate>
<guid>https://lujun9972.github.io/blog/2021/02/01/笑话理解之letter/index.html</guid>
</item>
</channel>
</rss>