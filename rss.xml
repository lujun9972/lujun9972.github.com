<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
  <channel>
    <title>暗无天日</title>
    <link>https://lujun9972.github.io</link>
    <description>=============&gt;DarkSun的个人博客</description>
    <pubDate>Sat, 08 Aug 2020 14:31:35 UTC</pubDate>
    <lastBuildDate>Sat, 08 Aug 2020 14:31:35 UTC</lastBuildDate>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <generator>ego static site generator (https://github.com/emacs-china/ego)</generator>
<item>
<title>使用systemd-detect-virt判断Linux是否运行在虚拟机中</title>
<link>https://lujun9972.github.io/blog/2020/08/08/使用systemd-detect-virt判断linux是否运行在虚拟机中/index.html</link>
<description>之前我一直是用 =dmidecode= 来判断Linux是否运行在虚拟环境：

在物理机上：
#+begin_src shell :dir /sudo:: :results org
  sudo dmidecode -s system-product-name
#+end_src

#+RESULTS:
#+begin_src org
2353ABU
#+end_src

在虚拟机上：
#+begin_src shell :dir /ssh:192.168.1.85|sudo:192.168.1.85: :results org
  sudo dmidecode -s system-product-name
#+end_src

#+RESULTS:
#+begin_src org
VirtualBox
#+end_src

但是它有个缺陷，就是不支持容器的检查。在容器中运行 =dmidecode= 会提示错误信息 =/dev/mem: No such file or directory=
若你把 =/dev= 挂载进容器，则又会被识别为物理急。

不过今天我发现，原来 =systemd= 已经提供了一个命令来帮你完成这项任务了，那就是 =systemd-detect-virt=.

在物理机上：
#+begin_src shell :dir /sudo:: :results org
  systemd-detect-virt;exit 0
#+end_src

#+RESULTS:
#+begin_src org
none
#+end_src

在虚拟机上：
#+begin_src shell :dir /ssh:192.168.1.85|sudo:192.168.1.85: :results org
  systemd-detect-virt;exit 0
#+end_src

#+RESULTS:
#+begin_src org
oracle
#+end_src

在容器上:
#+begin_src shell :dir /docker:a4622369efdd: :results org
  systemd-detect-virt;exit 0
#+end_src

#+RESULTS:
#+begin_src org
docker
#+end_src
</description>
<pubDate>2020-08-08</pubDate>
<guid>https://lujun9972.github.io/blog/2020/08/08/使用systemd-detect-virt判断linux是否运行在虚拟机中/index.html</guid>
</item>
<item>
<title>为什么排序数组比未排序数组的处理速度要快?</title>
<link>https://lujun9972.github.io/blog/2020/07/22/为什么排序数组比未排序数组的处理速度要快-/index.html</link>
<description>今天在 Stack Overflow 上看到一个有趣的问题： Why is processing a sorted array faster than processing an unsorted array?

提问者列了一段代码：
#+begin_src C++ :results org
  #include &lt;algorithm&gt;
  #include &lt;ctime&gt;
  #include &lt;iostream&gt;

  int main()
  {
    // 生成数据
    const unsigned arraySize = 32768;
    int data[arraySize];

    for (unsigned c = 0; c &lt; arraySize; ++c)
      data[c] = std::rand() % 256;

    // !!! 这一行会导致后面的循环运行速度变快.
    // std::sort(data, data + arraySize);

    // 测试运算速度
    clock_t start = clock();
    long long sum = 0;

    for (unsigned i = 0; i &lt; 100000; ++i)
      {
        // 主循环
        for (unsigned c = 0; c &lt; arraySize; ++c)
          {
            if (data[c] &gt;= 128)
              sum += data[c];
          }
      }

    double elapsedTime = static_cast&lt;double&gt;(clock() - start) / CLOCKS_PER_SEC;

    std::cout &lt;&lt; elapsedTime &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;sum = &quot; &lt;&lt; sum &lt;&lt; std::endl;
  }
#+end_src

这段代码奇就奇怪在当注释掉 =std::sort(data, data + arraySize);= 这行代码后，循环运算的速度有了明显的提升。

比如在我Win10 的 WSL 上加上排序代码后的运算时间为 =6.65907= 秒，去掉排序代码后的运算时间为 =20.5398=.

那么产生这一现象的原因是什么呢？那就是分支预测。

分支预测(Branch Prediction)是一种用来解决分支指令导致流水线失败的方法。
即CPU的分支预测器预测条件表达式中哪一路最可能发生，然后根据预测结果进行取指令和执行指令等操作。
这样一来，在预测成功的情况下，CPU就避免了由于流水线停顿而导致的时间浪费。而在分支预测错误的情况下，则需要将流水线中推测执行的所有中间结果全部放弃，重新从另一个分支出发取指令和执行指令。
由于现代的CPU使用的流水线普遍很长，一般分支预测失败会损失大约10-20个时钟周期。

那么回到上面的这段代码。代码中有且仅有一个分支语句就是 ~if (data[c] &gt;= 128)~,而这个语句就是导致两个数组运算速度差距如此之大的罪魁祸首。

现代的CPU普遍采用动态预测器，即根据历史的分支执行信息来进行预测。
比如最简单的1 bit 动态预测就是直接根据该指令上次是否跳转来预测此次是否跳转。如果上次跳转，则预测此次也会跳转。
当然实际使用的动态预测模型不会这么简单啦。

当预先对数组进行排序后，预测变得十分简单，因此在执行过程中CPU可以充分利用流水线的能力进行加速。
而在完全随机的情况下，预测变得不可能，CPU猜错的概率为 50%,也就是有一半的概率需要清空流水线，损失那10-20个时钟周期。

由于条件语句能够极大的干扰 CPU 流水线的运行，因此一个常用的提速方法就是去掉条件语句，比如在最高赞的那个答案中，给出的解决方案就是把
#+begin_src C
  if (data[c] &gt;= 128)
    sum += data[c];
#+end_src

改写成
#+begin_src C
  int t = (data[c] - 128) &gt;&gt; 31;
  sum += ~t &amp; data[c];
#+end_src

不过这个可读性不是一般的差～～～

随便一提，在这个问题后面还有一个高赞答案是使用 =?:= (据说会编译成条件传送指令cmov)进行改写:
#+begin_src C
  sum += data[c] &gt;=128 ? data[c] : 0;
#+end_src

但是我测试的结果发现这样修改后的速度并没有变快,不知道是什么原因。
</description>
<pubDate>2020-07-22</pubDate>
<guid>https://lujun9972.github.io/blog/2020/07/22/为什么排序数组比未排序数组的处理速度要快-/index.html</guid>
</item>
<item>
<title>笑话理解之blow</title>
<link>https://lujun9972.github.io/blog/2020/07/17/笑话理解之blow/index.html</link>
<description>#+begin_example
  What&#39;s the difference between your paycheck and your dict?

  You don&#39;t have to beg your wife to blow your paycheck!
#+end_example

=blow= 有 =挥霍= 的意思，另一个意思 =blowjob=, 你懂得。
</description>
<pubDate>2020-07-17</pubDate>
<guid>https://lujun9972.github.io/blog/2020/07/17/笑话理解之blow/index.html</guid>
</item>
<item>
<title>笑话理解之crane</title>
<link>https://lujun9972.github.io/blog/2020/07/17/笑话理解之crane/index.html</link>
<description>* What kind of bird can carry the most weight?

#+begin_example
  What kind of bird can carry the most weight?

  The crane!
#+end_example

=crane= 即可以表示 =鹤=,也可以表示 =起重机=
</description>
<pubDate>2020-07-17</pubDate>
<guid>https://lujun9972.github.io/blog/2020/07/17/笑话理解之crane/index.html</guid>
</item>
<item>
<title>笑话理解之cum</title>
<link>https://lujun9972.github.io/blog/2020/07/17/笑话理解之cum/index.html</link>
<description>* How do you cancel an appointment at the sperm bank?
#+begin_example
  How do you cancel an appointment at the sperm bank?

  Ring up and say you cannot cum.
#+end_example

=cum= 音同 =come=, 其中一个意思是：
#+begin_example
  Cum is a vulgar slang word for the liquid that comes out of the penis during ejaculation.
  Sometimes spelled com, this is very inappropriate word.

  When a man cums, he produces cum: this word can be a noun or verb.
#+end_example
</description>
<pubDate>2020-07-17</pubDate>
<guid>https://lujun9972.github.io/blog/2020/07/17/笑话理解之cum/index.html</guid>
</item>
<item>
<title>笑话理解之honey</title>
<link>https://lujun9972.github.io/blog/2020/07/17/笑话理解之honey/index.html</link>
<description>* What did the bee say to the flower?
#+begin_example
  What did the bee say to the flower?

  Hello honey!
#+end_example

honey: =蜂蜜=, =爱人=
</description>
<pubDate>2020-07-17</pubDate>
<guid>https://lujun9972.github.io/blog/2020/07/17/笑话理解之honey/index.html</guid>
</item>
<item>
<title>笑话理解之lay</title>
<link>https://lujun9972.github.io/blog/2019/06/09/笑话理解之lay/index.html</link>
<description>* Three Nuns
#+begin_example
  Three Italian nuns die and go to heaven.

  At the Pearly Gates, they are met by St. Peter.

  He says, &quot;Sisters, you all led such exemplary lives that the Lord is granting you six months to go back to earth and be anyone you wish to be.

  The first nun says, &quot;I want to be Sophia Loren..&quot; and *poof* she&#39;s gone.

  The second says, &quot;I want to be Madonna and *poof* she&#39;s gone.

  The third says, &quot;I want to be Sara Pipalini...&quot;

  St. Peter looks perplexed, &quot;Who?&quot;

  &quot;Sara Pipalini,&quot; replies the nun.

  St Peter shakes his head and says, &quot;I&#39;m sorry, but that name just doesn&#39;t ring a bell.&quot;

  The nun then takes a newspaper out of her habit and hands it to St. Peter. St. Peter reads the paper and starts laughing. He hands it back to her and says.

  &quot;No sister, the paper says it was the &#39;Sahara Pipeline&#39; that was laid by 1,400 men in 6 months.&quot;
#+end_example

=lay= 既有 =铺设= 也有 =与...性交= 的意思。

* Why do chickens lay eggs
#+begin_example
  Why do chickens lay eggs?

  Because if they drop them they will break!
#+end_example

=lay= 既有 =下蛋= 也有 =放置，铺设= 的意思。
</description>
<pubDate>2020-07-13</pubDate>
<guid>https://lujun9972.github.io/blog/2019/06/09/笑话理解之lay/index.html</guid>
</item>
<item>
<title>笑话理解之divide与multiply</title>
<link>https://lujun9972.github.io/blog/2020/06/22/笑话理解之divide与multiply/index.html</link>
<description>#+begin_example
  One attractive young businesswoman to another over lunch: &quot;My life is all math. I am trying to add to my income, subtract from my weight, divide my time, and avoid multiplying.&quot;
#+end_example

=divide=  在数学用语中是 =除法=, 同时也有 =分割= 的意思。

=multiply= 在数学用于中是 =乘法=, 同时也有 =繁殖= 的意思。
</description>
<pubDate>2020-06-22</pubDate>
<guid>https://lujun9972.github.io/blog/2020/06/22/笑话理解之divide与multiply/index.html</guid>
</item>
<item>
<title>如何通过HTTP协议访问指定版本的SVN库内容</title>
<link>https://lujun9972.github.io/blog/2020/06/20/如何通过http协议访问指定版本的svn库内容/index.html</link>
<description>在汇总晨检报告时，有同事反馈提交的内容被覆盖了，需要从某个指定版本中取出被覆盖的内容。
然而我在跳板机上只能通过HTTP协议用浏览器访问SVN仓库，默认访问的是最新版本内容。

那么要如何通过HTTP协议访问指定版本的内容呢?经过一番搜索，在 http://beerpla.net/2010/02/20/how-to-view-a-specific-svn-revision-in-your-browser/ 找到了解决方法，于是想着记录下来。

方法其实很简单，就是在URL的仓库根后面加上 =/!svn/bc/版本号/= 即可。

比如，我们想要看 https://plugins.svn.wordpress.org/stats/trunk/readme.txt 的 100000 版本的内容，我们可以这么做：

1. 找到仓库的根URL为 https://plugins.svn.wordpress.org
2. 在仓库根URL后加上 =/!svn/bc/100000/=: https://plugins.svn.wordpress.org/!svn/bc/100000/
3. 接上后续的文件路径: https://plugins.svn.wordpress.org/!svn/bc/100000/stats/trunk/readme.txt

所以访问路径 https://plugins.svn.wordpress.org/!svn/bc/100000/stats/trunk/readme.txt 即可。

另外，若 SVN 版本操作1.6,还可以通过在 URL 后添加 ~?p=版本号~, 也即访问 https://plugins.svn.wordpress.org/stats/trunk/readme.txt?p=100000 也能起到相同的作用。
 
</description>
<pubDate>2020-06-20</pubDate>
<guid>https://lujun9972.github.io/blog/2020/06/20/如何通过http协议访问指定版本的svn库内容/index.html</guid>
</item>
<item>
<title>如何设置git push和git pull的超时时间？</title>
<link>https://lujun9972.github.io/blog/2020/06/03/如何设置git-push和git-pull的超时时间？/index.html</link>
<description>不知道为什么，最近从 github 上git push 和 git pull 的时候总是不太稳定，有时候 pull 了半天都拉不下来，然后中断后重试一次又很顺畅了。

所以我想主动设置git push 和 git pull 的超时时间，这样我可以在脚本中监测退出状态后自动进行重试，而不是死等。

目前来看，似乎 =git= 并没有一个配置项是能保证超过一段时间后一定终止退出的，只能通过 =timeout= 命令才能保证超时退出。

然而很多 UNIX 系统没有 =timeout= 命令怎么办呢？我目前只找到两个近似的解决方案，希望各位大神能提供其他的解决方法。

首先，通过  =man git-config= 我们可以发现 =http.lowSpeedLimit= 和 =http.lowSpeedTime= 这两个选项是近似满足要求的：
#+begin_example
  http.lowSpeedLimit, http.lowSpeedTime
      If the HTTP transfer speed is less than http.lowSpeedLimit for
      longer than http.lowSpeedTime seconds, the transfer is aborted. Can
      be overridden by the GIT_HTTP_LOW_SPEED_LIMIT and
      GIT_HTTP_LOW_SPEED_TIME environment variables.
#+end_example

然而这两个选项只针对 HTTP 协议生效，其他协议则需要另辟蹊径。

另一方面，既然 git 的低层是使用 ssh 协议，那么其实我们可以通过通过配置 =ssh_config= 的 =ConnectTimeout= 来设置连接服务器的超时时间。
但这个选项只针对连接服务器这个阶段生效（即创建连接，SSH 握手和密钥交换这三个阶段），之后就无法进行超时约束了。


</description>
<pubDate>2020-06-03</pubDate>
<guid>https://lujun9972.github.io/blog/2020/06/03/如何设置git-push和git-pull的超时时间？/index.html</guid>
</item>
</channel>
</rss>