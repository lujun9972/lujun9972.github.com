<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
  <channel>
    <title>暗无天日</title>
    <link>https://lujun9972.github.io</link>
    <description>=============&gt;DarkSun的个人博客</description>
    <pubDate>Sat, 07 Aug 2021 10:42:16 UTC</pubDate>
    <lastBuildDate>Sat, 07 Aug 2021 10:42:16 UTC</lastBuildDate>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <generator>ego static site generator (https://github.com/emacs-china/ego)</generator>
<item>
<title>AIX中的timeout脚本</title>
<link>https://lujun9972.github.io/blog/2021/07/27/aix中的timeout脚本/index.html</link>
<description>AIX 下没有现成的 =timeout= 命令来限时运行命令，于是就想着自己实现一个类似的脚本。本来以为挺简单的一件事情，结果埋者一堆坑。

最初的结果如下：
#+begin_src shell 
  #! /usr/bin/ksh
  waitfor=$1
  shift
  command=$*
  $command &amp;
  commandpid=$!
  (sleep $waitfor;kill $commandpid) &amp; # 坑1
  watchdogpid=$!
  wait $commandpid
  kill $watchdogpid               # 坑2
#+end_src

这里有两个需要关注的地方：
1. =(sleep $waitof;kill $commandpid) &amp;= 在超时杀掉工作命令后就退出了，工作命令被杀掉之后 =wait $commandpid= 执行完成，主进程继续执行 =kill $watchdogpid=.
   然而由于监控进程早已退出，在忙碌的系统中，可能出现 =$watchdogpid= 被其他进程重复使用，导致误杀其他进程的风险。
   要解决这一风险，可以让监控进程在杀掉工作进程后再等待一段时间，以便让主进程杀掉监控进程。
2. =kill $watchdogpid= 在 =ksh= 中并不会把子进程一起杀掉，也就是说 =sleep $waitfor= 这个进程依然在运行，只不过父进程从 =$watchdogpid= 变成了 =1=.
   不仅如此 =AIX= 上的 =kill= 居然不支持 =PID= 为负数的情况，这使得妄想通过 =kill -$watchdogpid= 杀掉整个进程组变得不可能。


最后经过尝试，发现在ksh交互模式下，用 =kill %jobID= 的方式是能够将整个 =JOB= 杀干净的，因此最后的结果如下：
#+begin_src shell 
  #! /usr/bin/ksh -i
  waitfor=$1
  shift
  command=$*
  $command &amp;
  commandpid=$!
  (sleep $waitfor;kill $commandpid;sleep 1) &amp;
  wait $commandpid
  kill %2 &gt;/dev/null 2&gt;&amp;1
#+end_src

不过这种实现有个比较大的缺点就是由于整个实现实在交互式ksh环境中执行的，因此会污染 ksh 的 history 命令历史。


* UPDATE:
教新的 AIX 上搭载的 kill 命令是支持通过将 =PID= 设置为负值来杀掉整个进程组的，这样一来 =timeout= 的实现就简单很多了：
#+begin_src shell 
  timeout()
  {
      waitfor=$1
      shift
      command=$*
      $command &amp;
      commandpid=$!
      (sleep $waitfor;kill $commandpid;sleep 1) &amp;
      watchdogpid=$!
      wait $commandpid
      kill -$watchdogpid               # 杀掉整个进程组
  }
#+end_src
</description>
<pubDate>2021-08-07</pubDate>
<guid>https://lujun9972.github.io/blog/2021/07/27/aix中的timeout脚本/index.html</guid>
</item>
<item>
<title>从命令行追踪新冠肺炎全球疫情数据</title>
<link>https://lujun9972.github.io/blog/2021/08/07/从命令行追踪新冠肺炎全球疫情数据/index.html</link>
<description>今天发现一个好牛逼的网站，可以让我们通过命令行查看新冠肺炎全球疫情数据

1. 查看指定国家的今日疫情数据

通过访问 `https://corona-stats.online/国家名称` 可以获得指定国家的今日疫情数据，例如下面命令查看中国的当前疫情数据：
#+begin_src shell
curl https://corona-stats.online/china
#+end_src

[[file:images/corona19-01.png]]

2. 获取新冠肺炎全球TOP排行榜数据

通过访问 `https://corona-stats.online?top=N` 可以获得感染人数前N的国家今日疫情数据，例如下面命令查看感染人数前5的国家及其疫情数据：
#+begin_src shell
curl https://corona-stats.online?top=5
#+end_src

[[file:images/corona19-02.png]]

3. 指定返回 JSON 格式的数据

通过在访问URL后加上 ~?format=json~ 可以获取 JSON 格式的数据，例如下面命令获取中国今日新冠感染人数的JSON数据集:

#+begin_src shell
curl &quot;https://corona-stats.online/china?format=json&quot; |jq
#+end_src
输出结果为
#+begin_src json
{
  &quot;data&quot;: [
    {
      &quot;updated&quot;: 1628329931927,
      &quot;country&quot;: &quot;China&quot;,
      &quot;countryInfo&quot;: {
        &quot;_id&quot;: 156,
        &quot;iso2&quot;: &quot;CN&quot;,
        &quot;iso3&quot;: &quot;CHN&quot;,
        &quot;lat&quot;: 35,
        &quot;long&quot;: 105,
        &quot;flag&quot;: &quot;https://disease.sh/assets/img/flags/cn.png&quot;
      },
      &quot;cases&quot;: 93605,
      &quot;todayCases&quot;: 107,
      &quot;deaths&quot;: 4636,
      &quot;todayDeaths&quot;: 0,
      &quot;recovered&quot;: 87525,
      &quot;todayRecovered&quot;: 33,
      &quot;active&quot;: 1444,
      &quot;critical&quot;: 39,
      &quot;casesPerOneMillion&quot;: 65,
      &quot;deathsPerOneMillion&quot;: 3,
      &quot;tests&quot;: 160000000,
      &quot;testsPerOneMillion&quot;: 111163,
      &quot;population&quot;: 1439323776,
      &quot;continent&quot;: &quot;Asia&quot;,
      &quot;oneCasePerPeople&quot;: 15377,
      &quot;oneDeathPerPeople&quot;: 310467,
      &quot;oneTestPerPeople&quot;: 9,
      &quot;activePerOneMillion&quot;: 1,
      &quot;recoveredPerOneMillion&quot;: 60.81,
      &quot;criticalPerOneMillion&quot;: 0.03,
      &quot;confirmed&quot;: 93605,
      &quot;countryCode&quot;: &quot;CN&quot;
    }
  ],
  &quot;worldStats&quot;: {
    &quot;country&quot;: &quot;World&quot;,
    &quot;countryCode&quot;: &quot;World&quot;,
    &quot;cases&quot;: 202490517,
    &quot;todayCases&quot;: 130727,
    &quot;deaths&quot;: 4292020,
    &quot;todayDeaths&quot;: 2305,
    &quot;recovered&quot;: 180258478,
    &quot;active&quot;: 17940019,
    &quot;critical&quot;: 95654,
    &quot;casesPerOneMillion&quot;: &quot;25980.31&quot;,
    &quot;confirmed&quot;: 202490517
  }
}
#+end_src
</description>
<pubDate>2021-08-07</pubDate>
<guid>https://lujun9972.github.io/blog/2021/08/07/从命令行追踪新冠肺炎全球疫情数据/index.html</guid>
</item>
<item>
<title>脚本获取TLS/SSL证书失效日期</title>
<link>https://lujun9972.github.io/blog/2021/07/21/脚本获取tls-ssl证书失效日期/index.html</link>
<description>从 https://www.cyberciti.biz/faq/find-check-tls-ssl-certificate-expiry-date-from-linux-unix/ 上看到的使用小脚本，记录一下

在 Web 服务器上可以通过 TLS/SSL 来对服务器和浏览器之间的连接进行加密，TLS/SSL 使用 X509 证书来进行加密，当证书失效后浏览器访问该 Web 服务器就会出现错误提示。
通过下面这个脚本能够获取 TLS/SSL 证书的生效日期和失效日期
#+begin_src shell :var SERVER_NAME=&quot;www.baidu.com&quot; :var PORT=&quot;443&quot; :results org
  exec 2&gt;/dev/null
  openssl s_client -servername ${SERVER_NAME} -connect ${SERVER_NAME}:${PORT} | openssl x509 -noout -dates
#+end_src

#+RESULTS:
#+begin_src org
notBefore=Jul  1 01:16:03 2021 GMT
notAfter=Aug  2 01:16:03 2022 GMT
#+end_src

openssl 是一款非常好用的 TLS/SSL 诊断工具，这里用到了以下参数：

+ s_client :: 将 openssl 作为 TLS/SSL 客户端工具使用
+ -servername ${SERVER_NAME} :: 设置 TLS 的 SNI(Server Name Indication)扩展，该字段用来解决一个服务器拥有多个域名的情况
+ -connect ${SERVER_NAME}:${PORT} :: 指定要连接的TLS/SSL服务器的地址与端口
+ x509 :: X509证书数据解析工具
+ -noout :: 不显示证书内容，只显示证书的状态
+ -dates :: 输出 TLS/SSL 证书的生效日期与实效日期

我们还可以使用 =openssl x509= 直接解析 PEM格式的证书文件：
#+begin_src shell
openssl x509 -noout -dates ${PEM_FILE_PATH}
#+end_src

我们甚至可以直接检查证书是否会在多少秒后失效，从而达到预警的效果：
#+begin_src shell :var SERVER_NAME=&quot;www.baidu.com&quot; :var PORT=&quot;443&quot; :results org
  exec 2&gt;/dev/null
  openssl s_client -servername ${SERVER_NAME} -connect ${SERVER_NAME}:${PORT} | openssl x509 -noout -checkend $((365*24*3600))
#+end_src

#+RESULTS:
#+begin_src org
Certificate will not expire
#+end_src
</description>
<pubDate>2021-07-22</pubDate>
<guid>https://lujun9972.github.io/blog/2021/07/21/脚本获取tls-ssl证书失效日期/index.html</guid>
</item>
<item>
<title>笑话理解之Fission</title>
<link>https://lujun9972.github.io/blog/2021/06/24/笑话理解之fission/index.html</link>
<description>#+begin_example
  What can you do in radiation-contaminated rivers?

  Nuclear fission.
#+end_example

=fission= 音同 =fishing=
</description>
<pubDate>2021-06-24</pubDate>
<guid>https://lujun9972.github.io/blog/2021/06/24/笑话理解之fission/index.html</guid>
</item>
<item>
<title>笑话理解之Funny</title>
<link>https://lujun9972.github.io/blog/2021/06/24/笑话理解之funny/index.html</link>
<description>* taste of clowns

#+begin_example
  Why don&#39;t cannibals eat clowns?

  Because they taste funny!
#+end_example

=funny= 既有 =好笑= 也有 =古怪= 的意思
</description>
<pubDate>2021-06-24</pubDate>
<guid>https://lujun9972.github.io/blog/2021/06/24/笑话理解之funny/index.html</guid>
</item>
<item>
<title>笑话理解之Move</title>
<link>https://lujun9972.github.io/blog/2021/06/24/笑话理解之move/index.html</link>
<description>* When will my baby move?
#+begin_example
  I&#39;m two months pregnant now. When will my baby move?

  With any luck, right after it finishes college.
#+end_example

=move= 既有 =动= 的意思，也有 =离家= 的意思
</description>
<pubDate>2021-06-24</pubDate>
<guid>https://lujun9972.github.io/blog/2021/06/24/笑话理解之move/index.html</guid>
</item>
<item>
<title>笑话理解之Muffin</title>
<link>https://lujun9972.github.io/blog/2021/06/24/笑话理解之muffin/index.html</link>
<description>#+begin_example
  A little girl goes to the barbers with her dad and stands next to the chair eating a muffin while her dad gets a haircut.

  The barber smiles at her and says: &quot;Your gonna get hair on your muffin!&quot;

  &quot;I know&quot; she says &quot;im gonna get tits too you dirty old bastard!&quot;
#+end_example

=hair= 即可以指 =头发=,也可以统指 =毛发=, =muffin= 是 =松饼= 的意思，同时也是 =女阴= 的粗俗说法。
</description>
<pubDate>2021-06-24</pubDate>
<guid>https://lujun9972.github.io/blog/2021/06/24/笑话理解之muffin/index.html</guid>
</item>
<item>
<title>笑话理解之Solution</title>
<link>https://lujun9972.github.io/blog/2021/06/24/笑话理解之solution/index.html</link>
<description>* teach a blonde maths
#+begin_example
  How do you teach a blonde maths?

  Add a bed, subtract her knickers, divide her legs, enter your square root, leave your solution and hope she doesn&#39;t multiply!
#+end_example

=solution= 既有 =解决方案= 的意思，也有 =溶液= 的意思。
</description>
<pubDate>2021-06-24</pubDate>
<guid>https://lujun9972.github.io/blog/2021/06/24/笑话理解之solution/index.html</guid>
</item>
<item>
<title>ftp中的put命令</title>
<link>https://lujun9972.github.io/blog/2021/06/17/ftp中的put命令/index.html</link>
<description>一次程序缺陷，让我发现了对 ftp 中 put 指令的一些误解(vsftpd 2.2.2,其他fpt服务软件是不是这样每试验过)：

FTP 中的 put 指令分两种格式，一种是 =put 源文件=, 一种是 =put 源文件 目标文件地址=.
其中 =put 源文件 目标文件地址= 的意义很明确，就是把 =本地的源文件= 发送到 =远程主机的目标文件地址=.
误解在于 =put 源文件= 这种格式上，我曾经天真的以为这种格式就是把 =本地的源文件= 发送到 =远程主机的当前目录下=,但是这件事情没有想象中那么简单。
事实上，若 =源文件= 中不带目录，那么结果确实是把 =本地的源文件= 发送到 =远程主机的当前目录下=,
但是若 =源文件= 中带目录，那么结果是把 =本地的源文件= 发送到 =远程主机的相应目录下=.

总结起来如下表所示：

| 指令                             | 意义                                                                                          |
|----------------------------------+-----------------------------------------------------------------------------------------------|
| put file                         | 把 file 上传到远程主机的当前目录下                                                            |
| put srcDir/file                  | 把 srcDir/file 上传为远程主机的 srcDir/file ,若 srcDir 不存在会提示 533 Could not create file |
| put file destDir                 | 不会成功，因为 destDir 无法替换成 file                                                        |
| put srcDir/file destDir          | 不会成功，因为 destDir 无法替换成 file                                                        |
| put file destDir/destFile        | 把 file 上传为远程主机的 srcDir/destFile                                                      |
| put srcDir/file destDir/destFile | 把 srcDir/file 上传为远程主机的 srcDir/destFile                                               |
</description>
<pubDate>2021-06-18</pubDate>
<guid>https://lujun9972.github.io/blog/2021/06/17/ftp中的put命令/index.html</guid>
</item>
<item>
<title>eva-after-load与mode-hook的区别</title>
<link>https://lujun9972.github.io/blog/2021/06/15/eva-after-load与mode-hook的区别/index.html</link>
<description>从 [[https://stackoverflow.com/questions/2736087/eval-after-load-vs-mode-hook#:~:text=Code%20wrapped%20in%20eval-after-load%20will%20be%20executed%20only,code%2C%20there%27s%20no%20notion%20of%20the%20%22current%20buffer%22.][eval-after-load vs. mode hook]] 中看到的，记录一下。

=eva-after-load= 与 =mode-hook= 都能用来对某个特点的 =mode= 进行设置，但是他们之间还是有一些区别的：

+ eval-after-load 只会执行一次，因此通常用来对全局变量的默认值进行一次性的设置，而不会对 buffer-local 之类的变量进行设置
+ eval-after-load 执行时， =current buffer= 为 =null=
+ mode-hook 在每次有 buffer 进入指定 mode 时执行，因此它通常用来对某个具体的 buffer 进行设置
+ mode-hook 执行的时间要晚于 =eval-after-load=
</description>
<pubDate>2021-06-15</pubDate>
<guid>https://lujun9972.github.io/blog/2021/06/15/eva-after-load与mode-hook的区别/index.html</guid>
</item>
</channel>
</rss>