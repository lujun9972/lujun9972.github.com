<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
  <channel>
    <title>暗无天日</title>
    <link>https://lujun9972.github.io</link>
    <description>=============&gt;DarkSun的个人博客</description>
    <pubDate>Fri, 28 Aug 2020 13:40:10 UTC</pubDate>
    <lastBuildDate>Fri, 28 Aug 2020 13:40:10 UTC</lastBuildDate>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <generator>ego static site generator (https://github.com/emacs-china/ego)</generator>
<item>
<title>sc:命令行里的电子表格</title>
<link>https://lujun9972.github.io/blog/2020/08/25/sc-命令行里的电子表格/index.html</link>
<description>Linux下的电子表格软件非常多，比如国产的WPS演示、LibreOffice Calc、Gnumeric、KSpread、Xspread。
但是这写软件都是运行在图形环境下的。而今天介绍的sc跟那些妖艳是不一样的，它运行在终端环境中。

* 安装
常见Linux发行版的仓库中都有该软件包，因此可以直接使用包安装工具安装
#+begin_src shell :dir /ssh:192.168.1.9|sudo:192.168.1.9:
  sudo apt install -y sc
#+end_src

* 界面说明
直接运行 =sc= 命令就启动了 =sc= 软件。其界面如下所示：

[[file:./images/screenshot-74.png]]
可以看出其界面跟常见的电子表格应用非常类似，也是用字母表示列，用数字表示行，一个单元格的位置由表示列的字母和行的数字组成，比如B2表示第2列第3行这个单元格。

而一个输入了内容的sc界面如下所示：

[[file:./images/screenshot-76.png]]

注意到第一行的 =D25 (10 2 0) [1.23456]=,它的意思是：
+ =D25= 为当前单元格的位置，光标目前处于D列25行所在的这个单元格处
+ =(10 2 0)= 为当前单元格的现实格式，其中第一个 =10= 表示单元格显示10位，多于10位的内容会显示为多个 =*=; 第二个 =2= 表示数字保留小数点后2位; 第三位用来表示是否使用科学计数法来表示数字， =0= 表示不用， =1= 表示用。
+ [1.23456] :: =[]= 表示该单元格的值为数字，1.23456为实际的值。若该单元格中的值为字符串，则该字符串会被引号应用起来，且在字符串前会有一个表示对齐方式的字符（&lt;表示左对齐、&gt;表示右对齐、|表示中间对齐）

* 常见操作

** 输入数据

[[file:./images/screenshot-77.png]]

+ 按下 ~=~ 表示输入数字(10)、其他单元格引用(D5)或是公式(@sum(A0:A5)
+ 按下 ~&lt;~ 表示输入左对齐的字符串
+ 按下 ~&gt;~ 表示输入右对齐的字符串
+ 按下 ~\~ 表示输入中间对齐的字符串
+ 按下 ~{~ 表示调整当前单元格的字符串为左对齐
+ 按下 ~}~ 表示调整当前单元格的字符串为右对齐
+ 按下 ~|~ 表示调整当前单元格的字符串为中间对齐

** 移动光标
sc的很多操作借鉴了vi的快捷键，你可以通过

+ =h/左箭头= 将光标移动到左边的一个单元格
+ =j/Ctrl+n/下箭头= 将光标移动到下边的一个单元格
+ =k/Ctrl+p/上箭头= 将光标移动到上边的一个单元格
+ =l/右箭头= 将光标移动到右边的一个单元格
+ =g位置= 将光标直接跳转到指定位置的单元格
+ =Ctrl+b= 上一页
+ =Ctrl+f= 下一叶


** 添加/删除单元格

+ =ir= 在光标上面插入一行空单元格
+ =ic= 在光标左边插入一列空单元格
+ =dr= 删除并复制光标所在的那一行单元格
+ =dc= 删除并复制光标所在的那一列单元格
+ =dd= 删除并复制光标所在的单元格
+ =yr= 复制光标所在行
+ =yc= 复制光标所在列
+ =yy= 复制光标所在单元格
+ =pr= 将复制内容粘贴为上一行的内容
+ =pc= 将复制内容粘贴为左一列的内容
+ =pp= 将复制内容粘贴在当前单元格

** 修改单元格内容
我们可以通过输入数据的方式来直接覆盖原单元格内容。但若原单元格中的内容很复杂，而我们只是想要对其进行一些微调的话，那么

+ 若原单元格为数字、单元格引用或公式，则按下 =e= 键进入修改模式，修改时的操作方式跟vi一致
+ 若原单元格为字符串，则按下 =E= 键进入修改模式，修改时的操作方式跟vi一致

** 设置单元格格式
通过 =f= 键可以对单元格的显示格式进行设置，按下后进入格式调整模式，在这个模式下

+ 按下 =l= 或 =右方向键= 可以调大该列单元格显示的宽度
+ 按下 =h= 或 =左方向键= 可以调小该列单元格显示的宽度
+ 按下 =k= 或 =上方向键= 可以调大该列单元格的小数点精度
+ 按下 =j= 或 =下方向键= 可以调小该列单元格的小数点精度
  
调整的过程会实时调整单元格的显示，调整好后按下 =回车= 退出格式调整模式。

[[file:images/sc01.gif]]

** 隐藏行列
当编辑大型的表格时，常常会需要隐藏一些多余的行和列。这些操作可以通过 =Z= (zap) 命令来实现。

+ =Zc= 隐藏光标所在的列
+ =Zr= 隐藏光标所在的行
  
要显示之前隐藏的行列时，则可以通过 =s= (show) 命令来实现。

+ =sc= 显示隐藏的列
+ =sr= 显示隐藏的行

** 拷贝/删除单元格内容

+ =x= 键可以删除单元格的内容
+ =m字母= 表示将当前单元格的内容存入 =字母= 表示的寄存器中。
+ =c字母= 表示从 =字母= 表示的寄存器中拷贝出单元格内容。

** 公式

按下 ~=~ 键后不仅可以输入数字，还能输入公式，例如要计算B4和B6的值那么可以输入 ~=B4+B6~.

在公式中我们还可以使用函数，例如输入 ~=@sum(A1:A10)~ 就会将A1到A10的值进行累加了。

sc内置有许多常见的公式，详情可以运行 =man sc= 来进行查看。

** 保存/加载工作簿

+ 使用 =P &quot;/tmp/file.sc&quot;= 来将内容保存到 =/tmp/file.sc= 文件中
+ 使用 =G &quot;/tmp/file.sc&quot;= 来将当前内容清空，并加载 =/tmp/file.sc= 文件
</description>
<pubDate>2020-08-28</pubDate>
<guid>https://lujun9972.github.io/blog/2020/08/25/sc-命令行里的电子表格/index.html</guid>
</item>
<item>
<title>笑话理解之affair</title>
<link>https://lujun9972.github.io/blog/2020/08/27/笑话理解之affair/index.html</link>
<description>* Fishing Jokes
#+begin_example
  &quot;Do you really believe your husband when he tells you he goes fishing every weekend?&quot; asked Jane&#39;s best friend.

  &quot;Why shouldn&#39;t I?&quot; said Jane.

  &quot;Well, maybe he is having an affair?&quot;

  &quot;No way&quot; said Jane &quot;he never returns with any fish...&quot;
#+end_example

=affair= 即有 =物品= 的意思，也有 =婚外情= 的意思
</description>
<pubDate>2020-08-27</pubDate>
<guid>https://lujun9972.github.io/blog/2020/08/27/笑话理解之affair/index.html</guid>
</item>
<item>
<title>笑话理解之bricklayer</title>
<link>https://lujun9972.github.io/blog/2020/08/27/笑话理解之bricklayer/index.html</link>
<description>* What do you get if you cross a chicken with a cement mixer?
#+begin_example
  What do you get if you cross a chicken with a cement mixer?

  A brick layer!
#+end_example

=layer= 有 =下蛋母鸡= 的意思， =bricklayer= 则是 =砌砖工= 的意思。
</description>
<pubDate>2020-08-27</pubDate>
<guid>https://lujun9972.github.io/blog/2020/08/27/笑话理解之bricklayer/index.html</guid>
</item>
<item>
<title>笑话理解之court</title>
<link>https://lujun9972.github.io/blog/2020/08/27/笑话理解之court/index.html</link>
<description>* The first tennis match in Bible
#+begin_example
Where is the first tennis matching mentioned in the Bible?

When Joseph served in Pharaoh&#39;s court
#+end_example

=court= 即有 =宫廷= 的意思，也有 =篮球，网球等的球场= 的意思。
</description>
<pubDate>2020-08-27</pubDate>
<guid>https://lujun9972.github.io/blog/2020/08/27/笑话理解之court/index.html</guid>
</item>
<item>
<title>笑话理解之on the house</title>
<link>https://lujun9972.github.io/blog/2020/08/27/笑话理解之on-the-house/index.html</link>
<description>#+begin_example
  How do you get a blonde on the roof?

  Tell her drinks are on the house.
#+end_example

=on the house= 不是在房子上的意思，而是 =免费= 的意思。
</description>
<pubDate>2020-08-27</pubDate>
<guid>https://lujun9972.github.io/blog/2020/08/27/笑话理解之on-the-house/index.html</guid>
</item>
<item>
<title>在命令行进行简单的统计分析</title>
<link>https://lujun9972.github.io/blog/2020/08/23/在命令行进行简单的统计分析/index.html</link>
<description>* 使用awk获取最小值、最大值、中位数和平均值

使用awk先把数据存入一个数组中，然后对数组进行排序后就可以自己写代码找出最小值、最大值、中位数和平均值了：

#+begin_src awk :tangle ~/bin/calculate.awk
  #! /usr/bin/awk -f
  {
      sum += $1                   # 假设数据放在第一列
      nums[NR] = $1  # 将数据记录到数组中
  }
  END {
      if (NR == 0) exit  #防止出现处于0的情况To avoid division by zero

      asort(nums)  #  先对数据进行排序，用于记录中位数

      # 计算中位数
      median = (NR % 2 == 0) ? ( nums[NR / 2] + nums[NR / 2 + 1] ) / 2  : nums[int(NR / 2) + 1]

      # 计算平均
      mean = sum/NR

      printf &quot;min = %s, max = %s, median = %s, mean = %s\n&quot;, nums[1], nums[NR], median, mean
  }
#+end_src

我们可以实验一下：
#+begin_src shell :results org
  seq -10 3 30|~/bin/calculate.awk
#+end_src

#+RESULTS:
#+begin_src org
min = -10, max = 29, median = 9.5, mean = 9.5
#+end_src

* 使用datamash进行统计分析
使用awk虽然可以进行统计分析，但是需要自己去实现大量的细节，很麻烦。 =datamash= 则是一个直接提供了基本统计能力的命令行程序。

datamash的使用非常简单，其调用规则为 =datamash 选项 统计操作1 数据列1 [统计操作2 数据列2]...=. 
它会对 =数据列N= 所表示的数据执行 =统计操作N=. 其中 =数据列= 一般是一个表示第几列的数字，但是当数据文件中的第一行是标题时，可以通过 =-H= 选项来指明数据文件中包含标题行，此时 =数据列= 可以是标题名来代替。

** 常见的选项说明

+ 分组 :: datamash支持对数据进行分组统计，通过使用 ~--group=数据列1[,数据列2,数据列3]~ 可以指明根据哪几个域进行分组
+ 排序 :: datamash需要输入的数据是预先经过排序的，若数据未经过排序则需要通过 ~--sort~ 选项预先进行排序
+ 忽略大小写差异 :: 通过 ~--ignore-case~ 选项可以让 datamash 在分组时忽略大小写的差异
+ 设置分隔符 :: 默认情况下datamash使用 ~TAB~ 作为列的分隔符，通过 ~--field-separator=x~ 可以设置 ~x~ 作为列分隔符，也可以通过 ~--whitespace~ 设置使用一个或多个空格或者tab作为分隔符。
+ 转置 :: 通过 ~transpose~ 选项可以交换行列式
+ 反转 :: 通过 ~reverse~ 选项可以反转字段的顺序
+ 跳过空值 :: ~--narm~ 跳过空域

** 常见的统计操作
+ count :: 计算总数据量
+ rand :: 随机返回一个值
+ sum :: 汇总
+ min :: 取最小值
+ max :: 取最大值
+ absmin :: 取绝对值最小的那个值
+ absmax :: 取绝对值最大的那个值
+ range :: 值域范围，即max - min
+ mean :: 取均值
+ median :: 取中位数
+ q1 :: 取第一四分位
+ q3 :: 取第三四分位
+ iqr :: 取四分位距
+ mode :: 取众数
+ antimode :: 取最少出现的数
+ pstdev :: 总体标准差
+ sstdev :: 样本标准差
+ pvar :: 总体方差
+ svar :: 样本方差
+ pskew :: 总体偏度
+ sskew :: 样本偏度
+ pkurt :: 总体峰度
+ skurt :: 样本峰度
+ pcov :: 总体协方差，需要两组数据，用 =列1:列2= 来表示
+ scov :: 样本协方差，需要两组数据，用 =列1:列2= 来表示
+ ppearson :: 总体皮尔逊相关系数，需要两组数据，用 =列1:列2= 来表示
+ spearson :: 样本皮尔逊相关系数，需要两组数据，用 =列1:列2= 来表示

** 例子
比如上面的awk脚本可以用一行datamash命令代替：
#+begin_src shell :results org
  seq -10 3 30|datamash min 1 max 1 median 1 mean 1
#+end_src

#+RESULTS:
#+begin_src org
-10	29	9.5	9.5
#+end_src
</description>
<pubDate>2020-08-23</pubDate>
<guid>https://lujun9972.github.io/blog/2020/08/23/在命令行进行简单的统计分析/index.html</guid>
</item>
<item>
<title>笑话理解之Jet</title>
<link>https://lujun9972.github.io/blog/2020/08/18/笑话理解之jet/index.html</link>
<description>* private jet
[[file:images/joke_jet.jpg]]

=jet= 即有 =喷气式飞机= 的意思，也有 =喷嘴= 的意思。
</description>
<pubDate>2020-08-18</pubDate>
<guid>https://lujun9972.github.io/blog/2020/08/18/笑话理解之jet/index.html</guid>
</item>
<item>
<title>如何禁止eww生成cookie</title>
<link>https://lujun9972.github.io/blog/2020/08/15/如何禁止eww生成cookie/index.html</link>
<description>通过阅读 =eww= 的源代码可以看到 =eww= 是通过 =url= 库来获取HTML页面的，其关键代码如下：
#+begin_src emacs-lisp
  (let ((url-mime-accept-string eww-accept-content-types))
    (url-retrieve url &#39;eww-render
                  (list url nil (current-buffer))))
#+end_src

而 =url= 是通过 =url-cookie= 库来管理cookie的，这个库提供了两个变量来让我们设置哪些URL可以设置Cookie，哪些URL不允许设置Cookie：
+ url-cookie-trusted-urls :: A list of regular expressions matching URLs to always accept cookies from.
+ url-cookie-untrusted-urls :: A list of regular expressions matching URLs to never accept cookies from.

所以可以通过如下设置来完全禁止 eww 生成 cookie.
#+begin_src emacs-lisp
  (setq url-cookie-trusted-urls &#39;()       ;不设置白名单
        url-cookie-untrusted-urls &#39;(&quot;.*&quot;)) ;所有内容都匹配黑名单
#+end_src
</description>
<pubDate>2020-08-15</pubDate>
<guid>https://lujun9972.github.io/blog/2020/08/15/如何禁止eww生成cookie/index.html</guid>
</item>
<item>
<title>为Linux系统开启多因素认证</title>
<link>https://lujun9972.github.io/blog/2020/08/15/为linux系统开启多因素认证/index.html</link>
<description>通常我们登陆系统时只需要输入用户名和密码即可（若是通过SSH登陆则还可以通过密钥对来登陆）。
而多因素认证可以要求用户提供附加的认证信息来加强安全性，这个附加信息可能是一条短信验证码，安全令牌应用生成的一次性密码，指纹等内容。

本文要做的就是通过 google-authenticator 为Linux增加基于安全令牌的多因素认证

* 安装
首先在Linux上安装PAM模块google-authenticator
#+begin_src shell
  sudo pacman -S libpam-google-authenticator
#+end_src

然后，在手机上安装 =小米安全令牌= 应用

* 配置 google-authenticator 模块
运行 =google-authenticator= 来生成 OTP code。该命令会询问是否基于时间生成认证码，并生成一个二维码供你扫描。

[[file:images/OTP.png]]

在手机上打开 =小米安全令牌= 扫描这个二维码就能看认证码了，输入认证码后，再回答几个问题就完成了google-authentiator模块的配置了
#+begin_example
  Enter code from app (-1 to skip): 383791
  Code confirmed
  Your emergency scratch codes are:
    28577389
    12044244
    52789565
    81786311
    51903013

  Do you want me to update your &quot;/home/lujun9972/.google_authenticator&quot; file? (y/n) y

  Do you want to disallow multiple uses of the same authentication
  token? This restricts you to one login about every 30s, but it increases
  your chances to notice or even prevent man-in-the-middle attacks (y/n) y

  By default, a new token is generated every 30 seconds by the mobile app.
  In order to compensate for possible time-skew between the client and the server,
  we allow an extra token before and after the current time. This allows for a
  time skew of up to 30 seconds between authentication server and client. If you
  experience problems with poor time synchronization, you can increase the window
  from its default size of 3 permitted codes (one previous code, the current
  code, the next code) to 17 permitted codes (the 8 previous codes, the current
  code, and the 8 next codes). This will permit for a time skew of up to 4 minutes
  between client and server.
  Do you want to do so? (y/n) y

  If the computer that you are logging into isn&#39;t hardened against brute-force
  login attempts, you can enable rate-limiting for the authentication module.
  By default, this limits attackers to no more than 3 login attempts every 30s.
  Do you want to enable rate-limiting? (y/n) y
#+end_example

* 启用google-authenticator模块
一般来说，通过 =login= 登陆系统要求接触到物理机器，本身安全性已经足够高了，开启多因素认证意义不大，我们主要对通过网络认证的 =sshd= 进行约束。

1. 为 =sshd= PAM启用google-authenticator认证

   往 =/etc/pam.d/sshd= 中添加如下内容:
   #+begin_src conf
     auth required pam_google_authenticator.so nullok
   #+end_src
   
   其中 =nullok= 的意思是对于未配置多因素认证的用户不需要输入认证码。若没有这个参数则会强制要求主机上的所有用户都必须启用多因素认证。

2. 配置 =sshd= 使用PAM进行认证

   编辑 =/etc/ssh/sshd_config= 确定 =UsePAM= 的值为 =yes=

3. 配置 =sshd= 提示输入认证码

   编辑 =/etc/ssh/sshd_config= 确定 =ChallengeResponseAuthentication= 的值为 =yes=

4. 重启 =sshd= 服务
   
   #+begin_src shell
     sudo systemctl restart sshd
   #+end_src


这样一来，通过 =sshd= 登陆 =lujun9972= 这个用户时就会要求输入认证码了，而登陆其他用户时则无需输入验证码:
#+begin_example
  lujun9972@orangepipc2:~$ ssh 192.168.1.206 -p 8022
  The authenticity of host &#39;[192.168.1.206]:8022 ([192.168.1.206]:8022)&#39; can&#39;t be established.
  ECDSA key fingerprint is SHA256:zIiiOyKuX/q7d+CI5HKNTTiqcHQ+QSf+caivgdS/OG8.
  Are you sure you want to continue connecting (yes/no/[fingerprint])? yes
  Warning: Permanently added &#39;[192.168.1.206]:8022&#39; (ECDSA) to the list of known hosts.
  Password: 
  Verification code: 
  Last login: Sat Aug 15 19:35:37 2020 from 127.0.0.1
  Test whether fcitx is running correctly with dbus...
  Fcitx is running correctly.

  =========================================================
  Launch fbterm...
  stdin isn&#39;t a interactive tty!
  lujun9972:~/ $ exit
  logout
  Connection to 192.168.1.206 closed.
  lujun9972@orangepipc2:~$ ssh daddy@192.168.1.206 -p 8022
  Password: 
  Last login: Sat Aug 15 19:37:50 2020 from 127.0.0.1
  [daddy@T520 /]$ exit
  logout
  Connection to 192.168.1.206 closed.
  lujun9972@orangepipc2:~$ 
#+end_example
</description>
<pubDate>2020-08-15</pubDate>
<guid>https://lujun9972.github.io/blog/2020/08/15/为linux系统开启多因素认证/index.html</guid>
</item>
<item>
<title>使用systemd-detect-virt判断Linux是否运行在虚拟机中</title>
<link>https://lujun9972.github.io/blog/2020/08/08/使用systemd-detect-virt判断linux是否运行在虚拟机中/index.html</link>
<description>之前我一直是用 =dmidecode= 来判断Linux是否运行在虚拟环境：

在物理机上：
#+begin_src shell :dir /sudo:: :results org
  sudo dmidecode -s system-product-name
#+end_src

#+RESULTS:
#+begin_src org
2353ABU
#+end_src

在虚拟机上：
#+begin_src shell :dir /ssh:192.168.1.85|sudo:192.168.1.85: :results org
  sudo dmidecode -s system-product-name
#+end_src

#+RESULTS:
#+begin_src org
VirtualBox
#+end_src

但是它有个缺陷，就是不支持容器的检查。在容器中运行 =dmidecode= 会提示错误信息 =/dev/mem: No such file or directory=
若你把 =/dev= 挂载进容器，则又会被识别为物理急。

不过今天我发现，原来 =systemd= 已经提供了一个命令来帮你完成这项任务了，那就是 =systemd-detect-virt=.

在物理机上：
#+begin_src shell :dir /sudo:: :results org
  systemd-detect-virt;exit 0
#+end_src

#+RESULTS:
#+begin_src org
none
#+end_src

在虚拟机上：
#+begin_src shell :dir /ssh:192.168.1.85|sudo:192.168.1.85: :results org
  systemd-detect-virt;exit 0
#+end_src

#+RESULTS:
#+begin_src org
oracle
#+end_src

在容器上:
#+begin_src shell :dir /docker:a4622369efdd: :results org
  systemd-detect-virt;exit 0
#+end_src

#+RESULTS:
#+begin_src org
docker
#+end_src
</description>
<pubDate>2020-08-08</pubDate>
<guid>https://lujun9972.github.io/blog/2020/08/08/使用systemd-detect-virt判断linux是否运行在虚拟机中/index.html</guid>
</item>
</channel>
</rss>