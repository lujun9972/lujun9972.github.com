<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
  <channel>
    <title>暗无天日</title>
    <link>https://lujun9972.github.io</link>
    <description>=============&gt;DarkSun的个人博客</description>
    <pubDate>Sun, 01 Aug 2021 02:34:33 UTC</pubDate>
    <lastBuildDate>Sun, 01 Aug 2021 02:34:33 UTC</lastBuildDate>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <generator>ego static site generator (https://github.com/emacs-china/ego)</generator>
<item>
<title>AIX中的timeout脚本</title>
<link>https://lujun9972.github.io/blog/2021/07/27/aix中的timeout脚本/index.html</link>
<description>AIX 下没有现成的 =timeout= 命令来限时运行命令，于是就想着自己实现一个类似的脚本。本来以为挺简单的一件事情，结果埋者一堆坑。

最初的结果如下：
#+begin_src shell 
  #! /usr/bin/ksh
  waitfor=$1
  shift
  command=$*
  $command &amp;
  commandpid=$!
  (sleep $waitfor;kill $commandpid) &amp; # 坑1
  watchdogpid=$!
  wait $commandpid
  kill $watchdogpid               # 坑2
#+end_src

这里有两个需要关注的地方：
1. =(sleep $waitof;kill $commandpid) &amp;= 在超时杀掉工作命令后就退出了，工作命令被杀掉之后 =wait $commandpid= 执行完成，主进程继续执行 =kill $watchdogpid=.
   然而由于监控进程早已退出，在忙碌的系统中，可能出现 =$watchdogpid= 被其他进程重复使用，导致误杀其他进程的风险。
   要解决这一风险，可以让监控进程在杀掉工作进程后再等待一段时间，以便让主进程杀掉监控进程。
2. =kill $watchdogpid= 在 =ksh= 中并不会把子进程一起杀掉，也就是说 =sleep $waitfor= 这个进程依然在运行，只不过父进程从 =$watchdogpid= 变成了 =1=.
   不仅如此 =AIX= 上的 =kill= 居然不支持 =PID= 为负数的情况，这使得妄想通过 =kill -$watchdogpid= 杀掉整个进程组变得不可能。


最后经过尝试，发现在ksh交互模式下，用 =kill %jobID= 的方式是能够将整个 =JOB= 杀干净的，因此最后的结果如下：
#+begin_src shell 
  #! /usr/bin/ksh -i
  waitfor=$1
  shift
  command=$*
  $command &amp;
  commandpid=$!
  (sleep $waitfor;kill $commandpid;sleep 1) &amp;
  wait $commandpid
  kill %2 &gt;/dev/null 2&gt;&amp;1
#+end_src

不过这种实现有个比较大的缺点就是由于整个实现实在交互式ksh环境中执行的，因此会污染 ksh 的 history 命令历史。
</description>
<pubDate>2021-08-01</pubDate>
<guid>https://lujun9972.github.io/blog/2021/07/27/aix中的timeout脚本/index.html</guid>
</item>
<item>
<title>脚本获取TLS/SSL证书失效日期</title>
<link>https://lujun9972.github.io/blog/2021/07/21/脚本获取tls-ssl证书失效日期/index.html</link>
<description>从 https://www.cyberciti.biz/faq/find-check-tls-ssl-certificate-expiry-date-from-linux-unix/ 上看到的使用小脚本，记录一下

在 Web 服务器上可以通过 TLS/SSL 来对服务器和浏览器之间的连接进行加密，TLS/SSL 使用 X509 证书来进行加密，当证书失效后浏览器访问该 Web 服务器就会出现错误提示。
通过下面这个脚本能够获取 TLS/SSL 证书的生效日期和失效日期
#+begin_src shell :var SERVER_NAME=&quot;www.baidu.com&quot; :var PORT=&quot;443&quot; :results org
  exec 2&gt;/dev/null
  openssl s_client -servername ${SERVER_NAME} -connect ${SERVER_NAME}:${PORT} | openssl x509 -noout -dates
#+end_src

#+RESULTS:
#+begin_src org
notBefore=Jul  1 01:16:03 2021 GMT
notAfter=Aug  2 01:16:03 2022 GMT
#+end_src

openssl 是一款非常好用的 TLS/SSL 诊断工具，这里用到了以下参数：

+ s_client :: 将 openssl 作为 TLS/SSL 客户端工具使用
+ -servername ${SERVER_NAME} :: 设置 TLS 的 SNI(Server Name Indication)扩展，该字段用来解决一个服务器拥有多个域名的情况
+ -connect ${SERVER_NAME}:${PORT} :: 指定要连接的TLS/SSL服务器的地址与端口
+ x509 :: X509证书数据解析工具
+ -noout :: 不显示证书内容，只显示证书的状态
+ -dates :: 输出 TLS/SSL 证书的生效日期与实效日期

我们还可以使用 =openssl x509= 直接解析 PEM格式的证书文件：
#+begin_src shell
openssl x509 -noout -dates ${PEM_FILE_PATH}
#+end_src

我们甚至可以直接检查证书是否会在多少秒后失效，从而达到预警的效果：
#+begin_src shell :var SERVER_NAME=&quot;www.baidu.com&quot; :var PORT=&quot;443&quot; :results org
  exec 2&gt;/dev/null
  openssl s_client -servername ${SERVER_NAME} -connect ${SERVER_NAME}:${PORT} | openssl x509 -noout -checkend $((365*24*3600))
#+end_src

#+RESULTS:
#+begin_src org
Certificate will not expire
#+end_src
</description>
<pubDate>2021-07-22</pubDate>
<guid>https://lujun9972.github.io/blog/2021/07/21/脚本获取tls-ssl证书失效日期/index.html</guid>
</item>
<item>
<title>笑话理解之Fission</title>
<link>https://lujun9972.github.io/blog/2021/06/24/笑话理解之fission/index.html</link>
<description>#+begin_example
  What can you do in radiation-contaminated rivers?

  Nuclear fission.
#+end_example

=fission= 音同 =fishing=
</description>
<pubDate>2021-06-24</pubDate>
<guid>https://lujun9972.github.io/blog/2021/06/24/笑话理解之fission/index.html</guid>
</item>
<item>
<title>笑话理解之Funny</title>
<link>https://lujun9972.github.io/blog/2021/06/24/笑话理解之funny/index.html</link>
<description>* taste of clowns

#+begin_example
  Why don&#39;t cannibals eat clowns?

  Because they taste funny!
#+end_example

=funny= 既有 =好笑= 也有 =古怪= 的意思
</description>
<pubDate>2021-06-24</pubDate>
<guid>https://lujun9972.github.io/blog/2021/06/24/笑话理解之funny/index.html</guid>
</item>
<item>
<title>笑话理解之Move</title>
<link>https://lujun9972.github.io/blog/2021/06/24/笑话理解之move/index.html</link>
<description>* When will my baby move?
#+begin_example
  I&#39;m two months pregnant now. When will my baby move?

  With any luck, right after it finishes college.
#+end_example

=move= 既有 =动= 的意思，也有 =离家= 的意思
</description>
<pubDate>2021-06-24</pubDate>
<guid>https://lujun9972.github.io/blog/2021/06/24/笑话理解之move/index.html</guid>
</item>
<item>
<title>笑话理解之Muffin</title>
<link>https://lujun9972.github.io/blog/2021/06/24/笑话理解之muffin/index.html</link>
<description>#+begin_example
  A little girl goes to the barbers with her dad and stands next to the chair eating a muffin while her dad gets a haircut.

  The barber smiles at her and says: &quot;Your gonna get hair on your muffin!&quot;

  &quot;I know&quot; she says &quot;im gonna get tits too you dirty old bastard!&quot;
#+end_example

=hair= 即可以指 =头发=,也可以统指 =毛发=, =muffin= 是 =松饼= 的意思，同时也是 =女阴= 的粗俗说法。
</description>
<pubDate>2021-06-24</pubDate>
<guid>https://lujun9972.github.io/blog/2021/06/24/笑话理解之muffin/index.html</guid>
</item>
<item>
<title>笑话理解之Solution</title>
<link>https://lujun9972.github.io/blog/2021/06/24/笑话理解之solution/index.html</link>
<description>* teach a blonde maths
#+begin_example
  How do you teach a blonde maths?

  Add a bed, subtract her knickers, divide her legs, enter your square root, leave your solution and hope she doesn&#39;t multiply!
#+end_example

=solution= 既有 =解决方案= 的意思，也有 =溶液= 的意思。
</description>
<pubDate>2021-06-24</pubDate>
<guid>https://lujun9972.github.io/blog/2021/06/24/笑话理解之solution/index.html</guid>
</item>
<item>
<title>ftp中的put命令</title>
<link>https://lujun9972.github.io/blog/2021/06/17/ftp中的put命令/index.html</link>
<description>一次程序缺陷，让我发现了对 ftp 中 put 指令的一些误解(vsftpd 2.2.2,其他fpt服务软件是不是这样每试验过)：

FTP 中的 put 指令分两种格式，一种是 =put 源文件=, 一种是 =put 源文件 目标文件地址=.
其中 =put 源文件 目标文件地址= 的意义很明确，就是把 =本地的源文件= 发送到 =远程主机的目标文件地址=.
误解在于 =put 源文件= 这种格式上，我曾经天真的以为这种格式就是把 =本地的源文件= 发送到 =远程主机的当前目录下=,但是这件事情没有想象中那么简单。
事实上，若 =源文件= 中不带目录，那么结果确实是把 =本地的源文件= 发送到 =远程主机的当前目录下=,
但是若 =源文件= 中带目录，那么结果是把 =本地的源文件= 发送到 =远程主机的相应目录下=.

总结起来如下表所示：

| 指令                             | 意义                                                                                          |
|----------------------------------+-----------------------------------------------------------------------------------------------|
| put file                         | 把 file 上传到远程主机的当前目录下                                                            |
| put srcDir/file                  | 把 srcDir/file 上传为远程主机的 srcDir/file ,若 srcDir 不存在会提示 533 Could not create file |
| put file destDir                 | 不会成功，因为 destDir 无法替换成 file                                                        |
| put srcDir/file destDir          | 不会成功，因为 destDir 无法替换成 file                                                        |
| put file destDir/destFile        | 把 file 上传为远程主机的 srcDir/destFile                                                      |
| put srcDir/file destDir/destFile | 把 srcDir/file 上传为远程主机的 srcDir/destFile                                               |
</description>
<pubDate>2021-06-18</pubDate>
<guid>https://lujun9972.github.io/blog/2021/06/17/ftp中的put命令/index.html</guid>
</item>
<item>
<title>eva-after-load与mode-hook的区别</title>
<link>https://lujun9972.github.io/blog/2021/06/15/eva-after-load与mode-hook的区别/index.html</link>
<description>从 [[https://stackoverflow.com/questions/2736087/eval-after-load-vs-mode-hook#:~:text=Code%20wrapped%20in%20eval-after-load%20will%20be%20executed%20only,code%2C%20there%27s%20no%20notion%20of%20the%20%22current%20buffer%22.][eval-after-load vs. mode hook]] 中看到的，记录一下。

=eva-after-load= 与 =mode-hook= 都能用来对某个特点的 =mode= 进行设置，但是他们之间还是有一些区别的：

+ eval-after-load 只会执行一次，因此通常用来对全局变量的默认值进行一次性的设置，而不会对 buffer-local 之类的变量进行设置
+ eval-after-load 执行时， =current buffer= 为 =null=
+ mode-hook 在每次有 buffer 进入指定 mode 时执行，因此它通常用来对某个具体的 buffer 进行设置
+ mode-hook 执行的时间要晚于 =eval-after-load=
</description>
<pubDate>2021-06-15</pubDate>
<guid>https://lujun9972.github.io/blog/2021/06/15/eva-after-load与mode-hook的区别/index.html</guid>
</item>
<item>
<title>使用curl进行网站测速</title>
<link>https://lujun9972.github.io/blog/2021/06/08/使用curl进行网站测速/index.html</link>
<description>网站访问可以分为下面几个阶段：

+ DNS 域名解析
+ 通过SSL协议交换密钥（HTTPS)
+ 与服务端创建 TCP 访问连接
+ 客户端发起请求
+ 服务端收到请求并准备回应内容
+ 服务端回复回应内容

当我们优化网站速度时通常要现确定哪个阶段是耗时大头。而令我感到惊奇的是，原来 curl 的 =-w= 选项可以让 curl 完成访问网站的操作后将各阶段的耗时情况（以及其他一些访问信息）输出到标准输出。

=man curl= 中关于 =-w= 选项的说明如下：
#+begin_example
  -w, --write-out &lt;format&gt;
         Make curl display information on stdout after a completed trans‐
         fer. The format is a string that may contain  plain  text  mixed
         with  any  number of variables. The format can be specified as a
         literal &quot;string&quot;, or you can have curl read the  format  from  a
         file  with  &quot;@filename&quot; and to tell curl to read the format from
         stdin you write &quot;@-&quot;.

         The variables present in the output format will  be  substituted
         by  the  value or text that curl thinks fit, as described below.
         All variables are specified as %{variable_name} and to output  a
         normal  % you just write them as %%. You can output a newline by
         using \n, a carriage return with \r and a tab space with \t.

         NOTE: The %-symbol is a special symbol in the win32-environment,
         where  all  occurrences  of  %  must  be doubled when using this
         option.

         The variables available are:

         content_type   The Content-Type of the  requested  document,  if
                        there was any.

         filename_effective
                        The  ultimate  filename  that curl writes out to.
                        This is only meaningful if curl is told to  write
                        to  a  file  with  the  -O,  --remote-name or -o,
                        --output option. It&#39;s most useful in  combination
                        with  the -J, --remote-header-name option. (Added
                        in 7.26.0)

         ftp_entry_path The initial path curl ended up in when logging on
                        to the remote FTP server. (Added in 7.15.4)

         http_code      The numerical response code that was found in the
                        last retrieved HTTP(S)  or  FTP(s)  transfer.  In
                        7.18.2  the alias response_code was added to show
                        the same info.

         http_connect   The numerical code that was  found  in  the  last
                        response   (from  a  proxy)  to  a  curl  CONNECT
                        request. (Added in 7.12.4)

         http_version   The  http  version  that  was  effectively  used.
                        (Added in 7.50.0)

         local_ip       The  IP  address  of  the  local  end of the most
                        recently done connection - can be either IPv4  or
                        IPv6 (Added in 7.29.0)

         local_port     The  local  port number of the most recently done
                        connection (Added in 7.29.0)

         num_connects   Number of new connects made in the recent  trans‐
                        fer. (Added in 7.12.3)

         num_redirects  Number  of  redirects  that  were followed in the
                        request. (Added in 7.12.3)

         proxy_ssl_verify_result
                        The result of the HTTPS proxy&#39;s SSL peer certifi‐
                        cate verification that was requested. 0 means the
                        verification was successful. (Added in 7.52.0)

         redirect_url   When an HTTP request was made without -L, --loca‐
                        tion  to follow redirects (or when --max-redir is
                        met), this variable will show the  actual  URL  a
                        redirect would have gone to. (Added in 7.18.2)

         remote_ip      The  remote  IP address of the most recently done
                        connection - can be either IPv4 or IPv6 (Added in
                        7.29.0)

         remote_port    The  remote port number of the most recently done
                        connection (Added in 7.29.0)

         scheme         The URL scheme (sometimes called  protocol)  that
                        was effectively used (Added in 7.52.0)

         size_download  The total amount of bytes that were downloaded.

         size_header    The total amount of bytes of the downloaded head‐
                        ers.

         size_request   The total amount of bytes that were sent  in  the
                        HTTP request.

         size_upload    The total amount of bytes that were uploaded.

         speed_download The average download speed that curl measured for
                        the complete download. Bytes per second.

         speed_upload   The average upload speed that curl  measured  for
                        the complete upload. Bytes per second.

         ssl_verify_result
                        The  result of the SSL peer certificate verifica‐
                        tion that was requested. 0 means the verification
                        was successful. (Added in 7.19.0)

         time_appconnect
                        The  time,  in  seconds,  it  took from the start
                        until the SSL/SSH/etc  connect/handshake  to  the
                        remote host was completed. (Added in 7.19.0)

         time_connect   The  time,  in  seconds,  it  took from the start
                        until the TCP connect  to  the  remote  host  (or
                        proxy) was completed.

         time_namelookup
                        The  time,  in  seconds,  it  took from the start
                        until the name resolving was completed.

         time_pretransfer
                        The time, in seconds,  it  took  from  the  start
                        until  the file transfer was just about to begin.
                        This includes all pre-transfer commands and nego‐
                        tiations that are specific to the particular pro‐
                        tocol(s) involved.

         time_redirect  The time, in seconds, it took for all redirection
                        steps including name lookup, connect, pretransfer
                        and transfer before  the  final  transaction  was
                        started.  time_redirect shows the complete execu‐
                        tion time for multiple  redirections.  (Added  in
                        7.12.3)

         time_starttransfer
                        The  time,  in  seconds,  it  took from the start
                        until the first byte was just about to be  trans‐
                        ferred.  This  includes time_pretransfer and also
                        the time  the  server  needed  to  calculate  the
                        result.

         time_total     The  total time, in seconds, that the full opera‐
                        tion lasted.

         url_effective  The URL that was fetched last. This is most mean‐
                        ingful  if  you&#39;ve  told curl to follow location:
                        headers.

         If this option is used several times, the last one will be used.
#+end_example

其中与时间相关的变量包括：
+ time_namelookup :: DNS 解析时间，可以与 =--resolve= 选项配合寻找最快的DNS
+ time_connect :: 与服务端创建好 TCP 连接的时间，严格来说是客户端回复 ACK 的时间。我们可以通过 =time_connect - time_namelookup= 来大致推断网络延时。
+ time_appconnect :: 完成 SSL/TLS 设置的时间，此时客户端与服务端完成密钥交换，客户端准备发起请求
+ time_pretransfer :: 服务端收到请求的时间
+ time_starttransfer :: 服务端准备好回应内容的时间。
+ time_total :: 完成整个请求的所有时间
+ time_redirect :: 若请求经过多次重定向，那么这个包含直到最后一次请求开始所耗的时间。

下面这张从 [[https://blog.cloudflare.com/a-question-of-timing/][cloudflare]] 偷来的例子可以很直观的看出每个变量的对应关系

#+begin_src shell
curl -so /dev/null -w &quot;dnslookup: %{time_namelookup} | connect: %{time_connect} | appconnect: %{time_appconnect} | pretransfer: %{time_pretransfer} | starttransfer: %{time_starttransfer} | total: %{time_total} | size: %{size_download}\n&quot; https://www.zasag.mn
#+end_src

其中 =-s= 表示进入 =silent= 模式， =-o /dev/null= 表示不显示获取到的文件内容

结果为：
#+begin_example
  dnslookup: 1.510 | connect: 1.757 | appconnect: 2.256 | pretransfer: 2.259 | starttransfer: 2.506 | total: 3.001 | size: 53107
#+end_example

图示如下：
[[file:images/timingOfHTTPS.png]]
</description>
<pubDate>2021-06-08</pubDate>
<guid>https://lujun9972.github.io/blog/2021/06/08/使用curl进行网站测速/index.html</guid>
</item>
</channel>
</rss>