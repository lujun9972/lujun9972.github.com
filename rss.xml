<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
  <channel>
    <title>暗无天日</title>
    <link>https://lujun9972.github.io</link>
    <description>=============&gt;DarkSun的个人博客</description>
    <pubDate>Mon, 17 May 2021 13:52:54 UTC</pubDate>
    <lastBuildDate>Mon, 17 May 2021 13:52:54 UTC</lastBuildDate>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <generator>ego static site generator (https://github.com/emacs-china/ego)</generator>
<item>
<title>笑话理解之Birds and bees</title>
<link>https://lujun9972.github.io/blog/2021/05/17/笑话理解之birds-and-bees/index.html</link>
<description>* birds and bees
#+begin_example
  A father asked his son, Little Johnny, if he knew about the birds and the bees.

  &quot;I don&#39;t want to know!&quot; Little Johnny said, exploding and bursting into tears. Confused, his father asked Little Johnny what was wrong.

  &quot;Oh Pop,&quot; Johnny sobbed, &quot;for me there was no Santa Claus at age six, no Easter Bunny at seven, and no Tooth Fairy at eight. And if you&#39;re telling me now that grown ups don&#39;t really have sex, I&#39;ve got nothing left to believe in!&quot;[2021-05-13 周四 06:30]
#+end_example

=birds and bees= 是 =性事= 的委婉说法
</description>
<pubDate>2021-05-17</pubDate>
<guid>https://lujun9972.github.io/blog/2021/05/17/笑话理解之birds-and-bees/index.html</guid>
</item>
<item>
<title>笑话理解之Pull out</title>
<link>https://lujun9972.github.io/blog/2021/05/17/笑话理解之pull-out/index.html</link>
<description>* why don&#39;t big planes have baby planes?&quot;
#+begin_example
  A mother and her son were flying Southwest Airlines from Kansas City to Chicago. The son (who had been looking out the window) turned to his mother and asked, &quot;If big dogs have baby dogs and big cats have baby cats, why don&#39;t big planes have baby planes?&quot;

  The mother (who couldn&#39;t think of an answer) told her son to ask the stewardess. So the boy asked the stewardess, &quot;If big dogs have baby dogs and big cats have baby cats, why don&#39;t big planes have baby planes?&quot;

  The stewardess responded, &quot;Did your mother tell you to ask me?&quot; The boy admitted that this was the case. &quot;Well, then, tell your mother that there are no baby planes because Southwest always pulls out on time. Your mother can explain that to you.&quot;
#+end_example

=pull out= 有 =起飞= 的意思，也有 =拔出= 的意思。
</description>
<pubDate>2021-05-17</pubDate>
<guid>https://lujun9972.github.io/blog/2021/05/17/笑话理解之pull-out/index.html</guid>
</item>
<item>
<title>笑话理解之Change</title>
<link>https://lujun9972.github.io/blog/2021/05/07/笑话理解之change/index.html</link>
<description>* no change
#+begin_example
  A man was rushed in to hospital yesterday because he swallowed a five pound note.

  They are keeping him in for observation on his condition - but so far there has been no change!
#+end_example

=change= 有 =改变= 的意思，也有 =零钱= 的意思。
</description>
<pubDate>2021-05-07</pubDate>
<guid>https://lujun9972.github.io/blog/2021/05/07/笑话理解之change/index.html</guid>
</item>
<item>
<title>为ping命令增加时间信息的正确方法</title>
<link>https://lujun9972.github.io/blog/2021/04/26/为ping命令增加时间信息的正确方法/index.html</link>
<description>不知道为什么，在网上搜索为 ping 命令增加时间信息方法时，给出来得解决方案都是将 ping 命令的结果传递给一个循环，然后在循环内生成时间。

这个循环可能是一个流式处理命令，比如 awk:
#+begin_src shell :results org
  ping www.baidu.com -c 5 | awk &#39;{ print strftime(&quot;%Y-%m-%d %H:%M:%S&quot;,systime())&quot;\t&quot;$0 }&#39;
#+end_src

#+RESULTS:
#+begin_src org
2021-04-26 11:26:24	PING www.a.shifen.com (14.215.177.38) 56(84) bytes of data.
2021-04-26 11:26:24	64 bytes from 14.215.177.38 (14.215.177.38): icmp_seq=1 ttl=52 time=12.1 ms
2021-04-26 11:26:24	64 bytes from 14.215.177.38 (14.215.177.38): icmp_seq=2 ttl=52 time=9.51 ms
2021-04-26 11:26:25	64 bytes from 14.215.177.38 (14.215.177.38): icmp_seq=3 ttl=52 time=18.4 ms
2021-04-26 11:26:26	64 bytes from 14.215.177.38 (14.215.177.38): icmp_seq=4 ttl=52 time=15.4 ms
2021-04-26 11:26:27	64 bytes from 14.215.177.38 (14.215.177.38): icmp_seq=5 ttl=52 time=9.81 ms
2021-04-26 11:26:27	
2021-04-26 11:26:27	--- www.a.shifen.com ping statistics ---
2021-04-26 11:26:27	5 packets transmitted, 5 received, 0% packet loss, time 10077ms
2021-04-26 11:26:27	rtt min/avg/max/mdev = 9.519/13.089/18.481/3.432 ms
#+end_src

也可能是一个 while 循环语句：
#+begin_src shell :results org
  ping www.baidu.com -c 5 |while read result
  do
      echo &quot;$(date) ${result}&quot;
  done
#+end_src

#+RESULTS:
#+begin_src org
2021年 04月 26日 星期一 11:25:09 CST PING www.a.shifen.com (14.215.177.38) 56(84) bytes of data.
2021年 04月 26日 星期一 11:25:09 CST 64 bytes from 14.215.177.38 (14.215.177.38): icmp_seq=1 ttl=52 time=8.73 ms
2021年 04月 26日 星期一 11:25:09 CST 64 bytes from 14.215.177.38 (14.215.177.38): icmp_seq=2 ttl=52 time=16.4 ms
2021年 04月 26日 星期一 11:25:10 CST 64 bytes from 14.215.177.38 (14.215.177.38): icmp_seq=3 ttl=52 time=9.98 ms
2021年 04月 26日 星期一 11:25:11 CST 64 bytes from 14.215.177.38 (14.215.177.38): icmp_seq=4 ttl=52 time=10.8 ms
2021年 04月 26日 星期一 11:25:12 CST 64 bytes from 14.215.177.38 (14.215.177.38): icmp_seq=5 ttl=52 time=17.3 ms
2021年 04月 26日 星期一 11:25:12 CST 
2021年 04月 26日 星期一 11:25:12 CST --- www.a.shifen.com ping statistics ---
2021年 04月 26日 星期一 11:25:12 CST 5 packets transmitted, 5 received, 0% packet loss, time 7043ms
2021年 04月 26日 星期一 11:25:12 CST rtt min/avg/max/mdev = 8.731/12.684/17.392/3.548 ms
#+end_src

但是这有个问题，那就是时间戳不是由 =ping= 命令生成的，而是在循环体内生成的。这就导致若我们在时间戳生成之前用 =sed= 和 =awk= 之类的命令对 =ping= 结果加工后，由于它们的缓存机制会使得输出到循环的时间比实际 ping 命令产生结果的时间产生较大差别。

例如下面命令的输出中，生成的时间是同一秒，这明显是不对的。
#+begin_src shell :results org
  ping www.baidu.com -c 5|awk &#39;1&#39; | awk &#39;{ print strftime(&quot;%Y-%m-%d %H:%M:%S&quot;,systime())&quot;\t&quot;$0 }&#39;
#+end_src

#+RESULTS:
#+begin_src org
2021-04-26 11:27:01	PING www.a.shifen.com (14.215.177.39) 56(84) bytes of data.
2021-04-26 11:27:01	64 bytes from 14.215.177.39 (14.215.177.39): icmp_seq=1 ttl=52 time=13.2 ms
2021-04-26 11:27:01	64 bytes from 14.215.177.39 (14.215.177.39): icmp_seq=2 ttl=52 time=8.32 ms
2021-04-26 11:27:01	64 bytes from 14.215.177.39 (14.215.177.39): icmp_seq=3 ttl=52 time=18.1 ms
2021-04-26 11:27:01	64 bytes from 14.215.177.39 (14.215.177.39): icmp_seq=4 ttl=52 time=8.61 ms
2021-04-26 11:27:01	64 bytes from 14.215.177.39 (14.215.177.39): icmp_seq=5 ttl=52 time=9.09 ms
2021-04-26 11:27:01	
2021-04-26 11:27:01	--- www.a.shifen.com ping statistics ---
2021-04-26 11:27:01	5 packets transmitted, 5 received, 0% packet loss, time 4052ms
2021-04-26 11:27:01	rtt min/avg/max/mdev = 8.322/11.492/18.191/3.794 ms
#+end_src


事实上，通过查看 =ping= 命令的 manual, 我们可以发现 ping 命令的 =-D= 选项本身就会为每一行输出生成时间戳：
#+begin_example
   -D     Print timestamp (unix time + microseconds as in gettimeofday) before each line.
#+end_example

#+begin_src shell :results org
  ping -c 5 www.baidu.com -D
#+end_src

#+RESULTS:
#+begin_src org
PING www.a.shifen.com (14.215.177.39) 56(84) bytes of data.
[1619407749.478198] 64 bytes from 14.215.177.39 (14.215.177.39): icmp_seq=1 ttl=52 time=8.86 ms
[1619407749.492436] 64 bytes from 14.215.177.39 (14.215.177.39): icmp_seq=2 ttl=52 time=13.8 ms
[1619407750.493666] 64 bytes from 14.215.177.39 (14.215.177.39): icmp_seq=3 ttl=52 time=13.4 ms
[1619407751.492797] 64 bytes from 14.215.177.39 (14.215.177.39): icmp_seq=4 ttl=52 time=10.5 ms
[1619407752.501662] 64 bytes from 14.215.177.39 (14.215.177.39): icmp_seq=5 ttl=52 time=17.1 ms

--- www.a.shifen.com ping statistics ---
5 packets transmitted, 5 received, 0% packet loss, time 4042ms
rtt min/avg/max/mdev = 8.861/12.776/17.120/2.861 ms
#+end_src

唯一的问题就是这个时间戳采取的是是从1970年1月1日（UTC/GMT的午夜）开始所经过的秒数，不方便理解，但是没关系，我们可以用 =date= 进行一下转换：
#+begin_src shell :results org
  ping -c 5 www.baidu.com -D |awk &#39;1&#39; |while read result
  do
      if [[ &quot;${result}&quot; =~ &quot;[&quot; ]] # 以 [ 开头的行带时间戳
      then
         read timestamp rest &lt; &lt;(echo ${result}|tr -d &#39;[]&#39;)
         echo $(date -d @${timestamp}) &quot;${rest}&quot;
         else
             echo &quot;${result}&quot;
      fi
  done
#+end_src

#+RESULTS:
#+begin_src org
PING www.a.shifen.com (14.215.177.39) 56(84) bytes of data.
2021年 04月 26日 星期一 11:41:25 CST 64 bytes from 14.215.177.39 (14.215.177.39): icmp_seq=1 ttl=52 time=8.97 ms
2021年 04月 26日 星期一 11:41:25 CST 64 bytes from 14.215.177.39 (14.215.177.39): icmp_seq=2 ttl=52 time=7.89 ms
2021年 04月 26日 星期一 11:41:26 CST 64 bytes from 14.215.177.39 (14.215.177.39): icmp_seq=3 ttl=52 time=27.3 ms
2021年 04月 26日 星期一 11:41:27 CST 64 bytes from 14.215.177.39 (14.215.177.39): icmp_seq=4 ttl=52 time=20.6 ms
2021年 04月 26日 星期一 11:41:28 CST 64 bytes from 14.215.177.39 (14.215.177.39): icmp_seq=5 ttl=52 time=22.2 ms

--- www.a.shifen.com ping statistics ---
5 packets transmitted, 5 received, 0% packet loss, time 4069ms
rtt min/avg/max/mdev = 7.897/17.425/27.343/7.671 ms
#+end_src
</description>
<pubDate>2021-04-26</pubDate>
<guid>https://lujun9972.github.io/blog/2021/04/26/为ping命令增加时间信息的正确方法/index.html</guid>
</item>
<item>
<title>笑话理解之Cunt</title>
<link>https://lujun9972.github.io/blog/2021/04/26/笑话理解之cunt/index.html</link>
<description>
* sad life of a penis
#+begin_example
  The sad life a penis: &quot;I only have one eye, my hair is a mess, my skin is wrinkly, and my relatives are nuts, my neighbor is an asshole and my best friend’s a cunt!&quot;
#+end_example

=nuts= 既有 =怪人= 的意思，也有 =睾丸= 的意思,
=asshole= 既有 =肛门= 的意思，也有 =混蛋= 的意思，
=cunt= 既有 =阴道= 的意思，也有 =笨蛋= 的意思。
</description>
<pubDate>2021-04-26</pubDate>
<guid>https://lujun9972.github.io/blog/2021/04/26/笑话理解之cunt/index.html</guid>
</item>
<item>
<title>笑话理解之Devil</title>
<link>https://lujun9972.github.io/blog/2021/04/26/笑话理解之devil/index.html</link>
<description>* scared devil out of people
#+begin_example
  Some ecclesiastical gentlemen -- a cardinal, a couple of bishops and some others -- were waiting outside the Pearly Gates for St. Peter to open up.

  He finally arrived, but just they were about to enter heaven St. Peter asked them to wait a moment and let a new arrival through first.

  A sweet young thing in a mini-skirt arrived and was ushered through.

  The cardinal was a bit upset about this and demanded an explanation from St. Peter. After all, they had been waiting outside for quite some time and were pillars of the church. How could a girl in a mini-skirt deserve better treatment?

  St. Peter smiled and told him, &quot;While she was alive, that young lady drove a little yellow sports car. She regularly jumped red lights, overtook on blind corners, and generally scared the devil out of more people than all of you combined.&quot;
#+end_example

=scared devil out of people= 是把人吓得魂飞破散的意思，但字面意思可以理解为 =把魔鬼从人身体里吓出来=
</description>
<pubDate>2021-04-26</pubDate>
<guid>https://lujun9972.github.io/blog/2021/04/26/笑话理解之devil/index.html</guid>
</item>
<item>
<title>笑话理解之movie</title>
<link>https://lujun9972.github.io/blog/2021/04/26/笑话理解之movie/index.html</link>
<description>* Where do cows go on Friday night?
#+begin_example
  Where do cows go on Friday night?

  To the moo-vies.
#+end_example

=movies=:电影
=moo-vies=: 咩咩叫比赛
</description>
<pubDate>2021-04-26</pubDate>
<guid>https://lujun9972.github.io/blog/2021/04/26/笑话理解之movie/index.html</guid>
</item>
<item>
<title>在Linux下创建内存磁盘的不同方法及区别</title>
<link>https://lujun9972.github.io/blog/2021/04/16/在linux下创建内存磁盘的不同方法及区别/index.html</link>
<description>内存磁盘具有读写速度快和断电即删的特性，非常适用于临时性的测试新鲜应用。
在Linux中提供了 =tmpfs= 和 =ramfs= 两种内存文件系统用于创建内存磁盘，用它们创建内存磁盘的方法几乎一样：
#+begin_src shell
  # 使用 tmpfs 创建内存磁盘
  mount -t tmpfs -o size=1G tmpfs /mnt
  # 使用 ramfs 创建内存磁盘
  mount -t ramfs -o size=1G ramfs /mnt
#+end_src
但在效果上是有一些不同的。

tmpfs 的特点包括：
1. 使用 tmpfs 创建的内存磁盘并不百分百保证是存储在RAM芯片上的，它实际上是存储在 Linux 内核的内存池中，也就是即包含内存也包含虚拟内存。
   由于虚拟内存一般存储在磁盘上，因此速度会比实际的内存慢很多。
2. 由于特点1,tmpfs 的最大可用存储空间为实际内存＋虚拟内存的大小。默认为实际内存的一半。
3. tmpfs 实际使用的空间是随着实际存储的数据而变化的，其 =-size= 参数只是告诉内核这个挂载点最多能用多少内存池中的内存而已，并不是实际占有量。
4. tmpfs 默认挂载的权限为 777


ramfs 的特点包括：
1. 使用 ramfs 创建的内存磁盘百分百存储在实际内存上，因此读写效率可以保证。
2. ramfs 的最大可用存储空间不能超过实际内存大小
3. ramfs 立即占用实际内存，可能会因此而影响主机性能
4. ramfs 默认工作权限为 755
5. *挂载 ramfs 不会在 =df= 命令中显示出来！但能在 =mount= 命令中显示出来*
6. *ramfs 的 =size= 选项其实没什么作用，你可以往里面写大于 =size= 大小的文件，因此要小心不要写入太多东西导致内存耗尽。*
</description>
<pubDate>2021-04-16</pubDate>
<guid>https://lujun9972.github.io/blog/2021/04/16/在linux下创建内存磁盘的不同方法及区别/index.html</guid>
</item>
<item>
<title>使用awk查找并修复数据中一对多的不一致问题</title>
<link>https://lujun9972.github.io/blog/2021/04/15/使用awk查找并修复数据中一对多的不一致问题/index.html</link>
<description>从 https://www.datafix.com.au/BASHing/2021-03-17.html 上看到的一个 =awk= 小技巧。

所谓“一对多”的不一致问题是指这么一种情况：属性1与属性2本来应该是 =1:1= 或者 =N:1= 的关系，但是由于数据错误导致同一个属性1有了多个属性2与之对应。

例如下面数据中， 每个 =item= 本来应该只有唯一的一个 =class=,但是实际上 =banana= 和 =potato= 有多个 =class= 与之对应。
#+begin_example
  saleID	date	item	class	kg
  001	2021-01-02	capsicum	vegetable	11.9
  002	2021-01-02	banana	fruit	12.7
  003	2021-01-02	capsicum	vegetable	3.7
  004	2021-01-02	potato	vegetable	4.1
  005	2021-01-02	capsicum	vegetable	6.0
  006	2021-01-02	potato	fruit	13.0
  007	2021-01-02	banana	vegetable	9.1
  008	2021-01-02	potato	vegetable	15.0
  009	2021-01-02	apple	fruit	5.6
  010	2021-01-02	banana	fruit	7.7
  011	2021-01-02	pumpkin	vegetable	8.3
  012	2021-01-02	pumpkin	vegetable	5.6
  013	2021-01-02	apple	fruit	3.5
  014	2021-01-02	pumpkin	vegetable	5.3
  015	2021-01-02	capsicum	vegetable	10.3
  016	2021-01-03	apple	fruit	12.2
  017	2021-01-03	pumpkin	vegetable	12.6
  018	2021-01-03	potato	vegetable	4.4
  019	2021-01-03	apple	fruit	12.5
  020	2021-01-03	pumpkin	vegetable	11.6
  021	2021-01-03	banana	vegetable	14.5
  022	2021-01-03	capsicum	vegetable	4.1
  023	2021-01-03	banana		5.9
  024	2021-01-03	potato	vegetable	4.8
  025	2021-01-03	apple	fruit	15.6
#+end_example

为了找出一对多的关系，我们需要使用二维数组来保存 =属性1= 和 =属性2= 的关系，然后判断 =属性1= 这个一维数组中是否包含数组个数大于1的数值就行了（原文的判断方法比这要复杂，我简化了一下）。awk 程序如下
#+begin_src shell :results org
awk &#39;{b[$3][$4]++}
END {for (i in b) {if (length(b[i])&gt;1){
            for (j in b[i]){
                print b[i][j] &quot;|&quot; i FS j}}}}&#39; /tmp/test.txt

#+end_src

#+RESULTS:
#+begin_src org
4|potato vegetable
1|potato fruit
2|banana vegetable
1|banana 5.9
2|banana fruit
#+end_src
这里第一列是每个 =属性1 属性2= 对的数量，第二列是重复的 =属性1 属性2= 对的值。

为了方便复用，我们可以定义一个 =one2many= 的函数：
#+NAME: one2many
#+begin_src shell :tangle /tmp/one2many.sh
  one2many() {
      sep=&quot;$1&quot;                    # 数据分隔符
      one=&quot;$2&quot;                    # 属性1
      many=&quot;$3&quot;                   # 属性2
      file=&quot;$4&quot;                   # 数据文件路径
      awk -F&quot;${sep}&quot; -v one=&quot;${one}&quot; -v many=&quot;${many}&quot; &#39;$one != &quot;&quot; {b[$one][$many]++}
  END {for (i in b)
           {if (length(b[i]) &gt; 1) {
              for (j in b[i])
                  {print b[i][j] FS i FS j}}}}&#39; &quot;${file}&quot;
  }
#+end_src

这个函数与上面命令不同之处在于通过 =-F= 指定数据分隔符，通过 =-v= 将函数参数传递给 awk 变量，使用 =FS= 变量替代 =|= 作为数量与重复属性对之间的分隔符。

那么，我们可以直接使用该函数进行数据检测：
#+begin_src shell :noweb eval :results org
  &lt;&lt;one2many&gt;&gt;
  one2many &quot; &quot; 3 4 /tmp/test.txt
#+end_src

#+RESULTS:
#+begin_src org
4 potato vegetable
1 potato fruit
2 banana vegetable
1 banana 5.9
2 banana fruit
#+end_src

修复相对来说就比较简单了，我们首先创建一个查询表，用来查询 =属性1= 对应的 =属性2=,这个查询可以从 =one2many= 函数的结果中截取：
#+begin_src shell :noweb eval :results org
  &lt;&lt;one2many&gt;&gt;
  one2many &quot; &quot; 3 4 /tmp/test.txt |sed -n &#39;1p;5p&#39; |tee /tmp/lookup
#+end_src

#+RESULTS:
#+begin_src org
4 potato vegetable
2 banana fruit
#+end_src

然后在 awk 中查询 =属性1= 的值若在查询表中则将 =属性2= 的值直接改为查询表中的对应结果：
#+begin_src shell :results org
  awk &#39;FNR==NR {lookup[$1]=$2; next} # 通过FNR==NR判断是否在遍历查询表文件
  $3 in lookup {$4=lookup[$3]} 1&#39; /tmp/lookup /tmp/test.txt # awk 最后那个1表示执行awk 的默认操作，即输出$0
#+end_src

#+RESULTS:
#+begin_src org
saleID	date	item	class	kg
001	2021-01-02	capsicum	vegetable	11.9
002	2021-01-02	banana	fruit	12.7
003	2021-01-02	capsicum	vegetable	3.7
004	2021-01-02	potato	vegetable	4.1
005	2021-01-02	capsicum	vegetable	6.0
006	2021-01-02	potato	fruit	13.0
007	2021-01-02	banana	vegetable	9.1
008	2021-01-02	potato	vegetable	15.0
009	2021-01-02	apple	fruit	5.6
010	2021-01-02	banana	fruit	7.7
011	2021-01-02	pumpkin	vegetable	8.3
012	2021-01-02	pumpkin	vegetable	5.6
013	2021-01-02	apple	fruit	3.5
014	2021-01-02	pumpkin	vegetable	5.3
015	2021-01-02	capsicum	vegetable	10.3
016	2021-01-03	apple	fruit	12.2
017	2021-01-03	pumpkin	vegetable	12.6
018	2021-01-03	potato	vegetable	4.4
019	2021-01-03	apple	fruit	12.5
020	2021-01-03	pumpkin	vegetable	11.6
021	2021-01-03	banana	vegetable	14.5
022	2021-01-03	capsicum	vegetable	4.1
023	2021-01-03	banana		5.9
024	2021-01-03	potato	vegetable	4.8
025	2021-01-03	apple	fruit	15.6
#+end_src
</description>
<pubDate>2021-04-15</pubDate>
<guid>https://lujun9972.github.io/blog/2021/04/15/使用awk查找并修复数据中一对多的不一致问题/index.html</guid>
</item>
<item>
<title>升级库文件后如何查找需要重启的服务</title>
<link>https://lujun9972.github.io/blog/2021/04/14/升级库文件后如何查找需要重启的服务/index.html</link>
<description>从 https://www.cyberciti.biz/faq/how-to-restart-systemd-without-rebooting-linux-when-critical-libraries-installed/ 上看到的一个小技巧。

当升级库文件后，那些使用该库的服务需要重启后才会真正使用该库文件中的内容。一个常用的方法是直接重启系统，这样所有服务在启动时自然使用的是最新库的内容，但是作为服务器是不可能允许随意重启的，那么在不重启的情况下如何找出受到影像的服务呢？

这里有个简单的方法：
#+begin_src shell :dir /ssh:lujun9972@tencent_cloud.lujun9972.win#8022: :results org
  sudo lsof -d &#39;DEL&#39; | grep &#39;lib&#39; | cut -f 1 -d &#39; &#39; | sort -u
#+end_src

#+RESULTS:
#+begin_src org
  acpid
  agetty
  atd
  dbus-daem
  dhclient
  dictd
  gdbus
  gmain
  JS
  lsmd
  master
  polkitd
  qmgr
  sshd
  systemd-l
#+end_src

其原理就是用 lsof 查出所有 FD 为 =DEL(已删除的映射文件)= 且路径中带 =lib= 的命令。然后就可以使用 =systemctl restart= 重启服务了。

不过 =systemd= 本身作为1号进程不能通过 =systemctl restart= 来进行重启，而需要使用 =sudo systemctl daemon-reexec= 来重启。

关于 =systemctl daemon-reexec= 的说明如下：
#+begin_example
  daemon-reexec  Reexecute the systemd manager. This will serialize the manager state, reexecute the process and deserialize the state again. This command is of little use except for debugging and package upgrades. Sometimes, it might be helpful as a heavy-weight daemon-reload. While the daemon is being reexecuted, all sockets systemd listening on behalf of user configuration will stay accessible.
#+end_example
</description>
<pubDate>2021-04-14</pubDate>
<guid>https://lujun9972.github.io/blog/2021/04/14/升级库文件后如何查找需要重启的服务/index.html</guid>
</item>
</channel>
</rss>