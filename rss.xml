<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
  <channel>
    <title>暗无天日</title>
    <link>https://lujun9972.github.io</link>
    <description>=============&gt;DarkSun的个人博客</description>
    <pubDate>Sat, 20 Jun 2020 11:25:49 UTC</pubDate>
    <lastBuildDate>Sat, 20 Jun 2020 11:25:49 UTC</lastBuildDate>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <generator>ego static site generator (https://github.com/emacs-china/ego)</generator>
<item>
<title>如何通过HTTP协议访问指定版本的SVN库内容</title>
<link>https://lujun9972.github.io/blog/2020/06/20/如何通过http协议访问指定版本的svn库内容/index.html</link>
<description>在汇总晨检报告时，有同事反馈提交的内容被覆盖了，需要从某个指定版本中取出被覆盖的内容。
然而我在跳板机上只能通过HTTP协议用浏览器访问SVN仓库，默认访问的是最新版本内容。

那么要如何通过HTTP协议访问指定版本的内容呢?经过一番搜索，在 http://beerpla.net/2010/02/20/how-to-view-a-specific-svn-revision-in-your-browser/ 找到了解决方法，于是想着记录下来。

方法其实很简单，就是在URL的仓库根后面加上 =/!svn/bc/版本号/= 即可。

比如，我们想要看 https://plugins.svn.wordpress.org/stats/trunk/readme.txt 的 100000 版本的内容，我们可以这么做：

1. 找到仓库的根URL为 https://plugins.svn.wordpress.org
2. 在仓库根URL后加上 =/!svn/bc/100000/=: https://plugins.svn.wordpress.org/!svn/bc/100000/
3. 接上后续的文件路径: https://plugins.svn.wordpress.org/!svn/bc/100000/stats/trunk/readme.txt

所以访问路径 https://plugins.svn.wordpress.org/!svn/bc/100000/stats/trunk/readme.txt 即可。

另外，若 SVN 版本操作1.6,还可以通过在 URL 后添加 ~?p=版本号~, 也即访问 https://plugins.svn.wordpress.org/stats/trunk/readme.txt?p=100000 也能起到相同的作用。
 
</description>
<pubDate>2020-06-20</pubDate>
<guid>https://lujun9972.github.io/blog/2020/06/20/如何通过http协议访问指定版本的svn库内容/index.html</guid>
</item>
<item>
<title>如何设置git push和git pull的超时时间？</title>
<link>https://lujun9972.github.io/blog/2020/06/03/如何设置git-push和git-pull的超时时间？/index.html</link>
<description>不知道为什么，最近从 github 上git push 和 git pull 的时候总是不太稳定，有时候 pull 了半天都拉不下来，然后中断后重试一次又很顺畅了。

所以我想主动设置git push 和 git pull 的超时时间，这样我可以在脚本中监测退出状态后自动进行重试，而不是死等。

目前来看，似乎 =git= 并没有一个配置项是能保证超过一段时间后一定终止退出的，只能通过 =timeout= 命令才能保证超时退出。

然而很多 UNIX 系统没有 =timeout= 命令怎么办呢？我目前只找到两个近似的解决方案，希望各位大神能提供其他的解决方法。

首先，通过  =man git-config= 我们可以发现 =http.lowSpeedLimit= 和 =http.lowSpeedTime= 这两个选项是近似满足要求的：
#+begin_example
  http.lowSpeedLimit, http.lowSpeedTime
      If the HTTP transfer speed is less than http.lowSpeedLimit for
      longer than http.lowSpeedTime seconds, the transfer is aborted. Can
      be overridden by the GIT_HTTP_LOW_SPEED_LIMIT and
      GIT_HTTP_LOW_SPEED_TIME environment variables.
#+end_example

然而这两个选项只针对 HTTP 协议生效，其他协议则需要另辟蹊径。

另一方面，既然 git 的低层是使用 ssh 协议，那么其实我们可以通过通过配置 =ssh_config= 的 =ConnectTimeout= 来设置连接服务器的超时时间。
但这个选项只针对连接服务器这个阶段生效（即创建连接，SSH 握手和密钥交换这三个阶段），之后就无法进行超时约束了。


</description>
<pubDate>2020-06-03</pubDate>
<guid>https://lujun9972.github.io/blog/2020/06/03/如何设置git-push和git-pull的超时时间？/index.html</guid>
</item>
<item>
<title>使用strace解决pacman提示无法锁定数据库的问题</title>
<link>https://lujun9972.github.io/blog/2020/05/25/使用strace解决pacman提示无法锁定数据库的问题/index.html</link>
<description>某次滚动升级archlinux的时候忘了插电，导致滚动到一半的时候断电了。导致插电后再升级时提示：
#+begin_example
  :: 正在同步软件包数据库...
  错误：无法升级 core (无法锁定数据库)
  错误：无法升级 extra (无法锁定数据库)
  错误：无法升级 community (无法锁定数据库)
  错误：无法升级 multilib (无法锁定数据库)
  错误：无法升级 archlinuxcn (无法锁定数据库)
  错误：未能成功同步所有数据库
#+end_example

从错误提示我能推测出大概率是升级到一半断电导致某个锁文件未被删除，问题是，这个锁文件在哪呢？

还好有 =strace=,可以帮我找出锁文件的路径
#+begin_src shell :results org :dir /sudo::
  sudo strace -e openat pacman -Syu --noconfirm 2&gt;&amp;1
#+end_src

#+RESULTS:
#+begin_src org
openat(AT_FDCWD, &quot;/etc/ld.so.cache&quot;, O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, &quot;/usr/lib/libalpm.so.12&quot;, O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, &quot;/usr/lib/libarchive.so.13&quot;, O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, &quot;/usr/lib/libc.so.6&quot;, O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, &quot;/usr/lib/libgpgme.so.11&quot;, O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, &quot;/usr/lib/libcurl.so.4&quot;, O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, &quot;/usr/lib/libcrypto.so.1.1&quot;, O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, &quot;/usr/lib/libacl.so.1&quot;, O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, &quot;/usr/lib/libexpat.so.1&quot;, O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, &quot;/usr/lib/liblzma.so.5&quot;, O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, &quot;/usr/lib/libzstd.so.1&quot;, O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, &quot;/usr/lib/liblz4.so.1&quot;, O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, &quot;/usr/lib/libbz2.so.1.0&quot;, O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, &quot;/usr/lib/libz.so.1&quot;, O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, &quot;/usr/lib/libassuan.so.0&quot;, O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, &quot;/usr/lib/libgpg-error.so.0&quot;, O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, &quot;/usr/lib/libnghttp2.so.14&quot;, O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, &quot;/usr/lib/libidn2.so.0&quot;, O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, &quot;/usr/lib/libssh2.so.1&quot;, O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, &quot;/usr/lib/libpsl.so.5&quot;, O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, &quot;/usr/lib/libssl.so.1.1&quot;, O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, &quot;/usr/lib/libgssapi_krb5.so.2&quot;, O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, &quot;/usr/lib/libkrb5.so.3&quot;, O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, &quot;/usr/lib/libk5crypto.so.3&quot;, O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, &quot;/usr/lib/libcom_err.so.2&quot;, O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, &quot;/usr/lib/libpthread.so.0&quot;, O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, &quot;/usr/lib/libdl.so.2&quot;, O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, &quot;/usr/lib/libattr.so.1&quot;, O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, &quot;/usr/lib/libunistring.so.2&quot;, O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, &quot;/usr/lib/libkrb5support.so.0&quot;, O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, &quot;/usr/lib/libkeyutils.so.1&quot;, O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, &quot;/usr/lib/libresolv.so.2&quot;, O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, &quot;/usr/lib/locale/locale-archive&quot;, O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, &quot;/etc/pacman.conf&quot;, O_RDONLY) = 3
openat(AT_FDCWD, &quot;/etc/pacman.d/mirrorlist&quot;, O_RDONLY) = 4
openat(AT_FDCWD, &quot;/etc/pacman.d/mirrorlist&quot;, O_RDONLY) = 4
openat(AT_FDCWD, &quot;/etc/pacman.d/mirrorlist&quot;, O_RDONLY) = 4
openat(AT_FDCWD, &quot;/etc/pacman.d/mirrorlist&quot;, O_RDONLY) = 4
openat(AT_FDCWD, &quot;/var/lib/pacman/local/&quot;, O_RDONLY|O_NONBLOCK|O_CLOEXEC|O_DIRECTORY) = 3
openat(AT_FDCWD, &quot;/var/lib/pacman/local/ALPM_DB_VERSION&quot;, O_RDONLY) = 4
openat(AT_FDCWD, &quot;/usr/share/locale/locale.alias&quot;, O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, &quot;/usr/share/locale/en_US.utf8/LC_MESSAGES/libc.mo&quot;, O_RDONLY) = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, &quot;/usr/share/locale/en_US/LC_MESSAGES/libc.mo&quot;, O_RDONLY) = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, &quot;/usr/share/locale/en.utf8/LC_MESSAGES/libc.mo&quot;, O_RDONLY) = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, &quot;/usr/share/locale/en/LC_MESSAGES/libc.mo&quot;, O_RDONLY) = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, &quot;/var/log/pacman.log&quot;, O_WRONLY|O_CREAT|O_APPEND|O_CLOEXEC, 0644) = 3
openat(AT_FDCWD, &quot;/etc/localtime&quot;, O_RDONLY|O_CLOEXEC) = 4
openat(AT_FDCWD, &quot;/usr/share/locale/en_US.utf8/LC_MESSAGES/pacman.mo&quot;, O_RDONLY) = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, &quot;/usr/share/locale/en_US/LC_MESSAGES/pacman.mo&quot;, O_RDONLY) = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, &quot;/usr/share/locale/en.utf8/LC_MESSAGES/pacman.mo&quot;, O_RDONLY) = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, &quot;/usr/share/locale/en/LC_MESSAGES/pacman.mo&quot;, O_RDONLY) = -1 ENOENT (No such file or directory)
:: Synchronizing package databases...
openat(AT_FDCWD, &quot;/var/lib/pacman/db.lck&quot;, O_WRONLY|O_CREAT|O_EXCL|O_CLOEXEC, 000) = -1 EEXIST (File exists)
openat(AT_FDCWD, &quot;/usr/share/locale/en_US.utf8/LC_MESSAGES/libalpm.mo&quot;, O_RDONLY) = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, &quot;/usr/share/locale/en_US/LC_MESSAGES/libalpm.mo&quot;, O_RDONLY) = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, &quot;/usr/share/locale/en.utf8/LC_MESSAGES/libalpm.mo&quot;, O_RDONLY) = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, &quot;/usr/share/locale/en/LC_MESSAGES/libalpm.mo&quot;, O_RDONLY) = -1 ENOENT (No such file or directory)
error: failed to update core (unable to lock database)
openat(AT_FDCWD, &quot;/var/lib/pacman/db.lck&quot;, O_WRONLY|O_CREAT|O_EXCL|O_CLOEXEC, 000) = -1 EEXIST (File exists)
error: failed to update extra (unable to lock database)
openat(AT_FDCWD, &quot;/var/lib/pacman/db.lck&quot;, O_WRONLY|O_CREAT|O_EXCL|O_CLOEXEC, 000) = -1 EEXIST (File exists)
error: failed to update community (unable to lock database)
openat(AT_FDCWD, &quot;/var/lib/pacman/db.lck&quot;, O_WRONLY|O_CREAT|O_EXCL|O_CLOEXEC, 000) = -1 EEXIST (File exists)
error: failed to update multilib (unable to lock database)
openat(AT_FDCWD, &quot;/var/lib/pacman/db.lck&quot;, O_WRONLY|O_CREAT|O_EXCL|O_CLOEXEC, 000) = -1 EEXIST (File exists)
error: failed to update archlinuxcn (unable to lock database)
error: failed to synchronize all databases
+++ exited with 1 +++
#+end_src

可以看到，在输出 =:: Synchronizing package databases...= 后，pacman会去检查 =&quot;/var/lib/pacman/db.lck&quot;= 是否存在,然后跟着提示 =error: failed to update archlinuxcn (unable to lock database)=

所以很容易就能推测出，锁文件为 =/var/lib/pacman/db.lck=,跟网上搜索的内容一致。
</description>
<pubDate>2020-05-25</pubDate>
<guid>https://lujun9972.github.io/blog/2020/05/25/使用strace解决pacman提示无法锁定数据库的问题/index.html</guid>
</item>
<item>
<title>如何批量删除Linux mail中的Cron邮件</title>
<link>https://lujun9972.github.io/blog/2020/05/25/如何批量删除linux-mail中的cron邮件/index.html</link>
<description>我在 cron 中设置了每天定时运行 [[https://github.com/LCTT/TranslateProject][Linux中国]] 的选题脚本。然后由于cron会将任务的执行结果通过邮件通知用户，这样一来过了一段时间后我的 mail box 中就充满了 CRON 发来邮箱了。

看了网上的一些资料，我知道可以通过 =echo &#39;d *&#39;|mail= 来删除所有 mail box 中的邮件，但是这样会把非 CRON 的邮件也删掉，这不是我想要的。

好在翻阅了一下 =man mail= 发现 =d= 命令后面可以通过直接跟 =发件人地址= 或 =/关键字= 的方式删除指定发件人的邮件，或删除标题中包含 =关键字= 的邮件。

由于所有的 =CRON= 发送的邮件都以 =(Cron Daemon)= 作为发件人，因此可以通过 =echo &#39;&quot;(Cron Daemon)&quot;&#39;|mail= 来删除所有 CRON 发出的邮件（这里不要忘了括号外的双引号，因为 =()= 在指定邮件的语法中有特殊意义）

那么若我只是想删除某个 CRON 任务发送的邮件又该怎么办呢？ 
=CRON= 发送的邮件的标题格式一般都是这样的 =Cron &lt;主机名&gt; CRON命令=.
#+begin_src shell :dir /ssh:lujun9972@tencent_cloud.lujun9972.win#8022: :results org
    echo -n |mail
#+end_src

#+RESULTS:
#+begin_src org
Heirloom Mail version 12.5 7/5/10.  Type ? for help.
&quot;/var/spool/mail/lujun9972&quot;: 11 messages 10 unread
&gt;U  1 (Cron Daemon)         Mon May 25 15:03  26/964   &quot;Cron &lt;lujun9972@VM_0_8_centos&gt; date&quot;
 U  2 (Cron Daemon)         Mon May 25 15:04  26/964   &quot;Cron &lt;lujun9972@VM_0_8_centos&gt; date&quot;
 U  3 (Cron Daemon)         Mon May 25 15:05  26/964   &quot;Cron &lt;lujun9972@VM_0_8_centos&gt; date&quot;
 U  4 (Cron Daemon)         Mon May 25 15:06  26/964   &quot;Cron &lt;lujun9972@VM_0_8_centos&gt; date&quot;
 U  5 (Cron Daemon)         Mon May 25 15:07  26/964   &quot;Cron &lt;lujun9972@VM_0_8_centos&gt; date&quot;
 U  6 (Cron Daemon)         Mon May 25 15:08  26/964   &quot;Cron &lt;lujun9972@VM_0_8_centos&gt; date&quot;
    7 (Cron Daemon)         Mon May 25 15:09  26/965   &quot;Cron &lt;lujun9972@VM_0_8_centos&gt; date&quot;
 U  8 (Cron Daemon)         Mon May 25 15:10  26/964   &quot;Cron &lt;lujun9972@VM_0_8_centos&gt; date&quot;
 U  9 (Cron Daemon)         Mon May 25 15:11  26/964   &quot;Cron &lt;lujun9972@VM_0_8_centos&gt; date&quot;
 U 10 (Cron Daemon)         Mon May 25 15:12  26/964   &quot;Cron &lt;lujun9972@VM_0_8_centos&gt; date&quot;
 U 11 (Cron Daemon)         Mon May 25 15:13  26/964   &quot;Cron &lt;lujun9972@VM_0_8_centos&gt; date&quot;
Held 11 messages in /var/spool/mail/lujun9972
#+end_src

因此，我们可以通过 =echo &#39;d /命令关键字&#39;|mail= 来删除某个特定任务的邮件，比如下面命令删除 =date= 命令产生的邮件：
#+begin_src shell :dir /ssh:lujun9972@tencent_cloud.lujun9972.win#8022: :results org
    echo &#39;d /date&#39; |mail
    echo -n |mail
#+end_src

#+RESULTS:
#+begin_src org
  No mail for lujun9972
#+end_src

=mail= 命令中关于指定邮件的语法特别灵活，下面说明摘取自 =man mail=
#+begin_src shell  :dir /ssh:lujun9972@tencent_cloud.lujun9972.win#8022: :results org
    man mail |sed -n &#39;/Specifying messages/,/Replying to or originating mail/p&#39;
#+end_src

#+RESULTS:
#+begin_src org
   Specifying messages
       Commands  such  as print and delete can be given a list of message num‐
       bers as arguments to apply to a  number  of  messages  at  once.   Thus
       `delete  1 2&#39; deletes messages 1 and 2, while `delete 1-5&#39; deletes mes‐
       sages 1 through 5.  In sorted or threaded mode (see the sort and thread
       commands),  `delete  1-5&#39; deletes the messages that are located between
       (and including) messages 1 through 5 in the sorted/threaded  order,  as
       shown  in  the  header  summary.   The  following special message names
       exist:

       :n     All new messages.

       :o     All old messages (any not in state read or new).

       :u     All unread messages.

       :d     All deleted messages (for the undelete command).

       :r     All read messages.

       :f     All `flagged&#39; messages.

       :a     All answered messages (cf. the markanswered variable).

       :t     All messages marked as draft.

       :k     All `killed&#39; messages.

       :j     All messages classified as junk.

       .      The current message.

       ;      The message that was previously the current message.

       ,      The parent message of the current message, that is  the  message
              with  the  Message-ID  given  in the `In-Reply-To:&#39; field or the
              last entry of the `References:&#39; field of the current message.

       -      The next  previous  undeleted  message,  or  the  next  previous
              deleted  message  for  the undelete command.  In sorted/threaded
              mode, the next previous  such  message  in  the  sorted/threaded
              order.

       +      The  next undeleted message, or the next deleted message for the
              undelete command.  In sorted/threaded mode, the next  such  mes‐
              sage in the sorted/threaded order.

       ^      The  first  undeleted  message, or the first deleted message for
              the undelete command.  In sorted/threaded mode, the  first  such
              message in the sorted/threaded order.

       $      The  last message.  In sorted/threaded mode, the last message in
              the sorted/threaded order.

       &amp;x     In threaded mode, selects the message addressed with x, where  x
              is  any  other  message specification, and all messages from the
              thread that begins at it.  Otherwise, it is identical to x.   If
              x  is  omitted, the thread beginning with the current message is
              selected.

       ,*      All messages.

       `      All messages that were included in the message list for the pre‐
              vious command.

       /string
              All  messages  that  contain  string  in the subject field (case
              ignored).  See also the searchheaders variable.   If  string  is
              empty,  the  string from the previous specification of that type
              is used again.

       address
              All messages from address.  By default, this is a case-sensitive
              search  for  the complete email address.  If the allnet variable
              is set, only the local part of the addresses  is  evaluated  for
              the  comparison.   Otherwise  if the showname variable is set, a
              case-sensitive search for the complete real name of a sender  is
              performed.  The IMAP-style (from address) expression can be used
              instead if substring matches are desired.

       (criterion)
              All messages that satisfy the given IMAP-style SEARCH criterion.
              This addressing mode is available with all types of folders; for
              folders not located on IMAP servers, or for  servers  unable  to
              execute  the  SEARCH  command,  mailx  will  perform  the search
              locally.  Strings must be enclosed by double quotes `&quot;&#39; in their
              entirety  if they contain white space or parentheses; within the
              quotes, only backslash `\&#39; is recognized as an escape character.
              All  string searches are case-insensitive.  When the description
              indicates that the `envelope&#39; representation of an address field
              is  used,  this  means that the search string is checked against
              both a list constructed as

              (&quot;real name&quot; &quot;source-route&quot; &quot;local-part&quot; &quot;domain-part&quot;)

              for each address, and the addresses without real names from  the
              respective header field.  Criteria can be nested using parenthe‐
              ses.

       (criterion1 criterion2 ... criterionN)
              All messages that satisfy all of the given criteria.

       (or criterion1 criterion2)
              All messages that satisfy either criterion1  or  criterion2,  or
              both.  To connect more than two criteria using `or&#39;, (or) speci‐
              fications have to be nested  using  additional  parentheses,  as
              with  `(or a (or b c))&#39;;  `(or a b c)&#39;  means  ((a or b) and c).
              For a simple `or&#39; operation of independent criteria on the  low‐
              est  nesting level, it is possible to achieve similar effects by
              using three separate criteria, as with `(a) (b) (c)&#39;.

       (not criterion)
              All messages that do not satisfy criterion.

       (bcc string)
              All messages that contain string in the  `envelope&#39;  representa‐
              tion of the Bcc: field.

       (cc string)
              All  messages  that contain string in the `envelope&#39; representa‐
              tion of the Cc: field.

       (from string)
              All messages that contain string in the  `envelope&#39;  representa‐
              tion of the From: field.

       (subject string)
              All messages that contain string in the Subject: field.

       (to string)
              All  messages  that contain string in the `envelope&#39; representa‐
              tion of the To: field.

       (header name string)
              All messages that contain string in the specified Name: field.

       (body string)
              All messages that contain string in their body.

       (text string)
              All messages that contain string in their header or body.

       (larger size)
              All messages that are larger than size (in bytes).

       (smaller size)
              All messages that are smaller than size (in bytes).

       (before date)
              All messages that were received before date; date must be in the
              form d[d]-mon-yyyy, where d[d] is the day of the month as one or
              two digits, mon is the name of the month—one  of  `Jan&#39;,  `Feb&#39;,
              `Mar&#39;,  `Apr&#39;,  `May&#39;, `Jun&#39;, `Jul&#39;, `Aug&#39;, `Sep&#39;, `Oct&#39;, `Nov&#39;,
              or  `Dec&#39;,  and  yyyy  is  the  year  as   four   digits;   e.g.
              &quot;30-Aug-2004&quot;.

       (on date)
              All messages that were received on the specified date.

       (since date)
              All messages that were received since the specified date.

       (sentbefore date)
              All messages that were sent on the specified date.

       (senton date)
              All messages that were sent on the specified date.

       (sentsince date)
              All messages that were sent since the specified date.

       ()     The  same criterion as for the previous search.  This specifica‐
              tion cannot be used as part of another criterion.  If the previ‐
              ous  command line contained more than one independent criterion,
              the last of those criteria is used.

       A practical method to read a set of messages is to issue a from command
       with  the  search criteria first to check for appropriate messages, and
       to read each single message then by typing ``&#39; repeatedly.

   Replying to or originating mail
#+end_src
</description>
<pubDate>2020-05-25</pubDate>
<guid>https://lujun9972.github.io/blog/2020/05/25/如何批量删除linux-mail中的cron邮件/index.html</guid>
</item>
<item>
<title>笑话理解之channel</title>
<link>https://lujun9972.github.io/blog/2020/05/19/笑话理解之channel/index.html</link>
<description>* English Channel
#+begin_example
  Teacher: &quot;Where is the English Channel?&quot;

  Pupil: &quot;I don&#39;t know, my TV doesn&#39;t pick it up!&quot;
#+end_example

=Channel= 有海峡的意思， =English Channel= 是指英吉利海峡。

同时 =Channel= 还有 =电视频道= 的意思，所以  =English Channel= 还可以表示英语频道。所以学生才会说电视上找不到
</description>
<pubDate>2020-05-19</pubDate>
<guid>https://lujun9972.github.io/blog/2020/05/19/笑话理解之channel/index.html</guid>
</item>
<item>
<title>AWK tips 之移动文件中的指定行</title>
<link>https://lujun9972.github.io/blog/2020/05/15/awk-tips-之移动文件中的指定行/index.html</link>
<description>从 https://www.datafix.com.au/BASHing/2020-05-13.html 上看到的 AWK 技巧，记录一下。

假设有这个一个文件：
#+begin_example
  SaleID|Class|Item|Count|UnitP|TotalP
  146|fish|BG fillets|3|15.00|45.00
  2785|fruit|banana|1|0.45|0.45
  0039|fruit|banana|1|0.45|0.45
  119|meat|liver paste|1|2.10|2.10
  6253|veg|carrot bunch|2|4.90|9.80
  8847|fish|tin tuna|4|1.50|6.00
  3776|veg|pak choy|2|2.50|5.00
  295|fruit|apple|6|0.94|5.64
  534|fish|tin tuna|1|1.50|1.50
  1221|meat|pork slices|8|4.20|33.60 
#+end_example

现在想把 SaleID 为 295 的这条记录移动到 0039 后面，用 AWK 如何实现？

这里的技巧在于对同一个文件遍历两次，第一次找出待移动的记录并记录到某个变量中，第二次在恰当的位置输出它。最后的解决方法为：
#+begin_src shell :dir /tmp :results org
  awk -F&quot;|&quot; &#39;FNR==NR {if ($1==&quot;295&quot;) {x=$0}; next} \
  $1==&quot;0039&quot; {$0=$0 RS x} $1!=&quot;295&quot; {print}&#39; demo demo
#+end_src

#+RESULTS:
#+begin_src org
SaleID|Class|Item|Count|UnitP|TotalP
146|fish|BG fillets|3|15.00|45.00
2785|fruit|banana|1|0.45|0.45
0039|fruit|banana|1|0.45|0.45
295|fruit|apple|6|0.94|5.64
119|meat|liver paste|1|2.10|2.10
6253|veg|carrot bunch|2|4.90|9.80
8847|fish|tin tuna|4|1.50|6.00
3776|veg|pak choy|2|2.50|5.00
534|fish|tin tuna|1|1.50|1.50
1221|meat|pork slices|8|4.20|33.60 
#+end_src

这里 ~FNR==NR {第一个文件的处理逻辑;next} 第二个文件的处理逻辑~ 是一种常见的搭配，用来先通过第一个文件构造必要的变量，然后利用这些构造出的变量来处理第二个文件。

这里的关键在于，第一个文件的处理过程一定要以 =next= 结尾，这样才会让 AWK 中断后面的模式匹配和操作，直到遍厉完第一个文件的内容。

当然，如果我们直到被移动记录的行数和插入的位置的话，也可以直接使用 =FNR= 作为匹配条件，例如上面的操作可以改为
#+begin_src shell :dir /tmp :results org
  awk &#39;FNR==NR {if (NR==9) {x=$0}; next} \
   FNR==4 {$0=$0 RS x} FNR!=9 {print}&#39; demo demo
#+end_src

#+RESULTS:
#+begin_src org
SaleID|Class|Item|Count|UnitP|TotalP
146|fish|BG fillets|3|15.00|45.00
2785|fruit|banana|1|0.45|0.45
0039|fruit|banana|1|0.45|0.45
295|fruit|apple|6|0.94|5.64
119|meat|liver paste|1|2.10|2.10
6253|veg|carrot bunch|2|4.90|9.80
8847|fish|tin tuna|4|1.50|6.00
3776|veg|pak choy|2|2.50|5.00
534|fish|tin tuna|1|1.50|1.50
1221|meat|pork slices|8|4.20|33.60 
#+end_src

在进一步，我们可以将这段 AWK 代码封装成一个函数：
#+begin_src shell :dir /tmp :results org
  shiftline()
  {
      awk -v target=&quot;$2&quot; -v putafter=&quot;$3&quot; &#39;FNR==NR {if (NR==target) {x=$0; next} else next} FNR==putafter {$0=$0 RS x} FNR!=target {print}&#39; &quot;$1&quot; &quot;$1&quot;
  }

  shiftline demo 9 4
#+end_src

#+RESULTS:
#+begin_src org
SaleID|Class|Item|Count|UnitP|TotalP
146|fish|BG fillets|3|15.00|45.00
2785|fruit|banana|1|0.45|0.45
0039|fruit|banana|1|0.45|0.45
295|fruit|apple|6|0.94|5.64
119|meat|liver paste|1|2.10|2.10
6253|veg|carrot bunch|2|4.90|9.80
8847|fish|tin tuna|4|1.50|6.00
3776|veg|pak choy|2|2.50|5.00
534|fish|tin tuna|1|1.50|1.50
1221|meat|pork slices|8|4.20|33.60 
#+end_src
</description>
<pubDate>2020-05-15</pubDate>
<guid>https://lujun9972.github.io/blog/2020/05/15/awk-tips-之移动文件中的指定行/index.html</guid>
</item>
<item>
<title>找回已连接Wifi的密码</title>
<link>https://lujun9972.github.io/blog/2020/05/14/找回已连接wifi的密码/index.html</link>
<description>根据Wifi管理组件的不同，存储Wifi密码的配置文件路径也不同。

* NetworkManager
在 Ubuntu 中默认是使用 =NetworkManger= 来进行管理Wifi。
其配置文件存储在 =/etc/NetworkManager/system-connections/= 目录中，且密码对应字段为 =psk= ,因此我们可以通过下面命令找回密码:
#+begin_src shell
  sudo grep -r &#39;^psk=&#39; /etc/NetworkManager/system-connections/
#+end_src

* netctl
我在archlinux下使用 =netctl= 来管理Wifi。
其配置文件存储在 =/etc/netctl= 目录下，且密码对应字段为 =Key= (注意第一个字符大写),因此我们可以通过下面命令找回密码:
#+begin_src shell :dir /sudo::
  sudo grep -r &#39;^Key=&#39; /etc/netctl/
#+end_src
</description>
<pubDate>2020-05-14</pubDate>
<guid>https://lujun9972.github.io/blog/2020/05/14/找回已连接wifi的密码/index.html</guid>
</item>
<item>
<title>如何从apt upgrade中排除指定包</title>
<link>https://lujun9972.github.io/blog/2020/05/13/如何从apt-upgrade中排除指定包/index.html</link>
<description>在 archlinux 下可以直接通过 =pacman -Syu --ingore= 来跳过指定包进行升级, 然而ubuntu 下的 apt 居然不提供类似的排除选项，这很让我感到吃惊.
不过网上apt的内容倒是蛮多，经过简单的搜索，很容易找到解决方法。

1. 先用 =apt-mark hold= 来保留要排除的软件包
   #+begin_src shell :dir /sudo::
     sudo apt-mark hold emacs-snapshot
   #+end_src

   #+RESULTS:
   : emacs-snapshot set on hold.

2. 执行升级操作
   #+begin_src shell :dir /sudo::
     sudo apt upgrade -y
   #+end_src

3. 用 =apt-mark unhold= 来取消包的保留
   #+begin_src shell :dir /sudo::
     sudo apt-mark unhold emacs-snapshot
   #+end_src

   #+RESULTS:
   : Canceled hold on emacs-snapshot.

   
如果没有 =apt-mark= 命令，则还可以使用 =dpkg --set-selections= 来保留软件包，关于它的manual如下：
#+begin_example
  --set-selections
              Set package selections using file read from stdin. This file should be in the format  “package  state”,
              where  state  is one of install, hold, deinstall or purge. Blank lines and comment lines beginning with
              ‘#’ are also permitted.

              The available file needs to be up-to-date for this command to be  useful,  otherwise  unknown  packages
              will be ignored with a warning. See the --update-avail and --merge-avail commands for more information.
#+end_example

所以步骤可以修改为
1. 保留要排除的软件包
   #+begin_src shell :dir /sudo::
     echo &quot;emacs-snapshot hold&quot; |sudo dpkg --set-selections
   #+end_src

   #+RESULTS:

2. 执行升级操作
   #+begin_src shell :dir /sudo::
     sudo apt upgrade -y
   #+end_src

3. 取消包的保留
   #+begin_src shell :dir /sudo::
     echo &quot;emacs-snapshot install&quot; |sudo dpkg --set-selections
   #+end_src

   #+RESULTS:
</description>
<pubDate>2020-05-13</pubDate>
<guid>https://lujun9972.github.io/blog/2020/05/13/如何从apt-upgrade中排除指定包/index.html</guid>
</item>
<item>
<title>git branch大扫除</title>
<link>https://lujun9972.github.io/blog/2020/05/12/git-branch大扫除/index.html</link>
<description>从 http://www.joachim-breitner.de/blog/751-Spring_cleaning__local_git_branches 上看到的小技巧，觉得很棒，记录一下。

在git项目中经常会包含大量的分支，比如在在我 [[https://github.com/LCTT/TranslateProject][Linux中国]] 的选题仓库中就包含了一对各式各样的分支:
#+begin_src shell :results org :dir /ssh:lujun9972@tencent_cloud#8022:~/github/TranslateProject
  git branch
#+end_src

#+RESULTS:
#+begin_src org
  add-MjAxODA4MDUgV2hlcmUgVmltIENhbWUgRnJvbS5tZAo=
  add-MjAxODA5MDIgTGVhcm5pbmcgQkFTSUMgTGlrZSBJdC1zIDE5ODMubWQK
  add-MjAxODEwMTUgSW50ZXJuZXRzIG9mIEludGVyZXN0IC03LSBJYW4gQ29vcGVyIG9uIFRlc3QgRHJpdmVuIERldmVsb3BtZW50Lm1kCg==
  add-MjAxODExMDMgSW50ZXJuZXRzIG9mIEludGVyZXN0IC04LSBUb2RkIEZlcm5hbmRleiBvbiB0aGUgbWFudWZhY3R1cmluZyBvZiBtb2Rlcm4gc2VtaWNvbmR1Y3RvcnMubWQK
  add-MjAxODExMTEgSW50ZXJuZXRzIG9mIEludGVyZXN0IC05LSBKYXNvbiBTY290dCBvbiB0aGUgQ29weXJpZ2h0IEZ1cnkgUm9hZC5tZAo=
  add-MjAxODExMTUgSW50ZXJuZXRzIG9mIEludGVyZXN0IC0xMC0gTWlrZSBIYXJyaXNvbiBvbiB0aGUgRWlkb3Bob3IubWQK
  add-MjAxODEyMzAgSW50ZXJuZXRzIG9mIEludGVyZXN0IC0xMS0gWWVzdGVyZGF5LXMgQ29tcHV0ZXIgb2YgVG9tb3Jyb3ctIFRoZSBYZXJveCBBbHRvLm1kCg==
  add-MjAxOTA0MDMgQWJzb2x1dGUgVW5pdCAodGVzdCkubWQK
  add-MjAxOTA2MDUgSG93IHRvIG5hdmlnYXRlIHRoZSBLdWJlcm5ldGVzIGxlYXJuaW5nIGN1cnZlLm1kCg==
  add-MjAxOTA2MTAgV2h5IGNvbnRhaW5lcnMgYW5kIEt1YmVybmV0ZXMgaGF2ZSB0aGUgcG90ZW50aWFsIHRvIHJ1biBhbG1vc3QgYW55dGhpbmcubWQK
  add-MjAxOTA2MjggVW5kbyByZWxlYXNlcyBMaXZlIFJlY29yZGVyIDUuMCBmb3IgTGludXggZGVidWdnaW5nLm1kCg==
  add-MjAxOTA3MDUgU3lkbmV5IEhpZ2ggUGVyZm9ybWFuY2UgR28gd29ya3Nob3AubWQK
  add-MjAxOTA3MDkgUmVkIEhhdCwgSUJNLCBhbmQgRmVkb3JhLm1kCg==
  add-MjAxOTA4MzAgSFBFIGludHJvZHVjZXMgVk13YXJlIHNlcnZpY2VzIG9uIEdyZWVuTGFrZS5tZAo=
  add-MjAxOTA5MDIgVXNpbmcgcHJlZGljdGl2ZSBhbmFseXRpY3MgdG8gdHJvdWJsZXNob290IG5ldHdvcmsgaXNzdWVzLSBGYWN0IG9yIGZpY3Rpb24ubWQK
  add-MjAxOTA5MDUgUS1BLSBIUEUtcyBuZXR3b3JraW5nIGNoaWVmIG9wZW5zIHVwIGFib3V0IGludGVsbGlnZW50IGVkZ2UsIENpc2NvIGFuZCBtaWNybyBkYXRhIGNlbnRlcnMubWQK
  add-MjAxOTA5MDYgMi1NaW51dGUgTGludXggVGlwLSBUaGUgZW52IGNvbW1hbmQubWQK
  add-MjAxOTA5MDkgTW92aW5nIHRvIFNELVdBTi0gQ29uc2lkZXIgU2VjdXJpdHkgQ2FyZWZ1bGx5LCBTYXkgRXhwZXJ0cyBhbmQgSVQgTWFuYWdlcnMubWQK
  add-MjAxOTA5MTEgNSBXYXlzIFNELVdBTiBQcm9tb3RlIEJ1c2luZXNzIEFnaWxpdHkubWQK
  add-MjAxOTA5MTEgOCBLZXkgQ29uc2lkZXJhdGlvbnMgV2hlbiBTZWxlY3RpbmcgYSBNYW5hZ2VkIFNELVdBTiBTZXJ2aWNlIFByb3ZpZGVyLm1kCg==
  add-MjAxOTA5MTEgQ2lzY28gYWRkcyBzcGVlZCwgc21hcnRzIHRvIE1EUyBzdG9yYWdlIG5ldHdvcmtpbmcgZmFtaWx5Lm1kCg==
  add-MjAxOTA5MTEgU0QtV0FOLSBEb2VzIFlvdXIgSVQgVGVhbSBIYXZlIFdoYXQgSXQgVGFrZXMubWQK
  add-MjAxOTA5MTIgNSBNdXN0LWhhdmUgU0QtV0FOIFNlY3VyaXR5IENhcGFiaWxpdGllcy5tZAo=
  add-MjAxOTA5MTIgSUJNIHoxNSBtYWluZnJhbWUsIGFtcHMtdXAgY2xvdWQsIHNlY3VyaXR5IGZlYXR1cmVzLm1kCg==
  add-MjAxOTA5MTIgVG9wIDMgTWlzY29uY2VwdGlvbnMgQWJvdXQgU0QtV0FOLm1kCg==
  add-MjAxOTA5MTMgR05PTUUgMy4zNCByZWxlYXNlZCAtIGNvbWluZyBzb29uIGluIEZlZG9yYSAzMS5tZAo=
  add-MjAxOTA5MTMgSm9pbiBPcGVuIEphbSAyMDE5IHRvIGJ1aWxkIG9wZW4gc291cmNlIGluZGllIGdhbWVzLm1kCg==
  add-MjAxOTA5MTMgV2hhdCBwb2xpdGljcyBjYW4gdGVhY2ggdXMgYWJvdXQgb3BlbiBzb3VyY2UubWQK
  add-MjAxOTAyMTYgU29tZSBQcmVzZW50YXRpb24gU2xpZGVzLm1kCg==
  add-MjAxOTAyMjAgSW50ZXJuZXRzIG9mIEludGVyZXN0IC0xMi0gVGVzdGluZyBNaWNoYWVsIEZlYXRoZXJzLSBQYXRpZW5jZS5tZAo=
  add-MjAxOTEwMzEgRmlyZWZveCB0aXBzIGZvciBGZWRvcmEgMzEubWQK
  add-MjAxOTExMTUgRmVkb3JhIHBhc3RlYmluIGFuZCBmcGFzdGUgdXBkYXRlcy5tZAo=
  add-MjAxOTExMTggRmVkb3JhIHNoaXJ0cyBhbmQgc3dlYXRzaGlydHMgZnJvbSBIRUxMT1RVWC5tZAo=
  add-MjAxOTExMjIgU2hhcmluZyBGZWRvcmEubWQK
  add-MjAxOTExMjQgQmF1aCAtIE1hbmFnZSBTbmFwcywgRmxhdHBha3MgYW5kIEFwcEltYWdlcyBmcm9tIE9uZSBJbnRlcmZhY2UubWQK
  add-MjAxOTEyMTIgNyB3YXlzIHRvIHJlbWVtYmVyIExpbnV4IGNvbW1hbmRzLm1kCg==
  add-MjAxOTEyMTMgSG93IHRvIHVzZSB0aGUgTGludXggdW5pcSBjb21tYW5kLm1kCg==
  add-MjAxOTEyMzEgT25lIE9mIFRoZSBSZWFzb25zIFdoeSBMaW51eCA1LjUgQ2FuIEJlIFJ1bm5pbmcgU2xvd2VyLm1kCg==
  add-MjAyMDA1MDcgSG93IHRvIHJlcGVhdCBhIExpbnV4IGNvbW1hbmQgdW50aWwgaXQgc3VjY2VlZHMubWQK
  add-MjAyMDAzMTAgUnVuIEt1YmVybmV0ZXMgb24gYSBSYXNwYmVycnkgUGkgd2l0aCBrM3MubWQK
,* master
  revert-c291cmNlcy90ZWNoLzIwMjAwNDA3IEhvdyB0byB1c2UgcHllbnYgdG8gcnVuIG11bHRpcGxlIHZlcnNpb25zIG9mIFB5dGhvbiBvbiBhIE1hYy5tZAo=
#+end_src


这些分支大致会处于下面几种状态：

1. master分支, 指向上游的master分支
2. 已经推送到remote仓库的开发分支.
3. 已经发起pull request但未处理的开发分支.
4. 已经发起pull request，且merge到master的开发分支
5. 已经发起pull request, 且sqush或rebase到master的开发分支
6. 已经发起pull request, 但被拒绝,但remote branch还在的开发分支
7. 已经发起pull request, 但被拒绝,且remote branch已被删除的开发分支
8. 尚未推送到remote的本地开发分支

   
实际上，这些分支还可以进一步合并为三类:
1. master分支
2. 推送到remote仓库的开发分支(remote branch或pull request)
3. 未推送到remote仓库的分支


一个比较简单的方法就是使用 =git branch --merged= 列出所有已合并入master的本地分支然后删掉除当前分支(以* 开头的分支):
#+begin_src shell
  git branch --merged | egrep -v &quot;(^\*|master)&quot; | xargs git branch -d
#+end_src

不过这种方法只能删除已经merge到master的分支，其他状态的分支无法被删除，比如在我 [[https://github.com/LCTT/TranslateProject][Linux中国]] 的选题仓库运行 =git branch --merge= 的结果如下
#+begin_src shell :results org :dir /ssh:lujun9972@tencent_cloud#8022:~/github/TranslateProject
  git branch --merged |egrep -v &quot;(^\*|master)&quot;
#+end_src

#+RESULTS:
#+begin_src org
  add-MjAxOTA2MDUgSG93IHRvIG5hdmlnYXRlIHRoZSBLdWJlcm5ldGVzIGxlYXJuaW5nIGN1cnZlLm1kCg==
  add-MjAxOTA2MTAgV2h5IGNvbnRhaW5lcnMgYW5kIEt1YmVybmV0ZXMgaGF2ZSB0aGUgcG90ZW50aWFsIHRvIHJ1biBhbG1vc3QgYW55dGhpbmcubWQK
#+end_src

可以看到，删除的效果不佳啊。

*下面是重点来了*

事实上，github 上的pull request（不管是否关闭） 都对应了一个branch，通过下面操作可以将这些branch拉取下来:

1. 修改 =.git/config= 在 =[remote &quot;origin&quot;]= 中添加下面内容(假设你的远程repo为origin):
   #+begin_src conf
     [remote &quot;origin&quot;]
       url = …
       fetch = +refs/heads/*:refs/remotes/origin/*
       fetch = +refs/pull/*/head:refs/remotes/origin/pr/*
   #+end_src

2. 运行 =git fetch= 拉去remote上的分支。


你会看到大量类似 =remotes/origin/pr/XXXX= 的分支

下面的事情就简单了，遍历所有remote上的分支，然后删除已经合并到该分支上的本地开发队列就行了:
#+begin_src shell
  for r in $(git branch -r --format=&#39;%(refname)&#39;); do git branch --merged $r; done | sort -u | grep -v &#39;^\*&#39; | xargs -r git branch -D
#+end_src

当然，你也很容易发现，若远程仓库pull request特别多，那么这个循环操作也会比较慢。
</description>
<pubDate>2020-05-12</pubDate>
<guid>https://lujun9972.github.io/blog/2020/05/12/git-branch大扫除/index.html</guid>
</item>
<item>
<title>使用 org-mode columnview 生成任务列表</title>
<link>https://lujun9972.github.io/blog/2020/05/08/使用-org-mode-columnview-生成任务列表/index.html</link>
<description>org-mode的columnview[[https://orgmode.org/manual/Dynamic-Blocks.html#Dynamic-Blocks][动态块]]能够帮你把树形的代办事项归整为表格，方便查看

在org-mode中可以通过两个命令来插入colmnviewa动态块:

+ 一个是通过 =M-x org-dynamic-block-insert-dblock= 插入一个动态块，默认情况下 org-mode 自带了两类动态块 =columnview= 和 =clocktable= ，然后我们选择 =columnview= 即可
+ 另一个是通过 =M-x org-columns-insert-dblock= 直接插入columnviewa动态块

  
一个 columnview 动态块大概长这个样子的:
#+begin_src org
  ,#+BEGIN: columnview :参数1 参数值 :参数N h参数值

  ,#+END:

#+end_src

其中 =columnview= 标识动态块的类型，该名字决定了org-mode会调用哪个函数来生成动态块的内容，比如这里调用的函数就是 =org-dblock-write:columnview=. 
后面的 =:参数1 参数值 :参数N h参数值= 参数则会组装成一个plist传递给函数作为唯一的参数，并将函数的返回值作为动态块的内容

我们可以通过查看 =org-dblock-write:columnview= 的docstring来找出 =columnwive= 动态块支持的参数:
#+begin_example
  (org-dblock-write:columnview PARAMS)

  Write the column view table.

  PARAMS is a property list of parameters:

  ‘:id’ (mandatory)

      The ID property of the entry where the columns view should be
      built.  When the symbol ‘local’, call locally.  When ‘global’
      call column view with the cursor at the beginning of the
      buffer (usually this means that the whole buffer switches to
      column view).  When &quot;file:path/to/file.org&quot;, invoke column
      view at the start of that file.  Otherwise, the ID is located
      using ‘org-id-find’.

  ‘:exclude-tags’

      List of tags to exclude from column view table.

  ‘:format’

      When non-nil, specify the column view format to use.

  ‘:hlines’

      When non-nil, insert a hline before each item.  When
      a number, insert a hline before each level inferior or equal
      to that number.

  ‘:indent’

      When non-nil, indent each ITEM field according to its level.

  ‘:match’

      When set to a string, use this as a tags/property match filter.

  ‘:maxlevel’

      When set to a number, don’t capture headlines below this level.

  ‘:skip-empty-rows’

      When non-nil, skip rows where all specifiers other than ITEM
      are empty.

  ‘:vlines’

      When non-nil, make each column a column group to enforce
      vertical lines.
#+end_example

这里比较重要的参数有

+ :id :: 这是最重要的参数. 它指定了column视图的数据来源。
+ :maxlevel :: 若设置为数字N,表示不捕捉层级在N级以下的条目
+ :skip-empty-rows :: 若设置为`t`,则会跳过那些除了`ITEM`属性列外,其他属性列都是空值的行
+ :format :: 设置column视图的格式。

其中 =:format= 是一个以多个列定义式组成的字符串，各定义式之间使用空格进行分隔。
column的定义式中可以包含有列的属性. 一般来说列的定义式看起来是这样做的
#+BEGIN_SRC org
  ,%[width]property[(title)][{summary-type}]
#+END_SRC
除了百分号和属性名之外,所有的都是可选的. 各部分的意思如下所示
#+BEGIN_EXAMPLE
  width           整型,代表了列的宽度,如果忽略则由org自动决定

  property        该列所表示的属性,可以是上文提到的哪些特殊属性

  title           列的标题,如果忽略,则会使用属性名代替

  {summary-type}  总和的类型,如果指定了,那么父节点的列值由其下子节点的值计算得到
                  支持的总和类型包括:
                  {+}       该列的累加值
                  {+;%.1f}  指定了格式的列累加值
                  {$}       货币格式，其实就是 ‘+;%.2f’.
                  {:}       把列中的值作为时间进行累加，格式为HH[:MM]
                  {X}       Checkbox 的状态, 若所有子checkboxd都标记为‘[X]’ 则显示‘[X]’.
                  {X/}      Checkbox 的状态, 显示格式为‘[n/m]’.
                  {X%}      Checkbox 的状态, 显示格式为‘[n%]’.
                  {min}     列中的最小值
                  {max}     列中的最大值
                  {mean}    列的算术平均值
                  {:min}    列中的最小值（以时间为单位）
                  {:max}    列中的最大值（以时间为单位）
                  {:mean}   列中的算术平均值（以时间为单位）
                  {@min}    列中的最小值（以时间区间为单位）
                  {@max}    列中的最大值（以时间区间为单位）
                  {@mean}   列中的算术平均值（以时间区间为单位）
                  {est+}    耗时的范围

#+END_EXAMPLE

我一般使用 columnview 来生成任务列表方便我对任务进度进行追踪。下面是一个例子
#+begin_src org
  ,* 任务分派

  ,#+BEGIN: columnview :hlines 1 :id local :format &quot;%ITEM(任务) %CHARGER(负责人) %DEADLINE(死线) %TODO(状态)&quot; :skip-empty-rows t
  | 任务   | 负责人    | 死线            | 状态  |
  |--------+-----------+-----------------+-------|
  | 任务一 | 甲xx      |                 | NEXT  |
  | 任务二 | 乙xx      | &lt;2020-05-12 二&gt; | TODAY |
  | 任务三 | 甲xx 乙xx |                 | TODO  |
  ,#+END:

  ,** NEXT 任务一
     :PROPERTIES:
     :CHARGER:  甲xx
     :END:
  + [ ] xxxx
  + [ ] yyyy
  + [ ] zzzz
  + [X] abcd
  ,** TODAY [#A] 任务二
     DEADLINE: &lt;2020-05-12 二&gt;
     :PROPERTIES:
     :CHARGER:  乙xx
     :END:
  + [ ] 111111
  + [ ] 222222
  ,** TODO [#C] 任务三
     :PROPERTIES:
     :CHARGER:  甲xx 乙xx
     :END:
#+end_src
</description>
<pubDate>2020-05-09</pubDate>
<guid>https://lujun9972.github.io/blog/2020/05/08/使用-org-mode-columnview-生成任务列表/index.html</guid>
</item>
</channel>
</rss>