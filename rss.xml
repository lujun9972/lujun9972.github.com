<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
  <channel>
    <title>暗无天日</title>
    <link>https://lujun9972.github.io</link>
    <description>=============&gt;DarkSun的个人博客</description>
    <pubDate>Thu, 15 Apr 2021 11:27:49 UTC</pubDate>
    <lastBuildDate>Thu, 15 Apr 2021 11:27:49 UTC</lastBuildDate>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <generator>ego static site generator (https://github.com/emacs-china/ego)</generator>
<item>
<title>使用awk查找并修复数据中一对多的不一致问题</title>
<link>https://lujun9972.github.io/blog/2021/04/15/使用awk查找并修复数据中一对多的不一致问题/index.html</link>
<description>从 https://www.datafix.com.au/BASHing/2021-03-17.html 上看到的一个 =awk= 小技巧。

所谓“一对多”的不一致问题是指这么一种情况：属性1与属性2本来应该是 =1:1= 或者 =N:1= 的关系，但是由于数据错误导致同一个属性1有了多个属性2与之对应。

例如下面数据中， 每个 =item= 本来应该只有唯一的一个 =class=,但是实际上 =banana= 和 =potato= 有多个 =class= 与之对应。
#+begin_example
  saleID	date	item	class	kg
  001	2021-01-02	capsicum	vegetable	11.9
  002	2021-01-02	banana	fruit	12.7
  003	2021-01-02	capsicum	vegetable	3.7
  004	2021-01-02	potato	vegetable	4.1
  005	2021-01-02	capsicum	vegetable	6.0
  006	2021-01-02	potato	fruit	13.0
  007	2021-01-02	banana	vegetable	9.1
  008	2021-01-02	potato	vegetable	15.0
  009	2021-01-02	apple	fruit	5.6
  010	2021-01-02	banana	fruit	7.7
  011	2021-01-02	pumpkin	vegetable	8.3
  012	2021-01-02	pumpkin	vegetable	5.6
  013	2021-01-02	apple	fruit	3.5
  014	2021-01-02	pumpkin	vegetable	5.3
  015	2021-01-02	capsicum	vegetable	10.3
  016	2021-01-03	apple	fruit	12.2
  017	2021-01-03	pumpkin	vegetable	12.6
  018	2021-01-03	potato	vegetable	4.4
  019	2021-01-03	apple	fruit	12.5
  020	2021-01-03	pumpkin	vegetable	11.6
  021	2021-01-03	banana	vegetable	14.5
  022	2021-01-03	capsicum	vegetable	4.1
  023	2021-01-03	banana		5.9
  024	2021-01-03	potato	vegetable	4.8
  025	2021-01-03	apple	fruit	15.6
#+end_example

为了找出一对多的关系，我们需要使用二维数组来保存 =属性1= 和 =属性2= 的关系，然后判断 =属性1= 这个一维数组中是否包含数组个数大于1的数值就行了（原文的判断方法比这要复杂，我简化了一下）。awk 程序如下
#+begin_src shell :results org
awk &#39;{b[$3][$4]++}
END {for (i in b) {if (length(b[i])&gt;1){
            for (j in b[i]){
                print b[i][j] &quot;|&quot; i FS j}}}}&#39; /tmp/test.txt

#+end_src

#+RESULTS:
#+begin_src org
4|potato vegetable
1|potato fruit
2|banana vegetable
1|banana 5.9
2|banana fruit
#+end_src
这里第一列是每个 =属性1 属性2= 对的数量，第二列是重复的 =属性1 属性2= 对的值。

为了方便复用，我们可以定义一个 =one2many= 的函数：
#+NAME: one2many
#+begin_src shell :tangle /tmp/one2many.sh
  one2many() {
      sep=&quot;$1&quot;                    # 数据分隔符
      one=&quot;$2&quot;                    # 属性1
      many=&quot;$3&quot;                   # 属性2
      file=&quot;$4&quot;                   # 数据文件路径
      awk -F&quot;${sep}&quot; -v one=&quot;${one}&quot; -v many=&quot;${many}&quot; &#39;$one != &quot;&quot; {b[$one][$many]++}
  END {for (i in b)
           {if (length(b[i]) &gt; 1) {
              for (j in b[i])
                  {print b[i][j] FS i FS j}}}}&#39; &quot;${file}&quot;
  }
#+end_src

这个函数与上面命令不同之处在于通过 =-F= 指定数据分隔符，通过 =-v= 将函数参数传递给 awk 变量，使用 =FS= 变量替代 =|= 作为数量与重复属性对之间的分隔符。

那么，我们可以直接使用该函数进行数据检测：
#+begin_src shell :noweb eval :results org
  &lt;&lt;one2many&gt;&gt;
  one2many &quot; &quot; 3 4 /tmp/test.txt
#+end_src

#+RESULTS:
#+begin_src org
4 potato vegetable
1 potato fruit
2 banana vegetable
1 banana 5.9
2 banana fruit
#+end_src

修复相对来说就比较简单了，我们首先创建一个查询表，用来查询 =属性1= 对应的 =属性2=,这个查询可以从 =one2many= 函数的结果中截取：
#+begin_src shell :noweb eval :results org
  &lt;&lt;one2many&gt;&gt;
  one2many &quot; &quot; 3 4 /tmp/test.txt |sed -n &#39;1p;5p&#39; |tee /tmp/lookup
#+end_src

#+RESULTS:
#+begin_src org
4 potato vegetable
2 banana fruit
#+end_src

然后在 awk 中查询 =属性1= 的值若在查询表中则将 =属性2= 的值直接改为查询表中的对应结果：
#+begin_src shell :results org
  awk &#39;FNR==NR {lookup[$1]=$2; next} # 通过FNR==NR判断是否在遍历查询表文件
  $3 in lookup {$4=lookup[$3]} 1&#39; /tmp/lookup /tmp/test.txt # awk 最后那个1表示执行awk 的默认操作，即输出$0
#+end_src

#+RESULTS:
#+begin_src org
saleID	date	item	class	kg
001	2021-01-02	capsicum	vegetable	11.9
002	2021-01-02	banana	fruit	12.7
003	2021-01-02	capsicum	vegetable	3.7
004	2021-01-02	potato	vegetable	4.1
005	2021-01-02	capsicum	vegetable	6.0
006	2021-01-02	potato	fruit	13.0
007	2021-01-02	banana	vegetable	9.1
008	2021-01-02	potato	vegetable	15.0
009	2021-01-02	apple	fruit	5.6
010	2021-01-02	banana	fruit	7.7
011	2021-01-02	pumpkin	vegetable	8.3
012	2021-01-02	pumpkin	vegetable	5.6
013	2021-01-02	apple	fruit	3.5
014	2021-01-02	pumpkin	vegetable	5.3
015	2021-01-02	capsicum	vegetable	10.3
016	2021-01-03	apple	fruit	12.2
017	2021-01-03	pumpkin	vegetable	12.6
018	2021-01-03	potato	vegetable	4.4
019	2021-01-03	apple	fruit	12.5
020	2021-01-03	pumpkin	vegetable	11.6
021	2021-01-03	banana	vegetable	14.5
022	2021-01-03	capsicum	vegetable	4.1
023	2021-01-03	banana		5.9
024	2021-01-03	potato	vegetable	4.8
025	2021-01-03	apple	fruit	15.6
#+end_src
</description>
<pubDate>2021-04-15</pubDate>
<guid>https://lujun9972.github.io/blog/2021/04/15/使用awk查找并修复数据中一对多的不一致问题/index.html</guid>
</item>
<item>
<title>升级库文件后如何查找需要重启的服务</title>
<link>https://lujun9972.github.io/blog/2021/04/14/升级库文件后如何查找需要重启的服务/index.html</link>
<description>从 https://www.cyberciti.biz/faq/how-to-restart-systemd-without-rebooting-linux-when-critical-libraries-installed/ 上看到的一个小技巧。

当升级库文件后，那些使用该库的服务需要重启后才会真正使用该库文件中的内容。一个常用的方法是直接重启系统，这样所有服务在启动时自然使用的是最新库的内容，但是作为服务器是不可能允许随意重启的，那么在不重启的情况下如何找出受到影像的服务呢？

这里有个简单的方法：
#+begin_src shell :dir /ssh:lujun9972@tencent_cloud.lujun9972.win#8022: :results org
  sudo lsof -d &#39;DEL&#39; | grep &#39;lib&#39; | cut -f 1 -d &#39; &#39; | sort -u
#+end_src

#+RESULTS:
#+begin_src org
  acpid
  agetty
  atd
  dbus-daem
  dhclient
  dictd
  gdbus
  gmain
  JS
  lsmd
  master
  polkitd
  qmgr
  sshd
  systemd-l
#+end_src

其原理就是用 lsof 查出所有 FD 为 =DEL(已删除的映射文件)= 且路径中带 =lib= 的命令。然后就可以使用 =systemctl restart= 重启服务了。

不过 =systemd= 本身作为1号进程不能通过 =systemctl restart= 来进行重启，而需要使用 =sudo systemctl daemon-reexec= 来重启。

关于 =systemctl daemon-reexec= 的说明如下：
#+begin_example
  daemon-reexec  Reexecute the systemd manager. This will serialize the manager state, reexecute the process and deserialize the state again. This command is of little use except for debugging and package upgrades. Sometimes, it might be helpful as a heavy-weight daemon-reload. While the daemon is being reexecuted, all sockets systemd listening on behalf of user configuration will stay accessible.
#+end_example
</description>
<pubDate>2021-04-14</pubDate>
<guid>https://lujun9972.github.io/blog/2021/04/14/升级库文件后如何查找需要重启的服务/index.html</guid>
</item>
<item>
<title>Bash中的TryCatch语句</title>
<link>https://lujun9972.github.io/blog/2021/04/14/bash中的trycatch语句/index.html</link>
<description>Bash 中是没有原生的Try Catch 语句的，但是今天从 https://www.xmodulo.com/catch-handle-errors-bash.html 上我看到了一种模拟 Try Catch 的方法。

函数定义如下（经过了一些改造，更好理解一些，而且原文是有一点小错误的）：

#+begin_src shell :tangle :~/bin/lib/trycatch.sh
  function try()
  {
      if [[ $SHELLOPTS = *errexit* ]];then      # $SHELLOPTS 中包含了 shell 的配置项
         ERREXIT_P=&quot;Y&quot;                          # 保存ERREXIT的启用情况
         set +e                                 # 若开启了ERREXIT则需要关闭该配置项，否则后面throw()返回非0值时会直接终止代码运行，也就没法运行后面的catch()语句了
      fi
  }

  function throw()
  {
      exit $1
  }

  function catch()
  {
      export exception_code=$?
      if [[ ${ERREXIT_P} == &quot;Y&quot; ]];then
       set -e                     # 恢复原ERREXIT配置项
      fi
      return $exception_code
  }
#+end_src

这套函数的使用方法如下例子所示：
#+begin_src shell
  # 引入 trycatch 语句
  source ./trycatch.sh

  # 定义异常类型
  export ERR_BAD=100
  export ERR_WORSE=101
  export ERR_CRITICAL=102

  try
  (                               # 注意这里进入子shell执行命令
      echo &quot;Start of the try block&quot;

      # 当命令执行出错（返回非0值），则throw 会退出子shell 的执行，并返回异常.
      run-command || throw $ERR_BAD
      run-command2 || throw $ERR_WORSE
      run-command3 || throw $ERR_CRITICAL

      echo &quot;End of the try block&quot;
  )
  catch || {                      # 若子shell执行有异常，则执行后面 {} 中的语句
      case $exception_code in     # exception_code 中存放的是子 shell 的返回值，在有异常的情况下也就是throw 出来的异常码
          $ERR_BAD)
              echo &quot;This error is bad&quot;
          ;;
          $ERR_WORSE)
              echo &quot;This error is worse&quot;
          ;;
          $ERR_CRITICAL)
              echo &quot;This error is critical&quot;
          ;;
          ,*)
              echo &quot;Unknown error: $exit_code&quot;
              throw $exit_code    # re-throw an unhandled exception
          ;;
      esac
  }
#+end_src

这套TryCatch模拟语句最大的坑莫过于 try 的语句是在子shell 中执行了，这使得 try 中的执行内容无法修改其他代码块中的变量。
</description>
<pubDate>2021-04-14</pubDate>
<guid>https://lujun9972.github.io/blog/2021/04/14/bash中的trycatch语句/index.html</guid>
</item>
<item>
<title>笑话理解之Seeman</title>
<link>https://lujun9972.github.io/blog/2021/03/09/笑话理解之seeman/index.html</link>
<description>
#+begin_example
  What do blondes and the Bermuda Triangle have in common?

  They&#39;ve both swallowed a lot of semen.
#+end_example

=see men=, =semen= 傻傻分不清楚
</description>
<pubDate>2021-03-09</pubDate>
<guid>https://lujun9972.github.io/blog/2021/03/09/笑话理解之seeman/index.html</guid>
</item>
<item>
<title>笑话理解之Denomination</title>
<link>https://lujun9972.github.io/blog/2021/02/24/笑话理解之denomination/index.html</link>
<description>
* Buy stamps
#+begin_example
  A woman walks into the Post Office to buy stamps for her Christmas cards.

  &quot;What denomination?&quot; asks the clerk.

  &quot;Oh, good heavens! Have we come to this?&quot; said the woman. &quot;Well, give me 50 Baptist and 50 Catholic and one Methodist.&quot;
#+end_example

=denomination= 即有 =面额= 也有 =教派= 的意思。
</description>
<pubDate>2021-02-24</pubDate>
<guid>https://lujun9972.github.io/blog/2021/02/24/笑话理解之denomination/index.html</guid>
</item>
<item>
<title>笑话理解之Nail</title>
<link>https://lujun9972.github.io/blog/2021/02/24/笑话理解之nail/index.html</link>
<description>* Nailed it
[[file:images/joke_nail.jpg]]

=nail= 是 =钉牢= 的意思，但是 =nailed it= 是 =搞定= 的意思
</description>
<pubDate>2021-02-24</pubDate>
<guid>https://lujun9972.github.io/blog/2021/02/24/笑话理解之nail/index.html</guid>
</item>
<item>
<title>笑话理解之bday</title>
<link>https://lujun9972.github.io/blog/2021/02/24/笑话理解之bday/index.html</link>
<description>* bday or dday
[[file:images/joke_bday.jpg]]

=bday= 指 =生日=, =D-day= 特指 =诺曼底登陆=
</description>
<pubDate>2021-02-24</pubDate>
<guid>https://lujun9972.github.io/blog/2021/02/24/笑话理解之bday/index.html</guid>
</item>
<item>
<title>笑话理解之letter</title>
<link>https://lujun9972.github.io/blog/2021/02/01/笑话理解之letter/index.html</link>
<description>* envelope
#+begin_example
  What starts with &quot;e&quot;, ends with &quot;e&quot;, and contains one letter?

  An envelope.
#+end_example

=letter= 既有 =字母= 的意思，也有 =信封= 的意思。
</description>
<pubDate>2021-02-01</pubDate>
<guid>https://lujun9972.github.io/blog/2021/02/01/笑话理解之letter/index.html</guid>
</item>
<item>
<title>笑话理解之Bark</title>
<link>https://lujun9972.github.io/blog/2021/01/25/笑话理解之bark/index.html</link>
<description>* Bark
#+begin_example
  Teacher: &quot;What do we call the outer part of a tree?&quot;

  Pupil: &quot;Don&#39;t know Miss!&quot;

  Teacher: &quot;Bark, silly, bark!&quot;

  Pupil: &quot;Woof, woof!&quot;
#+end_example

=Bark= 既有 =树皮= 的意思，也有 =狗叫= 的意思。
</description>
<pubDate>2021-01-25</pubDate>
<guid>https://lujun9972.github.io/blog/2021/01/25/笑话理解之bark/index.html</guid>
</item>
<item>
<title>笑话理解之HotWater</title>
<link>https://lujun9972.github.io/blog/2020/12/21/笑话理解之hotwater/index.html</link>
<description>
* How are men like noodles?
#+begin_example
  How are men like noodles?

  They are always in hot water, they lack taste, and they need dough.
#+end_example

这个双关比较多：
+ =hot water= 即是 =热水= 也表示 =困境=
+ =taste= 即是 =味道= 也表示 =品位=
+ =dough= 即是 =生面团= 在美国俚语中也表示 =金钱=
</description>
<pubDate>2020-12-21</pubDate>
<guid>https://lujun9972.github.io/blog/2020/12/21/笑话理解之hotwater/index.html</guid>
</item>
</channel>
</rss>