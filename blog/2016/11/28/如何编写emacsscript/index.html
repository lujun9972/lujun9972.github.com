<!DOCTYPE html>
<html lang="en">
<head>
  <title>如何编写EmacsScript - 暗无天日</title>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <meta name="author" content="lujun9972" />
  <style>
   #ds-thread #ds-reset .ds-comment-body p {color: #ffffff;}
   #disqus_thread a {color: #00ffff;}
  </style>
  <link rel="stylesheet" media="screen" href="../../../../../media/css/font.css" rel="stylesheet" type="text/css"/>
  <link rel="stylesheet" href="../../../../../media/css/main.css" type="text/css">
  <link rel="stylesheet" href="../../../../../media/css/org-src-fontify.css" type="text/css">
  <link rel="stylesheet" href="../../../../../media/css/kdComment.css" type="text/css">
  <script type="text/javascript"
          src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
  <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
</head>

  <body class="container">
<div>
  <header class="masthead">
    <h1 class="masthead-title"><a href="../../../../../">暗无天日</a></h1>
    <p>=============&gt;DarkSun的个人博客</p>
    <nav class="site-nav">
      <div class="menu-icon">
      </div>
      <ul class="trigger">
              <li><a href="../../../../../years/">Years</a></li>
              <li><a href="../../../../../tags/">Tags</a></li>
              <li><a href="../../../../../about/">About</a></li>
              <li><a href="https://github.com/lujun9972/lujun9972.github.com.git">Github</a></li>
              <li><a href="../../../../../rss.xml">RSS</a></li>
      </ul>
    </nav>
    <form method="get" id="searchform" action="http://www.google.com/search">
        <input type="text" class="field" name="q" id="s" placeholder="Search">
        <input type="hidden" name="as_sitesearch" value="lujun9972.github.io">
    </form>
  </header>
</div>

<div>
<div class="post">
<h1 class="title">如何编写EmacsScript</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org5b18b3a">1. &#x2013;script选项</a></li>
<li><a href="#orgb3b58d0">2. 处理命令行参数</a></li>
<li><a href="#org0b59814">3. EmacsScript的执行顺序</a></li>
<li><a href="#org5ab6543">4. 标准输出,标准错误与标准输入</a></li>
<li><a href="#org89d714a">5. 获取外部命令的运行结果</a></li>
<li><a href="#org78e2aa3">6. 加速EmacsScript的启动过程</a></li>
</ul>
</div>
</div>
<p>
Emacs作为一款文本编辑器已经为大家所熟知,但是可能比较少人会想到它还能用来像python,ruby一样作为一门脚本语言来用.
</p>

<p>
注意: EmacsScript的坑超级多,强烈推荐阅读这篇文章:<a href="http://www.lunaryorn.com/posts/emacs-script-pitfalls.html">emacs-script-pitfalls</a> (这里是它的中文版<a href="https://github.com/lujun9972/emacs-document/blob/master/elisp-common/emacs-script%E4%B8%AD%E7%9A%84%E9%82%A3%E4%BA%9B%E5%9D%91.org">emacs-script中的那些坑</a>)
</p>

<div id="outline-container-org5b18b3a" class="outline-2">
<h2 id="org5b18b3a"><span class="section-number-2">1</span> &#x2013;script选项</h2>
<div class="outline-text-2" id="text-1">
<p>
Emacs提供了一个 <code>--script</code> 选项可以让Emacs运行在batch模式下,并运行指定文件中的elisp代码. 
</p>

<p>
在batch模式下emacs完全作为一个elisp语言解释器来运行,并在执行完所有的elisp代码后直接退出. 在elisp代码执行期间,那些输出到echo area中的内容会输出到stdout或stderr中,那些从minibuffer读取内容的函数会变成从stdin读取内容.
</p>

<p>
Emacs为了遵循shell script的shebang标准,特意将第一行内容中的的 <code>#!</code> 当成注释符号来处理,因此你的EmacsScript一般会是这样的:
</p>
<div class="org-src-container">
<pre class="src src-sh"><span class="org-comment-delimiter">#</span><span class="org-comment">!/usr/bin/</span><span class="org-keyword">emacs</span><span class="org-comment"> --script</span>
(message <span class="org-string">"Hello world"</span>)
</pre>
</div>

<p>
当然,这种写法并不具有可移植性的,毕竟不是所有的emacs路径都是 <code>/usr/bin/emacs</code>. 真正具有可移植性的写法应该是:
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">#!/bin/sh
<span class="org-string">":"</span><span class="org-comment-delimiter">; </span><span class="org-comment">exec emacs --quick --script "$0" -- "$@" # -*- mode: emacs-lisp; lexical-binding: t; -*-</span>
(message <span class="org-string">"Hello world"</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb3b58d0" class="outline-2">
<h2 id="orgb3b58d0"><span class="section-number-2">2</span> 处理命令行参数</h2>
<div class="outline-text-2" id="text-2">
<p>
注意:对于EmacsScript来说,参数与选项是截然不同的两个东西. 而且选项不能放在参数最后,否则Emacs会提示"emacs: Option '-f' requires an argument"
</p>

<p>
在EmacsLisp中,与处理命令行参数有关的常用变量有这么几个:
</p>

<ul class="org-ul">
<li><p>
command-line-args-left
</p>

<p>
尚未处理的command-line argument列表. 
</p>

<p>
假设有这么一个"/tmp/test1.el"的脚本:
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">#!/bin/sh
<span class="org-string">":"</span><span class="org-comment-delimiter">; </span><span class="org-comment">exec emacs --script "$0" "$@" # -*- mode: emacs-lisp; lexical-binding: t; -*-</span>
(princ (format <span class="org-string">"command-line-args-left=%s"</span> command-line-args-left))
</pre>
</div>

<p>
那么执行该脚本的结果是:
</p>
<div class="org-src-container">
<pre class="src src-sh">/tmp/test1.el a b c
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org">command-line-args-left=(a b c)
</pre>
</div></li>

<li><p>
command-line-args
</p>

<p>
传递给Emacs的完整command-line argument列表,但是这个变量一般很少用,但它可以用于获取script脚本本身的名字.
</p>

<p>
假设有这么一个"/tmp/test2.el"的脚本:
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">#!/bin/sh
<span class="org-string">":"</span><span class="org-comment-delimiter">; </span><span class="org-comment">exec emacs --script "$0" "$@" # -*- mode: emacs-lisp; lexical-binding: t; -*-</span>
(princ (format <span class="org-string">"command-line-args=%s\n"</span> command-line-args))
(princ (format <span class="org-string">"$0=%s"</span> (nth 2 command-line-args)))
</pre>
</div>

<p>
那么执行该脚本的结果是:
</p>
<div class="org-src-container">
<pre class="src src-sh">/tmp/test2.el a b c
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org">command-line-args=(emacs -scriptload /tmp/test2.el a b c)
$0=/tmp/test2.el
</pre>
</div>

<p>
可以用 <code>(nth 2 command-line-args)</code> 来获取脚本名称.
</p></li>

<li><p>
command-switch-alist
</p>

<p>
Emacs在执行完EmacsScript中的语句之后,会检查 <code>command-line-args-left</code> 中是否包含有以 <code>-</code> 开头的选项,并在该变量中查找并运行对应的handler-function. 每处理完一个选项之后,就将该参数从 <code>command-line-args-left</code> 中删除掉.
</p>

<p>
该变量是元素为`(option . handler-function)'的alist. 这里
</p>

<ul class="org-ul">
<li>option为command-line argument中的`-option'参数(<b>带-</b>),为字符串格式</li>

<li>handler-function为相应的处理函数名,它接收option为唯一参数</li>
</ul>

<p>
若command line option后还带了其他参数,则在handler-function中可以通过变量`command-line-args-left'来获取剩余的命令行参数.
</p>

<p>
例如有这么一个脚本:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">#!/bin/sh
<span class="org-string">":"</span><span class="org-comment-delimiter">; </span><span class="org-comment">exec emacs --script "$0" "$@" # -*- mode: emacs-lisp; lexical-binding: t; -*-</span>
(<span class="org-keyword">defun</span> <span class="org-function-name">print-option-value</span> (option)
  (princ (format <span class="org-string">"command-line-args-left=%s\n"</span> command-line-args-left))
  (princ (format <span class="org-string">"value of %s is %s\n"</span> option (car command-line-args-left)))
  (<span class="org-keyword">pop</span> command-line-args-left))

(add-to-list 'command-switch-alist '(<span class="org-string">"-f"</span> . print-option-value))

</pre>
</div>

<p>
那么执行该脚本的结果是:
</p>
<div class="org-src-container">
<pre class="src src-sh">/tmp/test3.el a -f filename b c
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org">command-line-args-left=(filename b c)
value of -f is filename
</pre>
</div></li>

<li><p>
command-line-functions
</p>

<p>
该变量是一系列函数的列表,这些函数用来处理无法识别的command-line参数.
</p>

<p>
每次处理一个没有特殊意义的command line argument时,该变量中的函数都会被依次调用, <b>直到有一个函数返回非nil的值</b>
</p>

<p>
<b>这些函数被调用时并不传递参数,但在这些函数内可以通过变量`argi'获取当前待处理的command-line argument. 可以通过变量`command-line-args-left'获取尚未被处理的command line arguments</b>. 
</p>

<p>
<b>若某函数除了当前待处理的函数,同时也把后面的参数給处理过了,则需要把后面那些被处理过的参数从`command-line-args-left'中删除</b>
</p>

<p>
<b>若某函数已经处理了当前代处理的参数,则一定记得返回非nil值</b>. <b>若所有的函数都返回nil,该参数会被认为是Emacs要打开的文件名称</b>
</p>

<p>
例如有这么一个脚本:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">#!/bin/sh
<span class="org-string">":"</span><span class="org-comment-delimiter">; </span><span class="org-comment">exec emacs --script "$0" "$@" # -*- mode: emacs-lisp; lexical-binding: t; -*-</span>
(<span class="org-keyword">defun</span> <span class="org-function-name">print-option</span> ()
  (princ (format <span class="org-string">"command-line-args-left=%s\n"</span> command-line-args-left))
  (princ (format <span class="org-string">"option is %s\n"</span> argi)))

(add-to-list 'command-line-functions  #'print-option)
</pre>
</div>

<p>
那么执行该脚本的结果是:
</p>
<div class="org-src-container">
<pre class="src src-sh">/tmp/test4.el a -p filename b
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org">command-line-args-left=(-p filename b)
option is a
command-line-args-left=(filename b)
option is -p
command-line-args-left=(b)
option is filename
command-line-args-left=nil
option is b
</pre>
</div>

<p>
我们可以在脚本中同时使用 <code>command-switch-alist</code> 与 <code>command-line-functions</code>. 它们的调用顺序是按照传递给EmacsScript的参数顺序来进行的.
</p>

<p>
例如有这么一个脚本:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">#!/bin/sh
<span class="org-string">":"</span><span class="org-comment-delimiter">; </span><span class="org-comment">exec emacs --script "$0" "$@" # -*- mode: emacs-lisp; lexical-binding: t; -*-</span>
(<span class="org-keyword">defun</span> <span class="org-function-name">print-option</span> ()
  (princ (format <span class="org-string">"option is %s\n"</span> argi)))
(add-to-list 'command-line-functions  #'print-option)

(<span class="org-keyword">defun</span> <span class="org-function-name">print-option-value</span> (option)
  (princ (format <span class="org-string">"value of option %s is %s\n"</span> option (<span class="org-keyword">pop</span> command-line-args-left))))
(add-to-list 'command-switch-alist '(<span class="org-string">"-f"</span> . print-option-value))
</pre>
</div>

<p>
那么执行该脚本的结果会是:
</p>
<div class="org-src-container">
<pre class="src src-sh">/tmp/test5.el a -f f -p p
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org">command-line-args-left=(-f f -p p)
option is a
value of option -f is f
command-line-args-left=(p)
option is -p
command-line-args-left=nil
option is p
</pre>
</div></li>
</ul>
</div>
</div>

<div id="outline-container-org0b59814" class="outline-2">
<h2 id="org0b59814"><span class="section-number-2">3</span> EmacsScript的执行顺序</h2>
<div class="outline-text-2" id="text-3">
<p>
从上面命令行参数的说明中,大致可以推断出EmacsScript的执行顺序为:
</p>

<ol class="org-ol">
<li>Emacs读取并执行EmacsScript中的内容</li>
<li>Emacs遍历 <code>command-line-args-left</code> 中的参数,对于 <code>command-switch-alist</code> 中的参数调用对应的函数,对于不在 <code>command-switch-alist</code> 中的参数依次调用 <code>command-line-functions</code> 中的函数</li>
<li>倘若 <code>command-line-functiions</code> 中没有定义函数,或者某参数在依次调用 <code>command-line-functions</code> 中的函数后所有函数都返回nil的话,那么该参数交由emacs本身处理.</li>
</ol>
</div>
</div>

<div id="outline-container-org5ab6543" class="outline-2">
<h2 id="org5ab6543"><span class="section-number-2">4</span> 标准输出,标准错误与标准输入</h2>
<div class="outline-text-2" id="text-4">
<p>
在interactive模式下编写EmacsLisp函数时,我们习惯于用 <code>message</code> 函数来输出内容,然而在batch模式下,我们就不能再用 <code>message</code> 来输出内容了,因为 <code>message</code> 实际上会把内容输出到stderr上.
</p>

<p>
作为替代,若是要想将内容输出到stdout,你需要使用 <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Output-Functions.html#index-print">print</a>, <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Output-Functions.html#index-prin1">prin1</a>, <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Output-Functions.html#index-princ">princ</a> 等这一系列的函数来输出内容. 然而这一类的函数本身并没有格式化输出的功能,因此你一般还需要用 <code>format</code> 函数预先将要输出的内容格式化成字符串.
</p>

<p>
那么如何从标准输入读取内容呢? 只需要跟interactive模式下一样使用 <code>read-xxx</code> 系列函数就行了. 在batch模式下,原先从minbuffer读取内容的函数会改成从stdin中读取内容.
</p>

<p>
唯一需要注意的是:Emacs24及其之前的版本的Emacs在batch模式下用 <code>read-passwd</code> 从标准输出读取密码时,会在终端上显示出密码的内容. Emacs25版本的 <code>read-passwd</code> 则解决了这个问题.
</p>
</div>
</div>

<div id="outline-container-org89d714a" class="outline-2">
<h2 id="org89d714a"><span class="section-number-2">5</span> 获取外部命令的运行结果</h2>
<div class="outline-text-2" id="text-5">
<p>
在shell编程中,可以使用 <code>$()</code> 来捕获命令的运行结果, EmacsScript不支持这种语法,但可以通过函数 <code>shell-command-to-string</code> 来代替. 比如
</p>

<p>
假设有这么一个脚本:
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">#!/bin/sh
<span class="org-string">":"</span><span class="org-comment-delimiter">; </span><span class="org-comment">exec emacs --script "$0" "$@" # -*- mode: emacs-lisp; lexical-binding: t; -*-</span>
(princ <span class="org-string">"&#25429;&#33719;ls&#30340;&#20869;&#23481;:\n"</span>)
(princ (shell-command-to-string <span class="org-string">"ls -l"</span>))
</pre>
</div>

<p>
那么执行该脚本的结果是:
</p>
<div class="org-src-container">
<pre class="src src-sh">/tmp/test6.el
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org">&#25429;&#33719;ls&#30340;&#20869;&#23481;:
&#24635;&#29992;&#37327; 60
-rw-rw-r-- 1 lujun9972 lujun9972  9213 11&#26376; 22 22:29 Emacs&#26597;&#30475;&#26085;&#24535;&#24120;&#29992;&#21629;&#20196;.org
-rw-rw-r-- 1 lujun9972 lujun9972 10881 11&#26376; 22 22:29 Emacs&#20013;&#37027;&#20123;&#19981;&#24120;&#29992;&#30340;&#34892;&#25805;&#20316;&#21629;&#20196;.org
-rw-rw-r-- 1 lujun9972 lujun9972  5507 11&#26376; 22 22:29 Emacs&#20316;&#20026;&#22270;&#29255;&#27983;&#35272;&#22120;.org
-rw-rw-r-- 1 lujun9972 lujun9972  3226 11&#26376; 22 22:29 tramp&#30340;&#19968;&#33324;&#29992;&#27861;.org
-rw-rw-r-- 1 lujun9972 lujun9972  2522 11&#26376; 22 22:29 &#21028;&#26029;Emacs&#26159;&#21542;&#22312;&#22270;&#24418;&#29615;&#22659;&#20013;&#30340;&#27491;&#30830;&#26041;&#27861;.org
-rw-rw-r-- 1 lujun9972 lujun9972  9725 11&#26376; 28 20:41 &#22914;&#20309;&#32534;&#20889;EmacsScript.org
-rw-rw-r-- 1 lujun9972 lujun9972  1524 11&#26376; 22 22:29 &#20351;&#29992;Emacs ediff&#20316;&#20026;git diff&#24037;&#20855;.org
-rw-rw-r-- 1 lujun9972 lujun9972  1791 11&#26376; 22 22:29 &#20351;&#29992;Emacs ediff&#20316;&#20026;git merge&#24037;&#20855;.org
</pre>
</div>

<p>
当然,如果你愿意,完全可以使用底层的 <code>call-process</code> 与 <code>start-process</code>,这两个函数能让你更细致地控制子进程.
</p>
</div>
</div>

<div id="outline-container-org78e2aa3" class="outline-2">
<h2 id="org78e2aa3"><span class="section-number-2">6</span> 加速EmacsScript的启动过程</h2>
<div class="outline-text-2" id="text-6">
<p>
<code>--script</code> 选项会阻止Emacs启动时加载用户的初始化文件,但是依然会加载global site初始化文件.
</p>

<p>
若因此而拖慢了EmacsScript的启动速度,那么可以考虑添加 <code>--quick</code> 选项来明确禁止global site的初始化.
</p>
</div>
</div>

</div>
</div>
<div>
  <div class="post-meta">
    <span title="post date" class="post-info">2016-11-28</span>
    <span title="last modification date" class="post-info">2017-01-09</span>
    <span title="tags" class="post-info">N/A</span>
    <span title="author" class="post-info">lujun9972</span>
  </div>
  <script src="../../../../../media/js/jquery-2.1.3.min.js"></script>
  <script src="../../../../../media/js/md5.min.js"></script>
  <!-- 添加一叶 -->
  <link href="https://yiyechat.com/open-source/build/content-static/css/main.css" rel="stylesheet">
  <script src="https://yiyechat.com/open-source/build/content-static/js/main.js" ></script>
  <section>
      <div id="gitalk-container"></div>
      <script type="text/javascript">
       var gitalk = new Gitalk({
           clientID: 'fdcb5d9da3f4acb4862c',
           clientSecret: 'dd0a16312a206782cb7669dcec5e96874ab48170',
           repo: 'lujun9972.github.com',
           owner: 'lujun9972',
           admin: ['lujun9972'],
           id: md5(location.pathname),      // Ensure uniqueness and length less than 50
           distractionFreeMode: false  // Facebook-like distraction free mode
       })
       gitalk.render('gitalk-container')
      </script>
  </section>
  <script src="../../../../../media/js/kdComment.js"></script>
      <script>
       var _hmt = _hmt || [];
       (function() {
           var hm = document.createElement("script");
           hm.src = "https://hm.baidu.com/hm.js?7bac4fd0247f69c27887e0d4e3aee41e";
           var s = document.getElementsByTagName("script")[0]; 
           s.parentNode.insertBefore(hm, s);
       })();
      </script>
  <div class="footer">
    <p>Generated by <a href="http://www.gnu.org/software/emacs/">Emacs</a> 27.x(<a href="http://orgmode.org">Org mode</a> 9.x)</p>
    <p>
      Copyright &copy; 2014 - <span id="footerYear"></span> <a href="mailto:travis &lt;at&gt; travis-job-cf245b62-6b83-4530-a4d8-6c9bca0125b9">lujun9972</a>
      &nbsp;&nbsp;-&nbsp;&nbsp;
      Powered by <a href="https://github.com/emacs-china/EGO" target="_blank">EGO</a><br/>
      Themed with <a href="https://github.com/kuangdash/emacs_love" target="_blank">emacs_love</a>
        <a href="http://creativecommons.org/licenses/by-sa/3.0/" rel="license"><img src="https://licensebuttons.net/l/by-sa/3.0/88x31.png" style="border-width:0" alt="Creative Commons License" class="center"></a>
      <script type="text/javascript">document.getElementById("footerYear").innerHTML = (new Date()).getFullYear();</script>
    </p>
  </div>
    </div>

  </body>
</html>
