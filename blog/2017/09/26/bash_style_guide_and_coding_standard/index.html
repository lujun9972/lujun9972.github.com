<!DOCTYPE html>
<html lang="en">
<head>
  <title>Bash_Style_Guide_and_Coding_Standard - 暗无天日</title>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <meta name="author" content="lujun9972" />
  <meta name="keywords" content="编程之旅" />
  <style>
   #ds-thread #ds-reset .ds-comment-body p {color: #ffffff;}
   #disqus_thread a {color: #00ffff;}
  </style>
  <link rel="stylesheet" media="screen" href="../../../../../media/css/font.css" rel="stylesheet" type="text/css"/>
  <link rel="stylesheet" href="../../../../../media/css/main.css" type="text/css">
  <link rel="stylesheet" href="../../../../../media/css/org-src-fontify.css" type="text/css">
  <link rel="stylesheet" href="../../../../../media/css/kdComment.css" type="text/css">
  <script type="text/javascript"
          src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
  <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
</head>

  <body class="container">
<div>
  <header class="masthead">
    <h1 class="masthead-title"><a href="../../../../../">暗无天日</a></h1>
    <p>=============&gt;随便,谢谢</p>
    <nav class="site-nav">
      <div class="menu-icon">
      </div>
      <ul class="trigger">
              <li><a href="../../../../../years/">Years</a></li>
              <li><a href="../../../../../tags/">Tags</a></li>
              <li><a href="../../../../../about/">About</a></li>
              <li><a href="https://github.com/lujun9972/lujun9972.github.com.git">Github</a></li>
              <li><a href="../../../../../rss.xml">RSS</a></li>
      </ul>
    </nav>
    <form method="get" id="searchform" action="http://www.google.com/search">
        <input type="text" class="field" name="q" id="s" placeholder="Search">
        <input type="hidden" name="as_sitesearch" value="lujun9972.github.io">
    </form>
  </header>
</div>

<div>
<div class="post">
<h1 class="title">Bash_Style_Guide_and_Coding_Standard</h1>
<div id="table-of-contents">
<h2>&#30446;&#24405;</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orge266dd0">Length of line</a></li>
<li><a href="#orgc4ddf82">Indentation</a></li>
<li><a href="#org5fd856a">Comments</a>
<ul>
<li><a href="#org9a45ab9">Introductory comments in files</a></li>
<li><a href="#org2efc184">Line end comments</a></li>
<li><a href="#org645098b">Section comments</a></li>
<li><a href="#org9524452">Function comments</a></li>
<li><a href="#org80a8a0a">Commenting style</a></li>
</ul>
</li>
<li><a href="#orgb20d8c5">Variables and constants</a>
<ul>
<li><a href="#org94f2c70">Use of variables</a></li>
<li><a href="#org72d81c1">Use of constants</a></li>
</ul>
</li>
<li><a href="#org09f91e2">Success verification</a>
<ul>
<li><a href="#orge629d87">Command line options</a></li>
<li><a href="#orgd3f81ae">Variables, commands and functions</a></li>
<li><a href="#org9c07889">Execution and summary reports</a></li>
</ul>
</li>
<li><a href="#org515bedb">Files</a></li>
<li><a href="#org92d07c6">Command line options</a></li>
<li><a href="#org8ca7a73">Use of Shell Builtin Commands</a></li>
<li><a href="#org9bb72cb">Portability</a></li>
<li><a href="#org745e4dc">SUID/SGID-Scripts</a></li>
<li><a href="#org17cf03b">Testing</a>
<ul>
<li><a href="#org217ce57">Syntax check</a></li>
<li><a href="#orge189ba7">Test scope</a></li>
<li><a href="#org6fdeb53">Use of echo</a></li>
<li><a href="#org58a7b11">Testing using Bash options</a></li>
<li><a href="#orgf9326d6">The use of PS4</a></li>
<li><a href="#org3fffbac">Testing by means of trap</a></li>
<li><a href="#org486d0fc">The debugger bashdb</a></li>
</ul>
</li>
<li><a href="#org1632106">Further sources of information</a></li>
<li><a href="#orgcf87d28">References</a></li>
</ul>
</div>
</div>
<p>
通常来说, 脚本编程有快速编写,难以理解,即完即扔的特点,因此也无需有任何质量上的要求. 
但是这一观点忽略了一个事实,那就是在很多领域,脚本的生命周期都很长: 系统管理, 操作系统配置, 软件安装, 自动化的用户任务等等. 
很明显,这些脚本都需要维护,扩展并且文档化.
因此,脚本语言编程也应该满足生产语言编程一样的要求(能满足目的, 正确的实现方法, 能满足各种需求, 足够健壮, 易于维护)和标准. 
一个程序要维护,就需要让它的结构和功能能够很容易地被他人理解, 唯有这样别人才能在合理的时间内最其作出合适的修改. 
而如何满足这些要求很大程度上取决于所使用的编程风格. 
本指南的主要目的就是让你能写出易懂,可维护的代码.
</p>

<div id="outline-container-orge266dd0" class="outline-2">
<h2 id="orge266dd0">Length of line</h2>
<div class="outline-text-2" id="text-orge266dd0">
<p>
一行不能超过80个字符长度(包括注释). 这样在搜索的时候就不用左右拖动，而且在打印文件时也可以直接打印到平常宽度的纸上而不会导致代码行被截断或者换行.
为此，可能需要将一行命令或文本拆成多行来写.
</p>
</div>
</div>

<div id="outline-container-orgc4ddf82" class="outline-2">
<h2 id="orgc4ddf82">Indentation</h2>
<div class="outline-text-2" id="text-orgc4ddf82">
<p>
程序结构的缩进必须能体现程序逻辑层次.
一步缩进的步进通常与所用编辑器的制表符的步进一致. 通常为2,4或者8.
</p>
</div>
</div>

<div id="outline-container-org5fd856a" class="outline-2">
<h2 id="org5fd856a">Comments</h2>
<div class="outline-text-2" id="text-org5fd856a">
</div>
<div id="outline-container-org9a45ab9" class="outline-3">
<h3 id="org9a45ab9">Introductory comments in files</h3>
<div class="outline-text-3" id="text-org9a45ab9">
<p>
每个文件都需要有一份介绍性的说明,这份说明提供文件名称及其内容的相关信息.
</p>

<div class="org-src-container">
<pre class="src src-shell"><span class="org-comment-delimiter">#</span><span class="org-comment">!/bin/</span><span class="org-keyword">bash</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">===================================================================================</span>
<span class="org-comment-delimiter">#</span>
<span class="org-comment-delimiter">#         </span><span class="org-comment">FILE:  stale-links.sh</span>
<span class="org-comment-delimiter">#</span>
<span class="org-comment-delimiter">#        </span><span class="org-comment">USAGE:  stale-links.sh [-d] [-l] [-oD logfile] [-h] [starting directories]</span>
<span class="org-comment-delimiter">#</span>
<span class="org-comment-delimiter">#  </span><span class="org-comment">DESCRIPTION:  List and/or delete all stale links in directory trees.</span>
<span class="org-comment-delimiter">#                </span><span class="org-comment">The default starting directory is the current directory.</span>
<span class="org-comment-delimiter">#                </span><span class="org-comment">Don&#8217;t descend directories on other filesystems.</span>
<span class="org-comment-delimiter">#</span>
<span class="org-comment-delimiter">#      </span><span class="org-comment">OPTIONS:  see function &#8217;usage&#8217; below</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">REQUIREMENTS:  ---</span>
<span class="org-comment-delimiter">#         </span><span class="org-comment">BUGS:  ---</span>
<span class="org-comment-delimiter">#        </span><span class="org-comment">NOTES:  ---</span>
<span class="org-comment-delimiter">#       </span><span class="org-comment">AUTHOR:  Dr.-Ing. Fritz Mehner (fgm), mehner.fritz@fh-swf.de</span>
<span class="org-comment-delimiter">#      </span><span class="org-comment">COMPANY:  FH S&#252;dwestfalen, Iserlohn</span>
<span class="org-comment-delimiter">#      </span><span class="org-comment">VERSION:  1.3</span>
<span class="org-comment-delimiter">#      </span><span class="org-comment">CREATED:  12.05.2002 - 12:36:50</span>
<span class="org-comment-delimiter">#     </span><span class="org-comment">REVISION:  20.09.2004</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">===================================================================================</span>
</pre>
</div>

<p>
如有必要,也可以加上其他信息(比如. 版权,项目分配等信息)
</p>
</div>
</div>

<div id="outline-container-org2efc184" class="outline-3">
<h3 id="org2efc184">Line end comments</h3>
<div class="outline-text-3" id="text-org2efc184">
<p>
单行注释与代码在统一行. 在注释符 <code>#</code> 后应该跟一个空格,这样可以很容易地区分出单词的头部.
</p>

<div class="org-src-container">
<pre class="src src-shell"><span class="org-variable-name">found</span>=0   <span class="org-comment-delimiter"># </span><span class="org-comment">count links found</span>
<span class="org-variable-name">deleted</span>=0 <span class="org-comment-delimiter"># </span><span class="org-comment">count links deleted</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org645098b" class="outline-3">
<h3 id="org645098b">Section comments</h3>
<div class="outline-text-3" id="text-org645098b">
<p>
如果多行逻辑上构成一个段,那么就应该为段添上段注释.
</p>
<div class="org-src-container">
<pre class="src src-shell"><span class="org-comment-delimiter">#</span><span class="org-comment">----------------------------------------------------------------------</span>
<span class="org-comment-delimiter">#  </span><span class="org-comment">delete links, if demanded write logfile</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">----------------------------------------------------------------------</span>
<span class="org-keyword">if</span>
    [ <span class="org-string">"$action"</span> == &#8217;d&#8217; ] ;
<span class="org-keyword">then</span>
    rm --force <span class="org-string">"$file"</span> &amp;&amp; ((deleted++))
    <span class="org-builtin">echo</span> <span class="org-string">"removed link :  &#8217;$file&#8217;"</span>
    [ <span class="org-string">"$logfile"</span> != <span class="org-string">""</span> ] &amp;&amp; <span class="org-builtin">echo</span> <span class="org-string">"$file"</span> &gt;&gt; <span class="org-string">"$logfile"</span>
<span class="org-keyword">fi</span>
</pre>
</div>
<p>
段注释应该与后面代码的缩进位置对其.
</p>
</div>
</div>

<div id="outline-container-org9524452" class="outline-3">
<h3 id="org9524452">Function comments</h3>
<div class="outline-text-3" id="text-org9524452">
<p>
每个函数都应该有一个介绍性的注释. 其中包括函数名，函数的简单说明以及函数参数的说明(如果有的话).
如果后续对该函数有所修改的话，应该把修改人和修改日期也加进来.
</p>
<div class="org-src-container">
<pre class="src src-shell"><span class="org-comment-delimiter">#</span><span class="org-comment">===  FUNCTION  ================================================================</span>
<span class="org-comment-delimiter">#         </span><span class="org-comment">NAME:  usage</span>
<span class="org-comment-delimiter">#  </span><span class="org-comment">DESCRIPTION:  Display usage information for this script.</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">PARAMETER  1:  ---</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">===============================================================================</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org80a8a0a" class="outline-3">
<h3 id="org80a8a0a">Commenting style</h3>
<div class="outline-text-3" id="text-org80a8a0a">
<p>
注释风格应该遵循如下原则:
</p>
<blockquote>
<p>
简短、简洁、准确
</p>
</blockquote>
<p>
注释的目的是便于理解. 只有在特殊情况下才会用注释来描述代码结构或其中用到的一些小技巧:
</p>
<blockquote>
<p>
注释应该描述代码的目的.
</p>
</blockquote>
<p>
例如，下面这段注释就没啥用，它只是重复前面这一行的代码而已:
</p>
<div class="org-src-container">
<pre class="src src-shell">[ <span class="org-string">"$logfile"</span> != <span class="org-string">""</span> ] &amp;&amp; $(&gt; <span class="org-string">"$logfile"</span>) <span class="org-comment-delimiter"># </span><span class="org-comment">variable $logfile empty ?</span>
</pre>
</div>
<p>
而下面这句注释则简洁第描述了代码的意图:
</p>
<div class="org-src-container">
<pre class="src src-shell">[ <span class="org-string">"$logfile"</span> != <span class="org-string">""</span> ] &amp;&amp; $(&gt; <span class="org-string">"$logfile"</span>) <span class="org-comment-delimiter"># </span><span class="org-comment">empty an existing logfile</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgb20d8c5" class="outline-2">
<h2 id="orgb20d8c5">Variables and constants</h2>
<div class="outline-text-2" id="text-orgb20d8c5">
</div>
<div id="outline-container-org94f2c70" class="outline-3">
<h3 id="org94f2c70">Use of variables</h3>
<div class="outline-text-3" id="text-org94f2c70">
<p>
变量名应该是有意义的，需要能够望名知意(比如inputfile). 
变量名中前31个字符不能重复. 
如果名字特别的长，可以用下划线分割命名中的各个部分以提高可读性.
</p>

<p>
若变量名确实无法做到望名知意, 那么第一次使用该变量时必须在注释中写清楚该变量的意义和使用方法.
</p>
</div>
</div>

<div id="outline-container-org72d81c1" class="outline-3">
<h3 id="org72d81c1">Use of constants</h3>
<div class="outline-text-3" id="text-org72d81c1">
<p>
Principally, the following applies for all programming languages: <b>No constants must be included in the program text !</b>
In particular numeral constants do not have another immediate meaning apart from their value. 
The meaning of the value will only become clear in the specific text context.
In case of value changes of multiple occurring constants an automatic replacement in the editor is not
possible, because the value might have been used in different meanings. 
Such program texts therefore are difficult to maintain. 
For the handling of constants - and of course also constant texts (such as file names) - the following recommendations apply:
</p>

<ul class="org-ul">
<li><p>
Global constants and texts.
</p>

<p>
Global constants and texts (e.g. file names, replacement values for call parameters and the like) are collected in a separate section at the beginning of the script and commented individually, if the number is not too high.
</p>

<div class="org-src-container">
<pre class="src src-shell"><span class="org-variable-name">startdirs</span>=${<span class="org-variable-name">@</span>:-.} <span class="org-comment-delimiter"># </span><span class="org-comment">default start directory: current directory</span>
<span class="org-variable-name">action</span>=${<span class="org-variable-name">action</span>:-l} <span class="org-comment-delimiter"># </span><span class="org-comment">default action is -l (list)</span>
</pre>
</div></li>

<li><p>
大段文本.
引用大段的文本 (例如. 描述性的文字, 对调用选项的说明文档) 时可以使用 <code>here</code> documents.
</p>

<div class="org-src-container">
<pre class="src src-shell">cat
&lt;&lt;- EOT
<span class="org-sh-heredoc">List and/or delete all stale links in directory trees.</span>
<span class="org-sh-heredoc">usage : $0 [-d] [-oD logfile] [-l] [-h] [starting directories]</span>
<span class="org-sh-heredoc">-d    delete stale links</span>
<span class="org-sh-heredoc">-l    list stale links (default)</span>
<span class="org-sh-heredoc">-o    write stale links found into logfile</span>
<span class="org-sh-heredoc">-D    delete stale links listed in logfile</span>
<span class="org-sh-heredoc">-h    display this message</span>
<span class="org-sh-heredoc">EOT</span>
</pre>
</div></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org09f91e2" class="outline-2">
<h2 id="org09f91e2">Success verification</h2>
<div class="outline-text-2" id="text-org09f91e2">
</div>
<div id="outline-container-orge629d87" class="outline-3">
<h3 id="orge629d87">Command line options</h3>
<div class="outline-text-3" id="text-orge629d87">
<p>
若对参数个数有要求，那么就应该在脚本中对参数个数进行校验. 当调用参数有误时，脚本可以终止运行并返回错误信息或/并说明需要调用的参数是什么.
</p>

<p>
参数的值也应该校验有效性. 例如，当传递一个文件为参数值时，在读该文件之前应该先测试一下文件是否存在且具有可读权限(例如. 使用 <code>[ -r $inputfile ]</code> 来进行测试).
</p>
</div>
</div>

<div id="outline-container-orgd3f81ae" class="outline-3">
<h3 id="orgd3f81ae">Variables, commands and functions</h3>
<div class="outline-text-3" id="text-orgd3f81ae">
<p>
变量在使用前必须先为之设置一个有意义的初始值. 像这样:
</p>
<div class="org-src-container">
<pre class="src src-shell">[ -e <span class="org-string">"$1"</span> ] &amp;&amp; expand --tabs=$<span class="org-variable-name">number</span> <span class="org-string">"$1"</span> &gt; <span class="org-string">"$1.expand"</span>
</pre>
</div>
<p>
它会先检查参数 <code>$1</code> 所代表的文件是否存在. 
逻辑表达式会在左子句就能确定整个表达式结果的情况下终止对右子句的运行（即所谓的短路执行）,因此当前一个条件为假时，就不会进行进一步的处理.
最后命令的返回值会存储在变量 <code>$?</code> 中，可以将之运用于后续的处理控制中:
</p>

<div class="org-src-container">
<pre class="src src-shell">mkdir <span class="org-string">"$new_directory"</span>  2&gt; /dev/null
<span class="org-keyword">if</span>
    [ $<span class="org-variable-name">?</span> -ne 0 ]
<span class="org-keyword">then</span>
    ...
<span class="org-keyword">fi</span>
</pre>
</div>

<p>
在本例中，若无法创建目录，则 <code>mkdir</code> 的返回值就不会是0. 另外,变量 <code>$?</code> 还可以用于检查函数的返回值.
</p>
</div>
</div>

<div id="outline-container-org9c07889" class="outline-3">
<h3 id="org9c07889">Execution and summary reports</h3>
<div class="outline-text-3" id="text-org9c07889">
<p>
交互式应用的脚本应该要显示一份汇总报告. 从这份报告中可以判断脚本是否运行正常，还能用于检查结果的可信度,例如.
</p>
<div class="org-src-container">
<pre class="src src-shell">mn4:~/bin <span class="org-comment-delimiter"># </span><span class="org-comment">./stale-links -o stale-links.log /opt</span>
</pre>
</div>

<pre class="example">
... searching stale links ...
1. stale link:  ’/opt/dir link 23’
2. stale link:  ’/opt/file link 71’
3. stale link:  ’/opt/file link 7’
      stale links   found : 3
      stale links deleted : 0
      logfile: ’stale-links.log’
</pre>

<p>
有关细节的执行报告存在日志文件中. 这些日志文件中的内容也需要有助于诊断失败的原因.
</p>
</div>
</div>
</div>

<div id="outline-container-org515bedb" class="outline-2">
<h2 id="org515bedb">Files</h2>
<div class="outline-text-2" id="text-org515bedb">
<ul class="org-ul">
<li><p>
文件名
</p>

<p>
主文件名应该是有意义的. 文件扩展名则应该尽可能的反应出文件的内容(比如.dat , .log , .lst , .tmp 等等.).
</p></li>

<li><p>
临时文件
</p>

<p>
临时文件一般用于存放中间结果，并且这些文件一般统一放在 <code>tmp</code> 目录中，用完即删. 
可以使用 <code>mktemp</code> 来生成随机的文件名(参见 man 1 mktemp):
</p>

<div class="org-src-container">
<pre class="src src-shell"><span class="org-comment-delimiter">#</span><span class="org-comment">-------------------------------------------------------------------------------</span>
<span class="org-comment-delimiter">#  </span><span class="org-comment">Cleanup temporary file in case of keyboard interrupt or termination signal.</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">-------------------------------------------------------------------------------</span>
<span class="org-keyword">function</span> <span class="org-function-name">cleanup_temp</span> {
    [ -e $<span class="org-variable-name">tmpfile</span> ] &amp;&amp; rm --force $<span class="org-variable-name">tmpfile</span>
    <span class="org-keyword">exit</span> 0
}

<span class="org-keyword">trap</span> cleanup_temp  SIGHUP SIGINT SIGPIPE SIGTERM

<span class="org-variable-name">tmpfile</span>=$(<span class="org-sh-quoted-exec">mktemp</span>) || {<span class="org-builtin">echo</span> <span class="org-string">"$0: creation of temporary file failed!"</span>; <span class="org-keyword">exit</span> 1; }

<span class="org-comment-delimiter"># </span><span class="org-comment">... use tmpfile ...</span>

rm --force $<span class="org-variable-name">tmpfile</span>
</pre>
</div>

<p>
若触发了 <code>trap</code> 语句中指定的其中一种信号，在终止脚本执行的同时，还会调用函数 <code>cleanup_temp</code>. 然后该函数就会清除临时文件了.
只有当脚本被 <code>SIGKILL</code> 信号终止运行的情况下才会保留临时文件，因为该信号无法被捕获.
</p></li>

<li><p>
备份文件
</p>

<p>
如果需要保留多个旧的文件副本，那么建议使用时间来进行区分: 
</p>
<div class="org-src-container">
<pre class="src src-shell"><span class="org-variable-name">timestamp</span>=$(<span class="org-sh-quoted-exec">date</span> +<span class="org-string">"%Y%m%d-%H%M%S"</span>) <span class="org-comment-delimiter"># </span><span class="org-comment">generate timestamp : YYYYMMDD-hhmmss</span>
mv logfile logfile.$<span class="org-variable-name">timestamp</span>
</pre>
</div>
<p>
文件 <code>logfile</code> 就会被重命名为类似 <code>logfile.20041210-173116</code> 这样.
文件名中的时间和日期是以逆序的形式来组织的(The components of date and time are organized in reversed order??什么意思). 
以这种方式命名的文件在目录中的排列会按照时间的自然顺序来排列的.
</p></li>

<li><p>
中间结果
</p>

<p>
通过使用 <code>tee</code> 命令,可以将中间结果同时写入文件和标准输出中. 
这样一来，你就可以使用中间结果来控制处理流程或者用于测试脚本:
</p>
<div class="org-src-container">
<pre class="src src-shell"><span class="org-builtin">echo</span> $<span class="org-variable-name">output_string</span> | tee --append  $<span class="org-variable-name">TMPFILE</span>
</pre>
</div></li>
</ul>
</div>
</div>
<div id="outline-container-org92d07c6" class="outline-2">
<h2 id="org92d07c6">Command line options</h2>
<div class="outline-text-2" id="text-org92d07c6">
<ul class="org-ul">
<li><p>
调用外部程序
</p>

<p>
在脚本中调用系统程序时，应该尽可能的使用 <code>GNU风格的命令行参数(参数的完整形式)</code>. 
GNU风格的参数一般都很能表达出参数的意义，因此有助于理解脚本做的事情.
在下面的useradd命令中，我们使用了 <code>-c</code> , <code>-p</code> 和 <code>-m</code> 的完整形式:
</p>
<div class="org-src-container">
<pre class="src src-shell">useradd --comment <span class="org-string">"$full_name"</span> <span class="org-sh-escaped-newline">\</span>
        --password <span class="org-string">"$encrypted_password"</span>  <span class="org-sh-escaped-newline">\</span>
        --create-home <span class="org-sh-escaped-newline">\</span>
        $<span class="org-variable-name">loginname</span>
</pre>
</div>
<p>
通过断行符(行末尾的 <code>\</code> 字符) 可以避免写出太长的一行代码. 
参数前的缩进则增加了可读性.
</p></li>

<li><p>
自己脚本的命令行参数
</p>

<p>
自己设计参数字母时 (参数的缩写形式) 应该尽可能选择直观的或者普遍使用的字母 (例如. <code>-f</code> 用于指定文件, 或者 <code>-d</code>, 用于是否输出额外的信息(debug)). 
对于参数的完整形式, 建议参照 <code>[[http://www.gnu.org/prep/standards.html][GNU Coding Standards]]</code> 
</p></li>
</ul>
</div>
</div>

<div id="outline-container-org8ca7a73" class="outline-2">
<h2 id="org8ca7a73">Use of Shell Builtin Commands</h2>
<div class="outline-text-2" id="text-org8ca7a73">
<p>
尽可能使用shell内建命令而不是外部程序. 因为每次调用 <code>sed</code> , <code>awk</code> , <code>cut</code> 等外部命令都会产生一个新的进程. 
若在循环语句中反复调用会显著地增加运行所需要的时间. 
在下面的例子中，我们使用shell参数扩展机制来获取文件路径中的文件名和目录路径:
</p>

<div class="org-src-container">
<pre class="src src-shell"><span class="org-keyword">for</span>
    pathname<span class="org-keyword"> in</span> $(<span class="org-sh-quoted-exec">find</span> $<span class="org-variable-name">search</span> - type f -name <span class="org-string">"*"</span> -print)
<span class="org-keyword">do</span>
    <span class="org-variable-name">basename</span>=${<span class="org-variable-name">pathname</span>##*/} <span class="org-comment-delimiter"># </span><span class="org-comment">replaces basename(1)</span>
    <span class="org-variable-name">dirname</span>=${<span class="org-variable-name">pathname</span>%/*} <span class="org-comment-delimiter"># </span><span class="org-comment">replaces dirname(1)</span>
    ...
<span class="org-keyword">done</span>
</pre>
</div>

<p>
可以使用比较符 =~ 来对字符串进行模式匹配.
</p>
<div class="org-src-container">
<pre class="src src-shell"><span class="org-variable-name">metacharacter</span>=&#8217;[~&amp;|]&#8217;
<span class="org-keyword">if</span> [[ <span class="org-string">"$pathname"</span> =~ $<span class="org-variable-name">metacharacter</span> ]]
<span class="org-keyword">then</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">treat metacharacter</span>
<span class="org-keyword">fi</span>
</pre>
</div>

<p>
这种模式匹配兼容POSIX regular expressions (regex(7)).
</p>
</div>
</div>

<div id="outline-container-org9bb72cb" class="outline-2">
<h2 id="org9bb72cb">Portability</h2>
<div class="outline-text-2" id="text-org9bb72cb">
<p>
使用 <code>dash-shell</code> (Debian Almquist Shell) 通常能够保证脚本满足 POSIX 兼容性([POS13]). 
你也可以在 [Bas13] 中找到那些不可移植的结构及其对应的可移植的替代. 
</p>
</div>
</div>

<div id="outline-container-org745e4dc" class="outline-2">
<h2 id="org745e4dc">SUID/SGID-Scripts</h2>
<div class="outline-text-2" id="text-org745e4dc">
<p>
shell脚本受到用户输入，进程环境，初始化文件，所使用的系统工具等等各方面的影响. 
Shell语言不适合用来写与安全有关的脚本，因为上面所有这些因素 (当然还有其他没列出来的) 都可能用于攻击你的系统. 
Utilities may be vulnerable themselves.
要小心运行那些带 SUID/SGID 标志位的脚本 [GSS03 , Whe03].
下面仅列几条特别重要的预防措施:
</p>

<ul class="org-ul">
<li>Execute the script from a directory where it can not be changed unauthorized.</li>
<li>检查环境变量 <code>BASH_ENV</code> 是否为空.</li>
<li>设置 <code>umask</code> 为 077.</li>
<li>重置环境变量 <code>PATH</code> and <code>IFS</code> 为一个安全的值.</li>
<li>切换到一个安全的工作目录并验证是否成功切换过去了.</li>
<li>使用绝对路径来调用系统工具及数据文件.</li>
<li>每次调用系统工具都要检查返回码.</li>
<li>使用 <code>--</code> 来标识选项参数的结束.</li>
<li>将所有的命令行参数都引用起来 (例如. <code>"$1"</code>).</li>
<li>检查用户输入中是否包含了shell metacharacters(特殊意义的字符)或者其他非法字符.</li>
<li>检查用户提供的路径名 (绝对路径/相对路径).</li>
<li>开启shell选项 <code>noclobber</code> 以防止覆盖已有文件.</li>
<li>使用 <code>mktemp</code> 创建临时文件(参见 section 6)</li>
</ul>
</div>
</div>

<div id="outline-container-org17cf03b" class="outline-2">
<h2 id="org17cf03b">Testing</h2>
<div class="outline-text-2" id="text-org17cf03b">
</div>
<div id="outline-container-org217ce57" class="outline-3">
<h3 id="org217ce57">Syntax check</h3>
<div class="outline-text-3" id="text-org217ce57">
<p>
使用 <code>Bash</code> 加上 <code>-n</code> 参数来执行脚本, 则只会读取脚本命令而不会真正去执行他:
</p>
<div class="org-src-container">
<pre class="src src-shell">bash  -n  remove_ps.sh
</pre>
</div>

<p>
这种方法可以用于进行语法检查. 不过这种方法只能检查出致命错误.  
比如它无法检测出关键字不全的情况 (比如 <code>echo</code> 错写成了 <code>cho</code>), 因为很可能有一个同名的程序或者函数可以被调用.
</p>
</div>
</div>

<div id="outline-container-orge189ba7" class="outline-3">
<h3 id="orge189ba7">Test scope</h3>
<div class="outline-text-3" id="text-orge189ba7">
<p>
在开发阶段就有必要准备好测试环境,包括准备测试文件或者测试数据. 不过这些测试数据不需要太过复杂. 
这会增加脚本开发的速度，并且减少无意中改动重要数据的风险.
</p>
</div>
</div>

<div id="outline-container-org6fdeb53" class="outline-3">
<h3 id="org6fdeb53">Use of echo</h3>
<div class="outline-text-3" id="text-org6fdeb53">
<p>
会影响系统变更的命令(比如删除或者重命名文件)在测试时，应该先用 <code>echo</code> 将之输出并进行检查.  
这点很重要，尤其当处理对象中包含通配符或者递归目录进行处理的时候. 
</p>

<p>
下面代码
</p>
<div class="org-src-container">
<pre class="src src-shell"><span class="org-keyword">for</span> file<span class="org-keyword"> in</span> *.sh
<span class="org-keyword">do</span>
    rm  <span class="org-string">"$file"</span>
<span class="org-keyword">done</span>
</pre>
</div>
<p>
会立即删除目录中所有以 <code>.sh</code> 为后缀名的文件.  
</p>

<p>
在删除命令前加上 <code>echo</code> 命令, 就会输出要执行的删除命令了.
</p>

<div class="org-src-container">
<pre class="src src-shell"><span class="org-builtin">echo</span> <span class="org-string">"rm  \"$file\""</span>
</pre>
</div>

<p>
在确定无误后，再把 <code>echo</code> 删除.
</p>
</div>
</div>

<div id="outline-container-org58a7b11" class="outline-3">
<h3 id="org58a7b11">Testing using Bash options</h3>
<div class="outline-text-3" id="text-org58a7b11">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Command line option</th>
<th scope="col" class="org-left">set -o Option</th>
<th scope="col" class="org-left">Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">-n</td>
<td class="org-left">noexec</td>
<td class="org-left">Commands are not executed, only syntax check (see 11.1)</td>
</tr>

<tr>
<td class="org-left">-v</td>
<td class="org-left">verbose</td>
<td class="org-left">Outputs the lines of a script before execution.</td>
</tr>

<tr>
<td class="org-left">-x</td>
<td class="org-left">xtracd</td>
<td class="org-left">Outputs the lines of a script after replacements.</td>
</tr>
</tbody>
</table>

<p>
下面几行代码
</p>
<div class="org-src-container">
<pre class="src src-shell"><span class="org-variable-name">TMPFILE</span>=$( mktemp /tmp/example.XXXXXXXXXX ) || <span class="org-keyword">exit</span> 1
<span class="org-builtin">echo</span> <span class="org-string">"program output"</span> &gt;&gt; $<span class="org-variable-name">TMPFILE</span>
rm --force $<span class="org-variable-name">TMPFILE</span>
</pre>
</div>
<p>
若执行时加上 <code>-xv</code> 选项
</p>
<div class="org-src-container">
<pre class="src src-shell">bash -xv ./tempfile.sh
</pre>
</div>
<p>
会有如下输出:
</p>
<pre class="example">
TMPFILE=$( mktemp /tmp/example.XXXXXXXXXX ) || exit 1
mktemp /tmp/example.XXXXXXXXXX
++ mktemp /tmp/example.XXXXXXXXXX
+ TMPFILE=/tmp/example.AVkuGd6796
echo "program output" &gt;&gt; $TMPFILE
+ echo ’program output’
rm --force $TMPFILE
+ rm --force /tmp/example.AVkuGd6796
</pre>

<p>
以 <code>+</code> 开头的行是由 <code>-x</code> 选项输出的. 
加号的数量表示了变量替换的层级. 
</p>

<p>
这些选项可以在脚本的任意位置进行重新设置: 
</p>
<div class="org-src-container">
<pre class="src src-shell"><span class="org-builtin">set</span> -o xtrace <span class="org-comment-delimiter"># </span><span class="org-comment">--- xtrace on ---</span>
<span class="org-keyword">for</span>
    file<span class="org-keyword"> in</span> $<span class="org-variable-name">list</span>
<span class="org-keyword">do</span>
    rm  <span class="org-string">"$file"</span>
<span class="org-keyword">done</span>
<span class="org-builtin">set</span> +o xtrace <span class="org-comment-delimiter"># </span><span class="org-comment">--- xtrace off ---</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf9326d6" class="outline-3">
<h3 id="orgf9326d6">The use of PS4</h3>
<div class="outline-text-3" id="text-orgf9326d6">
<p>
上一小节中， 由 <code>-x</code> 生成的前缀是由变量 <code>PS4</code> 所决定的,默认值为 <code>’+’</code>. 
在需要的时候，会重复字符串中的第一个字符以标识调用深度. 
可以通过修改变量 <code>PS4</code> 的值来获得更多的信息. 
</p>

<p>
例如:
</p>
<div class="org-src-container">
<pre class="src src-shell"><span class="org-comment-delimiter"># </span><span class="org-comment">PS4 : position, line number, function name</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">The following line avoids error messages due to an unset FUNCNAME[0] :</span>
<span class="org-builtin">set</span> +o nounset
<span class="org-comment-delimiter"># </span><span class="org-comment">Treat unset variables not as an error</span>
<span class="org-variable-name">PS4</span>=<span class="org-string">'+|${BASH_SOURCE##*/} ${LINENO}${FUNCNAME[0]:+ ${FUNCNAME[0]}}|  '</span>
</pre>
</div>
<p>
下面是一个输出的例子:
</p>
<pre class="example">
+| test.sh 41| for n in ’{1..4}’
+| test.sh 42|  function1
+| test.sh 30 function1| echo ’-- in function1 --’
-- in function1 --
+| test.sh 31 function1|  function2
+| test.sh 37 function2| echo ’-- in function2 --’
-- in function2 --
+| test.sh 32 function1| echo ’-- in function1 again --’
-- in function1 again --
</pre>
<p>
提示符 <code>PS4</code> 还能用来输出时间戳.
</p>
<div class="org-src-container">
<pre class="src src-shell"><span class="org-comment-delimiter"># </span><span class="org-comment">PS4 : timestamp; the current time in 24-hour HH:MM:SS format</span>
<span class="org-variable-name">PS4</span>=&#8217;+[\t]  &#8217;
<span class="org-comment-delimiter"># </span><span class="org-comment">PS4 : timestamp; &#8217;seconds.nanoseconds&#8217; since 1970-01-01 00:00:00 UT</span>
<span class="org-variable-name">PS4</span>=&#8217;+[$(<span class="org-sh-quoted-exec">date</span> <span class="org-string">"+%s.%N"</span>)]  &#8217;
</pre>
</div>
</div>
</div>

<div id="outline-container-org3fffbac" class="outline-3">
<h3 id="org3fffbac">Testing by means of trap</h3>
<div class="outline-text-3" id="text-org3fffbac">
<p>
<code>Bash</code> 提供了两种仿真信号,可以为这两种仿真信号设置各自的处理行为.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">Pseudo signal</td>
<td class="org-left">Trigger</td>
</tr>

<tr>
<td class="org-left">DEBUG</td>
<td class="org-left">The shell has executed a command.</td>
</tr>

<tr>
<td class="org-left">EXIT</td>
<td class="org-left">The shell terminates the script.</td>
</tr>
</tbody>
</table>


<p>
图1 演示了 <code>trap</code> 命令捕获这两个仿真信号的例子. 
图二为输出.
</p>

<p>
Figure 1: Example for the use of pseudo signals and <code>trap</code>
</p>
<div class="org-src-container">
<pre class="src src-shell"><span class="org-comment-delimiter">#</span><span class="org-comment">===  FUNCTION  ================================================================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">NAME:  dbgtrap</span>
<span class="org-comment-delimiter">#  </span><span class="org-comment">DESCRIPTION:  monitor the variable &#8217;act_dir&#8217;</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">===============================================================================</span>
<span class="org-keyword">function</span> <span class="org-function-name">dbgtrap</span> ()
{
    <span class="org-builtin">echo</span> <span class="org-string">"act_dir = \"$act_dir\""</span>
}    <span class="org-comment-delimiter"># </span><span class="org-comment">----------  end of function dbgtrap  ----------</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">-----------------------------------------------------------------------</span>
<span class="org-comment-delimiter">#  </span><span class="org-comment">traps</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">-----------------------------------------------------------------------</span>
<span class="org-keyword">trap</span> &#8217; echo <span class="org-string">"On exit : act_dir = \"$act_dir\""</span>&#8217;  EXIT
<span class="org-keyword">trap</span> dbgtrap DEBUG
<span class="org-comment-delimiter">#</span><span class="org-comment">-----------------------------------------------------------------------</span>
<span class="org-comment-delimiter">#  </span><span class="org-comment">monitoring ...</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">-----------------------------------------------------------------------</span>
<span class="org-variable-name">act_dir</span>=$(<span class="org-sh-quoted-exec">pwd</span>)
<span class="org-builtin">cd</span> ..
<span class="org-variable-name">act_dir</span>=$(<span class="org-sh-quoted-exec">pwd</span>)
<span class="org-builtin">cd</span> $<span class="org-variable-name">HOME</span>
</pre>
</div>


<p>
Figure 2: Output of script in figure 1
</p>
<div class="org-src-container">
<pre class="src src-shell">act_dir = <span class="org-string">""</span>
act_dir = <span class="org-string">"/home/mehner"</span>
act_dir = <span class="org-string">"/home/mehner"</span>
act_dir = <span class="org-string">"/home"</span>
act_dir = <span class="org-string">"/home"</span>
act_dir = <span class="org-string">"/home"</span>
On exit : act_dir = <span class="org-string">"/home"</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org486d0fc" class="outline-3">
<h3 id="org486d0fc">The debugger bashdb</h3>
<div class="outline-text-3" id="text-org486d0fc">
<p>
调试器 <code>bashdb</code> 从3.0版本开始支持 <code>Bash</code>. 可以很容易地通过源代码来安装. 它还能够很好地与图形调试器前端 <code>ddd</code> 配合使用.
</p>
</div>
</div>
</div>

<div id="outline-container-org1632106" class="outline-2">
<h2 id="org1632106">Further sources of information</h2>
<div class="outline-text-2" id="text-org1632106">
<p>
已安装的shell和系统工具的手册是我们最重要的信息来源.
</p>

<p>
你可以从 [Tea13] 和 [Ste13] 这两个地方找到其他的风格指引. 有时也会有一些关于shell变成的科技文章发表.
另外市面上也已经有了许多关于shell变成的书籍可以阅读.
如果对系统编程和安全方面有疑问,[GSS03 , Whe03]是很好的入手资料.
网上也有很多关注于平台安全事物和新开发技术的网站.
</p>
</div>
</div>

<div id="outline-container-orgcf87d28" class="outline-2">
<h2 id="orgcf87d28">References</h2>
<div class="outline-text-2" id="text-orgcf87d28">
<p>
[Bas13] The Bash-Hackers Wiki. <a href="http://wiki.bash-hackers.org/scripting/nonportable">http://wiki.bash-hackers.org/scripting/nonportable</a> , 2013
[Bur04] Burtch , Ken O.: Linux Shell Scripting with Bash (Developer's Library). Sams, 2004.  -ISBN 0672326426. - As PDF freely available from the publisher.
[Coo12] Cooper , Mendel: Advanced Bash-Scripting Guide. <a href="http://www.tldp.org/LDP/abs/html/">http://www.tldp.org/LDP/abs/html/</a>, 2012.   Comprehensive tutorial with many examples, available in several formats. Well suited for additional online help and as reference work.
[FSF10] FSF : Bash Reference Manual . Free Software Foundation : <a href="http://www.gnu.org">http://www.gnu.org</a>, 12 2010.  - Bash shell, version 4.2. The official manual.
[GSS03] Garfinkel , Simson ; Spafford , Gene ; Schwartz , Alan: Practical  Unix  &amp;  Internet Security (3rd Edition) . O'Reilly Media, 2003.  -  ISBN 0596003234
[Lhu13] Lhunath : BashGuide . <a href="http://mywiki.wooledge.org/BashGuide">http://mywiki.wooledge.org/BashGuide</a>, 2013 
[NR05] Newham , Cameron ; Rosenblatt , Bill: Learning the bash Shell (3rd Edition) . O'Reilly Media, 2005.  -  ISBN 0596009658.  -  Textbook; covers the features of Bash Version 3.0.
[POS13] The Open Group Base Specifications Issue 7. <a href="http://pubs.opengroup.org/onlinepubs/9699919799/">http://pubs.opengroup.org/onlinepubs/9699919799/</a>, 2013 
[Ste13] Steven , Heiner: Heiner's SHELLdorado . <a href="http://shelldorado.com/goodcoding">http://shelldorado.com/goodcoding</a>, 2013
[Tea13] Team , Inquisitor: Coding style guidelines: Shell script. <a href="http://www.inquisitor.ru/doc/coding-style-shell.html">http://www.inquisitor.ru/doc/coding-style-shell.html</a>, 2013 
[Whe03] Wheeler , David A.: Secure Programming for Linux and Unix HOWTO . March 2003.  - Version v3.010 
</p>
</div>
</div>

</div>
</div>
<div>
  <div class="post-meta">
    <span title="post date" class="post-info">2017-09-26</span>
    <span title="last modification date" class="post-info">2017-10-25</span>
    <span title="tags" class="post-info"><a href="../../../../../tags/编程之旅">编程之旅</a></span>
    <span title="author" class="post-info">lujun9972</span>
  </div>
  <script src="../../../../../media/js/jquery-2.1.3.min.js"></script>
  <script src="../../../../../media/js/md5.min.js"></script>
  <section>
      <div id="gitalk-container"></div>
      <script type="text/javascript">
       var gitalk = new Gitalk({
           clientID: 'fdcb5d9da3f4acb4862c',
           clientSecret: 'dd0a16312a206782cb7669dcec5e96874ab48170',
           repo: 'lujun9972.github.com',
           owner: 'lujun9972',
           admin: ['lujun9972'],
           id: md5(location.pathname),      // Ensure uniqueness and length less than 50
           distractionFreeMode: false  // Facebook-like distraction free mode
       })
       gitalk.render('gitalk-container')
      </script>
  </section>
  <script src="../../../../../media/js/kdComment.js"></script>
      <script>
       var _hmt = _hmt || [];
       (function() {
           var hm = document.createElement("script");
           hm.src = "https://hm.baidu.com/hm.js?7bac4fd0247f69c27887e0d4e3aee41e";
           var s = document.getElementsByTagName("script")[0]; 
           s.parentNode.insertBefore(hm, s);
       })();
      </script>
  <div class="footer">
    <p>Generated by <a href="http://www.gnu.org/software/emacs/">Emacs</a> 27.x(<a href="http://orgmode.org">Org mode</a> 9.x)</p>
    <p>
      Copyright &copy; 2014 - <span id="footerYear"></span> <a href="mailto:travis &lt;at&gt; travis-job-741fed94-a850-4ec5-8cd7-96177af926a4">lujun9972</a>
      &nbsp;&nbsp;-&nbsp;&nbsp;
      Powered by <a href="https://github.com/emacs-china/EGO" target="_blank">EGO</a><br/>
      Themed with <a href="https://github.com/kuangdash/emacs_love" target="_blank">emacs_love</a>
        <a href="http://creativecommons.org/licenses/by-sa/3.0/" rel="license"><img src="http://i.creativecommons.org/l/by-sa/3.0/88x31.png" style="border-width:0" alt="Creative Commons License" class="center"></a>
      <script type="text/javascript">document.getElementById("footerYear").innerHTML = (new Date()).getFullYear();</script>
    </p>
  </div>
    </div>

  </body>
</html>
