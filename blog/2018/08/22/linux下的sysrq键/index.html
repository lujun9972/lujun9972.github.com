<!DOCTYPE html>
<html lang="en">
<head>
  <title>linux下的SysRq键 - 暗无天日</title>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <meta name="author" content="lujun9972" />
  <meta name="keywords" content="linux和它的小伙伴" />
  <style>
   #ds-thread #ds-reset .ds-comment-body p {color: #ffffff;}
   #disqus_thread a {color: #00ffff;}
  </style>
  <link rel="stylesheet" media="screen" href="../../../../../media/css/font.css" rel="stylesheet" type="text/css"/>
  <link rel="stylesheet" href="../../../../../media/css/main.css" type="text/css">
  <link rel="stylesheet" href="../../../../../media/css/org-src-fontify.css" type="text/css">
  <link rel="stylesheet" href="../../../../../media/css/kdComment.css" type="text/css">
  <script type="text/javascript"
          src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
  <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
</head>

  <body class="container">
<div>
  <header class="masthead">
    <h1 class="masthead-title"><a href="../../../../../">暗无天日</a></h1>
    <p>=============&gt;随便,谢谢</p>
    <nav class="site-nav">
      <div class="menu-icon">
      </div>
      <ul class="trigger">
              <li><a href="../../../../../years/">Years</a></li>
              <li><a href="../../../../../tags/">Tags</a></li>
              <li><a href="../../../../../about/">About</a></li>
              <li><a href="https://github.com/lujun9972/lujun9972.github.com.git">Github</a></li>
              <li><a href="../../../../../rss.xml">RSS</a></li>
      </ul>
    </nav>
    <form method="get" id="searchform" action="http://www.google.com/search">
        <input type="text" class="field" name="q" id="s" placeholder="Search">
        <input type="hidden" name="as_sitesearch" value="lujun9972.github.io">
    </form>
    <img class="avatar" src="https://avatar.csdnimg.cn/6/2/4/1_lujun9972.jpg" />
  </header>
</div>

<div>
<div class="post">
<h1 class="title">linux下的SysRq键</h1>
<div id="table-of-contents">
<h2>&#30446;&#24405;</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org01b8038">启用SysRq</a>
<ul>
<li><a href="#orgfe3f4da">对内核的要求</a></li>
<li><a href="#org756a085">查看当前SysRq的值</a></li>
<li><a href="#org28f9429">更改SysRq的值</a></li>
</ul>
</li>
<li><a href="#org3cb7e7c">使用SysRq</a>
<ul>
<li><a href="#org22404b8">常见的几种功能键组合</a>
<ul>
<li><a href="#org4ba8d7b">R-E-I-S-U-B:安全重启系统</a></li>
<li><a href="#org700f011">恢复系统挂起</a></li>
<li><a href="#org7e288e6">获取系统信息</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org9addab0">查看SysRq的输出信息</a></li>
</ul>
</div>
</div>
<p>
<a href="https://en.wikipedia.org/wiki/Magic_SysRq_key">SysRq</a> 键在 QWERT 键盘上与 <code>PrtSc</code> 同键,通过按下 <code>ALT+SysRq+&lt;command key&gt;</code> 可以直接向linux kernel发送预设的系统操作指令。
这套组合键提供了一系列在系统崩溃时常用到的功能，比如同步数据、杀进程、卸载文件系统，甚至系统重启.
</p>

<div id="outline-container-org01b8038" class="outline-2">
<h2 id="org01b8038">启用SysRq</h2>
<div class="outline-text-2" id="text-org01b8038">
</div>
<div id="outline-container-orgfe3f4da" class="outline-3">
<h3 id="orgfe3f4da">对内核的要求</h3>
<div class="outline-text-3" id="text-orgfe3f4da">
<p>
启用 <code>SysRq</code> 的前提是在linux kernel编译时启用了 <code>CONFIG_MAGIC_SYSRQ</code> 选项.
</p>

<p>
在目前主流的发行版linux中都启用了该选项，但若你是自己编译的内核，则有必要搜索一下内核的config文件了，确保里面有一句
</p>
<pre class="example">
CONFIG_MAGIC_SYSRQ=y
</pre>

<p>
内核中还有一个与SysRq相关的配置项:
</p>
<pre class="example">
CONFIG_MAGIC_SYSRQ_DEFAULT_ENABLE=0x01b6
</pre>
<p>
这个配置项指定了默认SysRq的值，这个值表示kernel会对哪些功能产生反应。
</p>
</div>
</div>

<div id="outline-container-org756a085" class="outline-3">
<h3 id="org756a085">查看当前SysRq的值</h3>
<div class="outline-text-3" id="text-org756a085">
<p>
我们可以通过查看 <code>/proc/sys/kernel/sysrq</code> 的值来判断Kernel会对哪些功能产生反应.
</p>
<div class="org-src-container">
<pre class="src src-shell">cat /proc/sys/kernel/sysrq
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org">16
</pre>
</div>

<p>
这里你会看到一个数字，这个数字可以转换成一个9位比特的形式，其中每一位的比特都有一个含义如下:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">数字</th>
<th scope="col" class="org-right">位数</th>
<th scope="col" class="org-left">意义</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-left">完全禁用sysrq</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-left">允许所有的sysrq功能</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-right">2</td>
<td class="org-left">允许控制终端日志级别</td>
</tr>

<tr>
<td class="org-right">4</td>
<td class="org-right">3</td>
<td class="org-left">允许控制键盘输入类型(SAK,unraw)</td>
</tr>

<tr>
<td class="org-right">8</td>
<td class="org-right">4</td>
<td class="org-left">允许调试进程dump</td>
</tr>

<tr>
<td class="org-right">16</td>
<td class="org-right">5</td>
<td class="org-left">允许执行sync命令</td>
</tr>

<tr>
<td class="org-right">32</td>
<td class="org-right">6</td>
<td class="org-left">允许重新挂载文件系统为之读</td>
</tr>

<tr>
<td class="org-right">64</td>
<td class="org-right">7</td>
<td class="org-left">允许发送信号给进程(term,kill,oom-kill)</td>
</tr>

<tr>
<td class="org-right">128</td>
<td class="org-right">8</td>
<td class="org-left">允许重启/关机</td>
</tr>

<tr>
<td class="org-right">256</td>
<td class="org-right">9</td>
<td class="org-left">允许调整实时任务的优先级</td>
</tr>
</tbody>
</table>

<p>
因此，我这里的 <code>16</code> 表示允许通过 SysRq 来同步数据到磁盘中去，
而数字 <code>130</code> 转换成二进制就是 <code>010000010</code>,根据表中的对应关系很容易看出允许重启/关机以及调整终端日志级别。
</p>
</div>
</div>

<div id="outline-container-org28f9429" class="outline-3">
<h3 id="org28f9429">更改SysRq的值</h3>
<div class="outline-text-3" id="text-org28f9429">
<p>
如果只是希望临时更改 <code>SysRq</code> 的值，那么很简单，只需要将新的值写入到 <code>/proc/sys/kernel/sysrq</code> 中去
</p>
<div class="org-src-container">
<pre class="src src-shell"><span class="org-builtin">echo</span> <span class="org-string">"1"</span> |sudo tee /proc/sys/kernel/sysrq
</pre>
</div>
<p>
或者通过 <code>sysctl</code> 来进行设置
</p>
<div class="org-src-container">
<pre class="src src-shell">sysctl -w kernel.sysrq=1
</pre>
</div>

<p>
如果需要每次启动时都自动修改SysRq的值，则需要修改配置文件
</p>
<div class="org-src-container">
<pre class="src src-shell"><span class="org-builtin">echo</span> <span class="org-string">"kernel.sysrq = 1"</span>|sudo tee -a /etc/sysctl.conf
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org3cb7e7c" class="outline-2">
<h2 id="org3cb7e7c">使用SysRq</h2>
<div class="outline-text-2" id="text-org3cb7e7c">
<p>
使用SysRq有两种方式:
</p>

<p>
一种是直接通过键盘 <code>Alt+SysRq+&lt;command key&gt;(部分笔记本上是Alt+Fn+PrtSrc+&lt;command key&gt;)</code> 来出发，
</p>

<p>
还有一种是直接通过 <code>/proc/sysrq-trigger</code> 接口来完成.
</p>
<div class="org-src-container">
<pre class="src src-shell"><span class="org-builtin">echo</span> &#8220; b &#8221; |sudo tee /proc/sysrq-trigger
</pre>
</div>

<p>
其中，这里每个 <code>command-key</code> 都对应一种kernel的行为，而且需要说明的是，不同种类的键盘上，相同kernel行为对应的 <code>command-key</code> 居然是不同的！
</p>

<p>
下面表格就是各个kernel行为对应的 <code>command-key</code> 的说明:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Action</th>
<th scope="col" class="org-left">QWERTY</th>
<th scope="col" class="org-left">Dvorak</th>
<th scope="col" class="org-left">AZERTY</th>
<th scope="col" class="org-left">Colemak</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">设置控制台日志级别(console_loglevel),它决定了哪些kernel信息会被输出到控制台上</td>
<td class="org-left">0 - 9</td>
<td class="org-left">0 - 9</td>
<td class="org-left">0 - 9(without ⇧ Shift)</td>
<td class="org-left">0 - 9</td>
</tr>

<tr>
<td class="org-left">不同步并卸载文件系统，立即重启系统</td>
<td class="org-left">b</td>
<td class="org-left">x</td>
<td class="org-left">b</td>
<td class="org-left">b</td>
</tr>

<tr>
<td class="org-left">让系统立即崩溃. 在配置得当的情况下会产生一个 crashdump</td>
<td class="org-left">c</td>
<td class="org-left">j</td>
<td class="org-left">c</td>
<td class="org-left">c</td>
</tr>

<tr>
<td class="org-left">显示所有排它锁 (需要内核启用CONFIG_LOCKDEP选项)</td>
<td class="org-left">d</td>
<td class="org-left">e</td>
<td class="org-left">d</td>
<td class="org-left">s</td>
</tr>

<tr>
<td class="org-left">发送 SIGTERM 信号到除了 init (PID 1) 外的所有进程</td>
<td class="org-left">e</td>
<td class="org-left">.</td>
<td class="org-left">e</td>
<td class="org-left">f</td>
</tr>

<tr>
<td class="org-left">触发 oom_kill, 会随机杀掉一个进程以缓解 OOM</td>
<td class="org-left">f</td>
<td class="org-left">u</td>
<td class="org-left">f</td>
<td class="org-left">t</td>
</tr>

<tr>
<td class="org-left">当进入内核模式时，切换到内核的 framebuffer 控制台. 若有内核调试器 kdb，则进入该调试器中</td>
<td class="org-left">g</td>
<td class="org-left">i</td>
<td class="org-left">g</td>
<td class="org-left">d</td>
</tr>

<tr>
<td class="org-left">在控制台上输出一个简短的帮助信息. (其他不能识别的key也会输出帮助信息)</td>
<td class="org-left">h</td>
<td class="org-left">d</td>
<td class="org-left">h</td>
<td class="org-left">h</td>
</tr>

<tr>
<td class="org-left">发送 SIGKILL 信号到除了 init (PID 1) 外的所有进程</td>
<td class="org-left">i</td>
<td class="org-left">c</td>
<td class="org-left">i</td>
<td class="org-left">u</td>
</tr>

<tr>
<td class="org-left">强制通过 FIFREEZE ioctl 冻结文件系统.</td>
<td class="org-left">j</td>
<td class="org-left">h</td>
<td class="org-left">j</td>
<td class="org-left">n</td>
</tr>

<tr>
<td class="org-left">杀掉当前虚拟控制台中的所有进程 (包括 X 和 SVGALib 程序).</td>
<td class="org-left">k</td>
<td class="org-left">t</td>
<td class="org-left">k</td>
<td class="org-left">e</td>
</tr>

<tr>
<td class="org-left">列出所有活动CPU上的 stack backtrace</td>
<td class="org-left">l</td>
<td class="org-left">n</td>
<td class="org-left">l</td>
<td class="org-left">i</td>
</tr>

<tr>
<td class="org-left">在控制台上输出当前内存信息</td>
<td class="org-left">m</td>
<td class="org-left">m</td>
<td class="org-left">,</td>
<td class="org-left">m</td>
</tr>

<tr>
<td class="org-left">重置所有高优先级和实时任务的 nice 级别</td>
<td class="org-left">n</td>
<td class="org-left">b</td>
<td class="org-left">n</td>
<td class="org-left">k</td>
</tr>

<tr>
<td class="org-left">关闭系统</td>
<td class="org-left">o</td>
<td class="org-left">r</td>
<td class="org-left">o</td>
<td class="org-left">y</td>
</tr>

<tr>
<td class="org-left">在控制台输出当前寄存器和标志位信息</td>
<td class="org-left">p</td>
<td class="org-left">l</td>
<td class="org-left">p</td>
<td class="org-left">;</td>
</tr>

<tr>
<td class="org-left">Display all active high-resolution timers and clock sources.</td>
<td class="org-left">q</td>
<td class="org-left">'</td>
<td class="org-left">a</td>
<td class="org-left">q</td>
</tr>

<tr>
<td class="org-left">将键盘从 raw 模式(常被诸如X11和SVGALib这样的程序所使用)切换到 XLATE模式</td>
<td class="org-left">r</td>
<td class="org-left">p</td>
<td class="org-left">r</td>
<td class="org-left">p</td>
</tr>

<tr>
<td class="org-left">同步所有已挂载的文件系统</td>
<td class="org-left">s</td>
<td class="org-left">o</td>
<td class="org-left">s</td>
<td class="org-left">r</td>
</tr>

<tr>
<td class="org-left">在控制台输出当前任务列表</td>
<td class="org-left">t</td>
<td class="org-left">y</td>
<td class="org-left">t</td>
<td class="org-left">g</td>
</tr>

<tr>
<td class="org-left">重新以只读模式重新挂载所有已挂载的文件系统</td>
<td class="org-left">u</td>
<td class="org-left">g</td>
<td class="org-left">u</td>
<td class="org-left">l</td>
</tr>

<tr>
<td class="org-left">强制恢复 framebuffer console. 若为ARM处理器,则会导致 ETM buffer dump.</td>
<td class="org-left">v</td>
<td class="org-left">k</td>
<td class="org-left">v</td>
<td class="org-left">v</td>
</tr>

<tr>
<td class="org-left">显示所有阻塞状态(状态为D)的任务</td>
<td class="org-left">w</td>
<td class="org-left">,</td>
<td class="org-left">z</td>
<td class="org-left">w</td>
</tr>

<tr>
<td class="org-left">Used by xmon interface on PPC/PowerPC platforms.</td>
<td class="org-left">x</td>
<td class="org-left">q</td>
<td class="org-left">x</td>
<td class="org-left">x</td>
</tr>

<tr>
<td class="org-left">显示全局的CPU寄存器内容 (仅对SPARC-64平台有效)</td>
<td class="org-left">y</td>
<td class="org-left">f</td>
<td class="org-left">y</td>
<td class="org-left">j</td>
</tr>

<tr>
<td class="org-left">Dump the ftrace buffer</td>
<td class="org-left">z</td>
<td class="org-left">;</td>
<td class="org-left">w</td>
<td class="org-left">z</td>
</tr>

<tr>
<td class="org-left">输出一份简单的系统支持SysRq的键列表</td>
<td class="org-left">space</td>
<td class="org-left">space</td>
<td class="org-left">space</td>
<td class="org-left">space</td>
</tr>
</tbody>
</table>
</div>


<div id="outline-container-org22404b8" class="outline-3">
<h3 id="org22404b8">常见的几种功能键组合</h3>
<div class="outline-text-3" id="text-org22404b8">
<p>
下面列出几个常见的功能键组合:
</p>
</div>

<div id="outline-container-org4ba8d7b" class="outline-4">
<h4 id="org4ba8d7b">R-E-I-S-U-B:安全重启系统</h4>
<div class="outline-text-4" id="text-org4ba8d7b">
<p>
这套组合键大致相当于reboot命令：
</p>

<ul class="org-ul">
<li>unRaw – 把键盘设置为 XLATE 模式，使按键可以穿透 x server 捕捉传递给内核</li>

<li>tErminate – 向除 init 外进程发送 SIGTERM 信号，让其自行结束. 这一步推荐等待30秒让进程有足够的时间进行收尾的嗯做。</li>

<li>kIll - 向除 init 以外所有进程发送 SIGKILL 信号，强制结束进程. 这一步推荐等待10秒，保证所有进程都退出了</li>

<li>Sync – 同步缓冲区数据到硬盘，避免数据丢失. 这一步在能看到输出的情况下等到"Emergency Sync complete" 后再做后续动作，否则推荐等待10秒</li>

<li>Unmount – 将所有已经挂载的文件系统 重新挂载为只读. 该操作通常也有一定延时,请等到"Emergency Remount complete" 出现过后再进行后续操作,否则推荐等待10秒</li>

<li>reBoot - 立即重启计算机</li>
</ul>
</div>
</div>

<div id="outline-container-org700f011" class="outline-4">
<h4 id="org700f011">恢复系统挂起</h4>
<div class="outline-text-4" id="text-org700f011">
<p>
若仅仅是因为资源消耗过量引起系统挂起就重启系统显然是不好的，我们可以尝试通过回收一些资源的方式来回复系统挂起。
</p>

<p>
SysRq中用来结束进程的command-key包括 E-I-K-F，其中:
</p>

<ul class="org-ul">
<li>E 和 I 太凶残，它会杀掉除了 init 外的所有进程,属于杀敌一千自损八百的操作。因此在一般情况下不会轻易使用</li>

<li>F 则是利用 OOM-Kiler选择一个进程来结束,对于由于内存不足引起的挂起比较有效，但有时候OOMKiller也可能会误判杀掉一些长期运行的后台程序。</li>

<li>K 杀掉与当前控制台有关的进程组，比较推荐用这种方法回复系统</li>
</ul>

<p>
此外，若系统挂起是由于实时任务消耗太多CPU引起的，则可以通过 <code>N</code> 来降低实时任务运行的优先级来缓解挂起症状。
</p>
</div>
</div>
<div id="outline-container-org7e288e6" class="outline-4">
<h4 id="org7e288e6">获取系统信息</h4>
<div class="outline-text-4" id="text-org7e288e6">
<p>
SysRq还提供了几个用于获取系统信息的commandkey，在恢复系统挂起前推荐执行这些commandkey，以记录下当前系统状态。
</p>

<dl class="org-dl">
<dt>M</dt><dd>打印内存使用信息</dd>

<dt>W</dt><dd>打印CPU寄存器上下文和程序调用栈回溯信息</dd>

<dt>P</dt><dd>打印CPU寄存器信息,比如正在执行的进程名，运行函数，寄存器上下文，以及程序的调用栈回溯等</dd>

<dt>T</dt><dd>打印进程列表,各进程的名称，进程 PID，父 PID 兄弟 PID 以及进程运行状态等相关信息</dd>
</dl>
</div>
</div>
</div>
</div>
<div id="outline-container-org9addab0" class="outline-2">
<h2 id="org9addab0">查看SysRq的输出信息</h2>
<div class="outline-text-2" id="text-org9addab0">
<p>
从上面的列表中我们可以看到，使用SysRq能够输出大量的信息。这些信息，默认会输出到syslog中.
同时，若设置的 <code>console_loglevel(0-9)</code> 大于 <code>default_message_loglevel</code> 则输出也会输出到本地控制台终端上去。
另外，若设置的 <code>console_loglevel</code> 大于 <code>default_message_loglvel</code> 则输出还会通过netconsole输出到远程机器上去。
</p>

<p>
总体来说，syslog中记录的日志应该是最完整的，然而由于负责记录日志的 <code>syslogd</code> 本身是一个用户进程，在某些情况下可能会被杀掉，从而导致日志记录不下来。
</p>

<div class="org-src-container">
<pre class="src src-shell"><span class="org-builtin">echo</span> <span class="org-string">" "</span>|sudo tee /proc/sysrq-trigger
dmesg |tail -n 1
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org"> 
[17899.255261] sysrq: SysRq : HELP : loglevel(0-9) reboot(b) crash(c) terminate-all-tasks(e) memory-full-oom-kill(f) kill-all-tasks(i) thaw-filesystems(j) sak(k) show-backtrace-all-active-cpus(l) show-memory-usage(m) nice-all-RT-tasks(n) poweroff(o) show-registers(p) show-all-timers(q) unraw(r) sync(s) show-task-states(t) unmount(u) force-fb(V) show-blocked-tasks(w) dump-ftrace-buffer(z) 
</pre>
</div>
</div>
</div>

</div>
</div>
<div>
  <div class="post-meta">
    <span title="post date" class="post-info">2018-08-22</span>
    <span title="last modification date" class="post-info">2018-08-22</span>
    <span title="tags" class="post-info"><a href="../../../../../tags/linux和它的小伙伴">linux和它的小伙伴</a></span>
    <span title="author" class="post-info">lujun9972</span>
  </div>
  <script src="../../../../../media/js/jquery-2.1.3.min.js"></script>
  <script src="../../../../../media/js/md5.min.js"></script>
  <section>
      <div id="gitalk-container"></div>
      <script type="text/javascript">
       var gitalk = new Gitalk({
           clientID: 'fdcb5d9da3f4acb4862c',
           clientSecret: 'dd0a16312a206782cb7669dcec5e96874ab48170',
           repo: 'lujun9972.github.com',
           owner: 'lujun9972',
           admin: ['lujun9972'],
           id: md5(location.pathname),      // Ensure uniqueness and length less than 50
           distractionFreeMode: false  // Facebook-like distraction free mode
       })
       gitalk.render('gitalk-container')
      </script>
  </section>
  <script src="../../../../../media/js/kdComment.js"></script>
      <script>
       var _hmt = _hmt || [];
       (function() {
           var hm = document.createElement("script");
           hm.src = "https://hm.baidu.com/hm.js?7bac4fd0247f69c27887e0d4e3aee41e";
           var s = document.getElementsByTagName("script")[0]; 
           s.parentNode.insertBefore(hm, s);
       })();
      </script>
  <div class="footer">
    <p>Generated by <a href="http://www.gnu.org/software/emacs/">Emacs</a> 27.x(<a href="http://orgmode.org">Org mode</a> 9.x)</p>
    <p>
      Copyright &copy; 2014 - <span id="footerYear"></span> <a href="mailto:travis &lt;at&gt; travis-job-7681ff2a-872b-49f2-9385-cd1ed3ca84fc">lujun9972</a>
      &nbsp;&nbsp;-&nbsp;&nbsp;
      Powered by <a href="https://github.com/emacs-china/EGO" target="_blank">EGO</a><br/>
      Themed with <a href="https://github.com/kuangdash/emacs_love" target="_blank">emacs_love</a>
        <a href="http://creativecommons.org/licenses/by-sa/3.0/" rel="license"><img src="https://licensebuttons.net/l/by-sa/3.0/88x31.png" style="border-width:0" alt="Creative Commons License" class="center"></a>
      <script type="text/javascript">document.getElementById("footerYear").innerHTML = (new Date()).getFullYear();</script>
    </p>
  </div>
    </div>

  </body>
</html>
