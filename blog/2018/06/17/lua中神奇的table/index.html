<!DOCTYPE html>
<html lang="en">
<head>
  <title>lua中神奇的table - 暗无天日</title>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <meta name="author" content="lujun9972" />
  <meta name="keywords" content="编程之旅,lua" />
  <style>
   #ds-thread #ds-reset .ds-comment-body p {color: #ffffff;}
   #disqus_thread a {color: #00ffff;}
  </style>
  <link rel="stylesheet" media="screen" href="/media/css/font.css" rel="stylesheet" type="text/css"/>
  <link rel="stylesheet" href="/media/css/main.css" type="text/css">
  <link rel="stylesheet" href="/media/css/kdComment.css" type="text/css">
  <script type="text/javascript"
          src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
  <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
</head>

  <body class="container">
<div>
  <header class="masthead">
    <h1 class="masthead-title"><a href="/">暗无天日</a></h1>
    <p>=============&gt;随便,谢谢</p>
    <nav class="site-nav">
      <div class="menu-icon">
      </div>
      <ul class="trigger">
              <li><a href="/years/">Years</a></li>
              <li><a href="/authors/">Authors</a></li>
              <li><a href="/tags/">Tags</a></li>
              <li><a href="/about/">About</a></li>
              <li><a href="https://github.com/lujun9972/lujun9972.github.com">Github</a></li>
              <li><a href="/rss.xml">RSS</a></li>
      </ul>
    </nav>
    <form method="get" id="searchform" action="http://www.google.com/search">
        <input type="text" class="field" name="q" id="s" placeholder="Search">
        <input type="hidden" name="as_sitesearch" value="lujun9972.github.io">
    </form>
  </header>
</div>

<div>
<div class="post">
<h1 class="title">lua中神奇的table</h1>
<div id="table-of-contents">
<h2>&#30446;&#24405;</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgff1f81f">字典</a></li>
<li><a href="#orgdbb4651">数组</a></li>
<li><a href="#org1bb8fd9">环境(命名空间)</a></li>
<li><a href="#org8b06f45">module</a></li>
<li><a href="#org369b095">对象</a></li>
<li><a href="#orgf6d1cdf">类</a></li>
</ul>
</div>
</div>
<p>
最近在尝试配置 awesome WM，因此粗略地学习了一下 lua 。 在学习过程中，我完全被 table 在 lua 中的应用所镇住了。
</p>

<p>
table 在 lua 中真的是无处不在:首先,它可以作为字典和数组来用; 此外，它还可以被用于设置闭包环境、module; 甚至可以用来模拟对象和类
</p>

<div id="outline-container-orgff1f81f" class="outline-2">
<h2 id="orgff1f81f">字典</h2>
<div class="outline-text-2" id="text-orgff1f81f">
<p>
table 最基础的作用就是当成字典来用。 它的 key 值可以是除了 nil 之外的任何类型的值。
</p>

<div class="org-src-container">
<pre class="src src-lua">t={}
t[{}] = "table"                 -- key 可以是 table
t[1] = "int"                    -- key 可以是整数
t[1.1] = "double"               -- key 可以是小数
t[function () end] = "function" -- key 可以是函数
t[true] = "Boolean"             -- key 可以是布尔值
t["abc"] = "String"             -- key 可以是字符串
t[io.stdout] = "userdata"       -- key 可以是userdata
t[coroutine.create(function () end)] = "Thread" -- key可以是thread
</pre>
</div>

<p>
当把 table 当成字典来用时，可以使用 <code>pairs</code> 函数来进行遍历。
</p>
<div class="org-src-container">
<pre class="src src-lua">for k,v in pairs(t) do
  print(k,"-&gt;",v)
end
</pre>
</div>

<p>
运行结果为:
</p>
<div class="org-src-container">
<pre class="src src-org">1       -&gt;      int
1.1     -&gt;      double
thread: 0x220bb08       -&gt;      Thread
table: 0x220b670        -&gt;      table
abc     -&gt;      String
file (0x7f34a81ef5c0)   -&gt;      userdata
function: 0x220b340     -&gt;      function
true    -&gt;      Boolean
</pre>
</div>

<p>
从结果中你还可以发现，使用 <code>pairs</code> 进行遍历时的顺序是随机的，事实上相同的语句执行多次得到的结果是不一样的。
</p>

<p>
table 中的key最常见的两种类型就是整数型和字符串类型。 
当 key 为字符串时，table可以当成结构体来用。同时形如 <code>t["field"]</code> 这种形式的写法可以简写成 <code>t.field</code> 这种形式。
</p>
</div>
</div>

<div id="outline-container-orgdbb4651" class="outline-2">
<h2 id="orgdbb4651">数组</h2>
<div class="outline-text-2" id="text-orgdbb4651">
<p>
当 key 为整数时，table 就可以当成数组来用。而且这个数组是一个 <b>索引从1开始</b> ，没有固定长度，可以根据需要自动增长的数组。
</p>
<div class="org-src-container">
<pre class="src src-lua">a = {}
for i=0,5 do                    -- 注意，这里故意写成了i从0开始
  a[i] = 0
end
</pre>
</div>

<p>
当将 table 当成数组来用时，可以通过 长度操作符 <code>#</code> 来获取数组的长度
</p>
<div class="org-src-container">
<pre class="src src-lua">print(#a)
</pre>
</div>
<p>
结果为
</p>
<div class="org-src-container">
<pre class="src src-org">5
</pre>
</div>

<p>
你会发现， lua 认为 数组 a 中只有5个元素，到底是哪5个元素呢？我们可以使用使用 <code>ipairs</code> 对数组进行遍历:
</p>
<div class="org-src-container">
<pre class="src src-lua">for i,v in ipairs(a) do
  print(i,v)
end
</pre>
</div>
<p>
结果为
</p>
<div class="org-src-container">
<pre class="src src-org">1       0
2       0
3       0
4       0
5       0
</pre>
</div>
<p>
从结果中你会发现 <code>a</code> 的0号索引并不认为是数组中的一个元素，从而也验证了 lua 中的数组是从 <b>1开始索引的</b>
</p>

<p>
另外，将table当成数组来用时，一定要注意索引不连贯的情况，这种情况下 <code>#</code> 计算长度时会变得很诡异
</p>
<div class="org-src-container">
<pre class="src src-lua">a = {}
for i=1,5 do
  a[i] = 0
end
a[8] = 0                        -- 虽然索引不连贯，但长度是以最大索引为准
print(#a)
a[100] = 0                      -- 索引不连贯，而且长度不再以最大索引为准了
print(#a)
</pre>
</div>
<p>
结果为：
</p>
<div class="org-src-container">
<pre class="src src-org">8
8
</pre>
</div>

<p>
而使用 <code>ipairs</code> 对数组进行遍历时，只会从1遍历到索引中断处
</p>
<div class="org-src-container">
<pre class="src src-lua">for i,v in ipairs(a) do
  print(i,v)
end
</pre>
</div>
<p>
结果为：
</p>
<div class="org-src-container">
<pre class="src src-org">1       0
2       0
3       0
4       0
5       0
</pre>
</div>
</div>
</div>

<div id="outline-container-org1bb8fd9" class="outline-2">
<h2 id="org1bb8fd9">环境(命名空间)</h2>
<div class="outline-text-2" id="text-org1bb8fd9">
<p>
lua将所有的全局变量/局部变量保存在一个常规table中，这个table一般被称为全局或者某个函数(闭包)的环境。
</p>

<p>
为了方便，lua在创建最初的全局环境时，使用全局变量 <code>_G</code> 来引用这个全局环境。因此，在未手工设置环境的情况下，可以使用 <code>_G[varname]</code> 来存取全局变量的值.
</p>
<div class="org-src-container">
<pre class="src src-lua">for k,v in pairs(_G) do
  print(k,"-&gt;",v)
end
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org">rawequal        -&gt;      function: 0x41c2a0
require -&gt;      function: 0x1ea4e70
_VERSION        -&gt;      Lua 5.3
debug   -&gt;      table: 0x1ea8ad0
string  -&gt;      table: 0x1ea74b0
xpcall  -&gt;      function: 0x41c720
select  -&gt;      function: 0x41bea0
package -&gt;      table: 0x1ea4820
assert  -&gt;      function: 0x41cc50
pcall   -&gt;      function: 0x41cd10
next    -&gt;      function: 0x41c450
tostring        -&gt;      function: 0x41be70
_G      -&gt;      table: 0x1ea2b80
coroutine       -&gt;      table: 0x1ea4ee0
unpack  -&gt;      function: 0x424fa0
loadstring      -&gt;      function: 0x41ca00
setmetatable    -&gt;      function: 0x41c7e0
rawlen  -&gt;      function: 0x41c250
bit32   -&gt;      table: 0x1ea8fc0
utf8    -&gt;      table: 0x1ea8650
math    -&gt;      table: 0x1ea7770
collectgarbage  -&gt;      function: 0x41c650
rawset  -&gt;      function: 0x41c1b0
os      -&gt;      table: 0x1ea6840
pairs   -&gt;      function: 0x41c950
arg     -&gt;      table: 0x1ea9450
table   -&gt;      table: 0x1ea5130
tonumber        -&gt;      function: 0x41bf40
io      -&gt;      table: 0x1ea5430
loadfile        -&gt;      function: 0x41cb10
error   -&gt;      function: 0x41c5c0
load    -&gt;      function: 0x41ca00
print   -&gt;      function: 0x41c2e0
dofile  -&gt;      function: 0x41cbd0
rawget  -&gt;      function: 0x41c200
type    -&gt;      function: 0x41be10
getmetatable    -&gt;      function: 0x41cb80
module  -&gt;      function: 0x1ea4e00
ipairs  -&gt;      function: 0x41c970
</pre>
</div>

<p>
从lua 5.2开始，可以通过修改 <code>_ENV</code> 这个值(<b>lua5.1中的setfenv从5.2开始被废除</b>)来设置某个函数的环境，从而让这个函数中的执行语句在一个新的环境中查找全局变量的值。
</p>

<div class="org-src-container">
<pre class="src src-lua">a=1                             -- 全局变量中a=1
local env={a=10,print=_G.print} -- 新环境中a=10,并且确保能访问到全局的print函数
function f1()
  local _ENV=env
  print("in f1:a=",a)
  a=a*10                        -- 修改的是新环境中的a值
end

f1()
print("globally:a=",a)
print("env.a=",env.a)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org">in f1:a=        10
globally:a=     1
env.a=  100
</pre>
</div>

<p>
另外，新创建的闭包都继承了创建它的函数的环境
</p>
</div>
</div>

<div id="outline-container-org8b06f45" class="outline-2">
<h2 id="org8b06f45">module</h2>
<div class="outline-text-2" id="text-org8b06f45">
<p>
lua 中的模块也是通过返回一个table来供模块使用者来使用的。 这个 table中包含的是模块中所导出的所有东西，包括函数和常量。
</p>

<p>
定义module的一般模板为
</p>
<div class="org-src-container">
<pre class="src src-lua">module(模块名, package.seeall)
</pre>
</div>

<p>
其中 <code>module(模块名)</code> 的作用类似于
</p>
<div class="org-src-container">
<pre class="src src-lua">local modname = 模块名
local M = {}                    -- M即为存放模块所有函数及常数的table
_G[modname] = M
package.loaded[modname] = M
setmetatable(M,{__index=_G})    -- package.seeall可以使全局环境_G对当前环境可见
local _ENV = M                  -- 设置当前的运行环境为 M，这样后续所有代码都不需要限定模块名了，所定义的所有函数自动变成M的成员
&lt;函数定义以及常量定义&gt;

return M                        -- module函数会帮你返回module table，而无需手工返回
</pre>
</div>
</div>
</div>
<div id="outline-container-org369b095" class="outline-2">
<h2 id="org369b095">对象</h2>
<div class="outline-text-2" id="text-org369b095">
<p>
lua 中之所以可以把table当成对象来用是因为:
</p>
<ol class="org-ol">
<li><p>
函数在 lua 中是一类值，你可以直接存取table中的函数值。 这使得一个table既可以有自己的状态，也可以有自己的行为：
</p>
<div class="org-src-container">
<pre class="src src-lua">Account = {balance = 0}
function Account.withdraw(v)
  Account.balance = Account.balance - v
end
</pre>
</div></li>
<li><p>
lua 支持闭包,这个特性可以用来模拟对象的私有成员变量
</p>
<div class="org-src-container">
<pre class="src src-lua">function new_account(b)
  local balance = b
  return {withdraw = function (v) balance = balance -v end,
          get_balance = function () return balance end
  }
end

a1 = new_account(1000)
a1.withdraw(10)
print(a1.get_balance())
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org">990
</pre>
</div></li>
</ol>

<p>
不过，上面第一种定义对象的方法有一个缺陷，那就是方法与 <code>Account</code> 这个名称绑定死了。
也就是说，这个对象的名称必须为 <code>Accout</code> 否则就会出错
</p>
<div class="org-src-container">
<pre class="src src-lua">a = Account
Account = nil
a.withdraw(10)                  -- 会报错，因为Accout.balance不再存在
</pre>
</div>

<p>
为了解决这个问题，我们可以给 <code>withdraw</code> 方法多一个参数用于指向对象本身
</p>
<div class="org-src-container">
<pre class="src src-lua">Account = {balance=100}
function Account.withdraw(self,v)
  self.balance = self.balance - v
end
a = Account
Account = nil
a.withdraw(a,10)                  -- 没问题，这个时候 self 指向的是a，因此会去寻找 a.balance
print(a.balance)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org">90
</pre>
</div>

<p>
不过由于第一个参数 <code>self</code> 几乎总是指向调用方法的对象本身，因此 lua 提供了一种语法糖形式 <code>object:method(...)</code> 用于隐藏 <code>self</code> 参数的定义及传递. 
这里冒号的作用有两个，其在定义函数时往函数中地一个参数的位置添加一个额外的隐藏参数 <code>sef</code>, 而在调用时传递一个额外的隐藏参数 <code>self</code> 到地一个参数位置。
即 <code>function object:method(v) end</code> 等价于 <code>function object.method(self,v) end</code>,
<code>object:method(v)</code> 等价于 <code>object.method(object,v)</code>
</p>
</div>
</div>

<div id="outline-container-orgf6d1cdf" class="outline-2">
<h2 id="orgf6d1cdf">类</h2>
<div class="outline-text-2" id="text-orgf6d1cdf">
<p>
当涉及到类和继承时，就要用到元表和元方法了。事实上，对于 lua 来说，对象和类并不存在一个严格的划分。
</p>

<p>
当一个对象被另一个table的 <code>__index</code> 元方法所引用时，table就能引用该对象中所定义的方法，因此也就可以理解为对象变成了table的类。
</p>

<p>
类定义的一般模板为:
</p>
<div class="org-src-container">
<pre class="src src-lua">function 类名:new(o)
  o = o or {}
  setmetatable(o,{__index = self})
  return o
end
</pre>
</div>
<p>
或者
</p>
<div class="org-src-container">
<pre class="src src-lua">function 类名:new(o)
  o = o or {}
  setmetatable(o,self)
  self.__index = self
  return o
end
</pre>
</div>
<p>
相比之下，第二种写法可以多省略一个table
</p>

<p>
另外有一点我觉得有必要说明的就是 lua 中的元方法是在元表中定义的，而不是对象本身定义的，这一点跟其他面向对象的语言比较不同。
</p>
</div>
</div>

</div>
</div>
<div>
  <div class="post-meta">
    <span title="post date" class="post-info">2018-06-17</span>
    <span title="last modification date" class="post-info">2018-06-18</span>
    <span title="tags" class="post-info"><a href="/tags/编程之旅">编程之旅</a> : <a href="/tags/lua">lua</a></span>
    <span title="author" class="post-info">lujun9972</span>
  </div>
  <script src="/media/js/jquery-2.1.3.min.js"></script>
  <script src="/media/js/md5.min.js"></script>
  <section>
      <div id="gitalk-container"></div>
      <script type="text/javascript">
       var gitalk = new Gitalk({
           clientID: 'fdcb5d9da3f4acb4862c',
           clientSecret: 'dd0a16312a206782cb7669dcec5e96874ab48170',
           repo: 'lujun9972.github.com',
           owner: 'lujun9972',
           admin: ['lujun9972'],
           id: md5(location.pathname),      // Ensure uniqueness and length less than 50
           distractionFreeMode: false  // Facebook-like distraction free mode
       })
       gitalk.render('gitalk-container')
      </script>
  </section>
  <script src="/media/js/kdComment.js"></script>
      <script>
       var _hmt = _hmt || [];
       (function() {
           var hm = document.createElement("script");
           hm.src = "https://hm.baidu.com/hm.js?7bac4fd0247f69c27887e0d4e3aee41e";
           var s = document.getElementsByTagName("script")[0]; 
           s.parentNode.insertBefore(hm, s);
       })();
      </script>
  <div class="footer">
    <p>Generated by <a href="http://www.gnu.org/software/emacs/">Emacs</a> 27.x(<a href="http://orgmode.org">Org mode</a> 9.x)</p>
    <p>
      Copyright &copy; 2014 - <span id="footerYear"></span> <a href="mailto:travis &lt;at&gt; travis-job-28cf1161-6021-4541-a002-8eb87d451368">lujun9972</a>
      &nbsp;&nbsp;-&nbsp;&nbsp;
      Powered by <a href="https://github.com/emacs-china/EGO" target="_blank">EGO</a><br/>
      Themed with <a href="https://github.com/kuangdash/emacs_love" target="_blank">emacs_love</a>
        <a href="http://creativecommons.org/licenses/by-sa/3.0/" rel="license"><img src="http://i.creativecommons.org/l/by-sa/3.0/88x31.png" style="border-width:0" alt="Creative Commons License" class="center"></a>
      <script type="text/javascript">document.getElementById("footerYear").innerHTML = (new Date()).getFullYear();</script>
    </p>
  </div>
    </div>

  </body>
</html>
