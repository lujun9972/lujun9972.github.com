<!DOCTYPE html>
<html lang="en">
<head>
  <title>信号 - 暗无天日</title>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <meta name="author" content="DarkSun" />
  <style>
   #ds-thread #ds-reset .ds-comment-body p {color: #ffffff;}
   #disqus_thread a {color: #00ffff;}
  </style>
  <link rel="stylesheet" media="screen" href="../../../../../media/css/font.css" rel="stylesheet" type="text/css"/>
  <link rel="stylesheet" href="../../../../../media/css/main.css" type="text/css">
  <link rel="stylesheet" href="../../../../../media/css/org-src-fontify.css" type="text/css">
  <link rel="stylesheet" href="../../../../../media/css/kdComment.css" type="text/css">
  <script type="text/javascript"
          src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
  <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
</head>

  <body class="container">
<div>
  <header class="masthead">
    <h1 class="masthead-title"><a href="../../../../../">暗无天日</a></h1>
    <p>=============&gt;随便,谢谢</p>
    <nav class="site-nav">
      <div class="menu-icon">
      </div>
      <ul class="trigger">
              <li><a href="../../../../../years/">Years</a></li>
              <li><a href="../../../../../tags/">Tags</a></li>
              <li><a href="../../../../../about/">About</a></li>
              <li><a href="https://github.com/lujun9972/lujun9972.github.com.git">Github</a></li>
              <li><a href="../../../../../rss.xml">RSS</a></li>
      </ul>
    </nav>
    <form method="get" id="searchform" action="http://www.google.com/search">
        <input type="text" class="field" name="q" id="s" placeholder="Search">
        <input type="hidden" name="as_sitesearch" value="lujun9972.github.io">
    </form>
  </header>
</div>

<div>
<div class="post">
<h1 class="title">信号</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgf8e4b2c">1. 编号为0的信号</a></li>
<li><a href="#org9b33b2e">2. 信号的处理</a></li>
<li><a href="#org98ae82f">3. 不产生core文件的条件</a></li>
<li><a href="#orgbd8a220">4. 常用信号说明</a></li>
<li><a href="#org14279d7">5. 注册信号处理函数</a>
<ul>
<li><a href="#orgcbef666">5.1. signal</a></li>
</ul>
</li>
<li><a href="#org439cef5">6. 不可靠的信号</a></li>
<li><a href="#org8a245f4">7. 可重入函数与不可重入函数</a></li>
<li><a href="#org7a70890">8. 抛出信号</a></li>
<li><a href="#orgd7742bd">9. alarm设置计时器</a></li>
<li><a href="#orge7702dd">10. pause函数挂起进程</a></li>
<li><a href="#org78960bc">11. 信号集</a></li>
<li><a href="#org038ce1a">12. sigprocmask函数</a></li>
<li><a href="#org821b12e">13. sigpendng函数</a></li>
<li><a href="#org69a2c84">14. sigaction函数</a>
<ul>
<li><a href="#org1fecbbf">14.1. 参数act的说明</a></li>
<li><a href="#org0e66722">14.2. 函数sa_sigaction说明</a></li>
</ul>
</li>
<li><a href="#org6625a11">15. sigsetjmp和siglongjmp函数</a></li>
<li><a href="#orge597d83">16. sigsuspend</a></li>
<li><a href="#org6cec838">17. abort函数</a></li>
<li><a href="#org6bd1215">18. 其他特性</a>
<ul>
<li><a href="#org79a7f02">18.1. </a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-orgf8e4b2c" class="outline-2">
<h2 id="orgf8e4b2c"><span class="section-number-2">1</span> 编号为0的信号</h2>
<div class="outline-text-2" id="text-1">
<p>
不存在编号为0的信号,kill函数对编号为0的信号有特殊处理. POSIX.1将这种信号称为空信号
</p>
</div>
</div>

<div id="outline-container-org9b33b2e" class="outline-2">
<h2 id="org9b33b2e"><span class="section-number-2">2</span> 信号的处理</h2>
<div class="outline-text-2" id="text-2">
<p>
有两种信号是不能忽略的,就是SIGKILL和SIGSTOP,因为进程收到这两个信号后必须终止或停止0运行.
</p>
</div>
</div>

<div id="outline-container-org98ae82f" class="outline-2">
<h2 id="org98ae82f"><span class="section-number-2">3</span> 不产生core文件的条件</h2>
<div class="outline-text-2" id="text-3">
<ol class="org-ol">
<li>进度是设置用户ID的,但当前用户并非程序文件的所有者</li>
<li>进程是设置组ID的,但当前用户组并非程序文件的组所有者</li>
<li>用户没有写当前工作目录的权限,也就无法产生新的core文件</li>
<li>core文件已存在,且用户对该文件没有写权限,也就无法覆盖原core文件</li>
<li>core文件太大,超过了RLIMIT_CORE的限制</li>
</ol>
</div>
</div>

<div id="outline-container-orgbd8a220" class="outline-2">
<h2 id="orgbd8a220"><span class="section-number-2">4</span> 常用信号说明</h2>
<div class="outline-text-2" id="text-4">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">信号</th>
<th scope="col" class="org-left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">SIGABRT</td>
<td class="org-left">调用abort函数产生的信号. 进程异常终止</td>
</tr>

<tr>
<td class="org-left">SIGALRM</td>
<td class="org-left">函数alarm设置的计时器超时,或setitimer函数设置的间隔时间超时产生该信号</td>
</tr>

<tr>
<td class="org-left">SIGCHLD</td>
<td class="org-left">子进程终止或停止时,发送该信号給父进程</td>
</tr>

<tr>
<td class="org-left">SIGCONT</td>
<td class="org-left">该作业控制信号发送给处于停止状态的进程,让其继续运行</td>
</tr>

<tr>
<td class="org-left">SIGFPE</td>
<td class="org-left">算术运算异常</td>
</tr>

<tr>
<td class="org-left">SIGHUP</td>
<td class="org-left">终端接口检测到连接断开,会将该信号发送给该终端相关的会话首进程. 会话首进程关闭时也会发送该信号到该会话中的所有进程. 常用于使用该信号通知守护进程,以便重新读取它们的配置文件.</td>
</tr>

<tr>
<td class="org-left">SIGINT</td>
<td class="org-left">用户按下中断键(一般为C-c或DEL键)</td>
</tr>

<tr>
<td class="org-left">SIGIO</td>
<td class="org-left">该信号指示一个异步IO事件</td>
</tr>

<tr>
<td class="org-left">SIGKILL</td>
<td class="org-left">该信号无法被捕捉,进程接收后必定终止</td>
</tr>

<tr>
<td class="org-left">SIGPIPE</td>
<td class="org-left">写到管道时读进程已终止,则产生该信号. SOCK_STREAM的套接字不再连接时,进程写到该套接字也产生此信号</td>
</tr>

<tr>
<td class="org-left">SIGPOLL</td>
<td class="org-left">在一个可轮询设备上发生特定事件时产生此信号</td>
</tr>

<tr>
<td class="org-left">SIGQUIT</td>
<td class="org-left">用户在终端上按退出键(一般为C-\)</td>
</tr>

<tr>
<td class="org-left">SIGSEGV</td>
<td class="org-left">进程进行了一次无效的内存引用</td>
</tr>

<tr>
<td class="org-left">SIGSTOP</td>
<td class="org-left">这是一个作业控制进程,用于暂停一个进程. 类似于SIGTSTP信号,但不能被捕获或忽略</td>
</tr>

<tr>
<td class="org-left">SIGSYS</td>
<td class="org-left">产生一个无效的系统调用</td>
</tr>

<tr>
<td class="org-left">SIGTERM</td>
<td class="org-left">kill命令发送的系统默认终止信号</td>
</tr>

<tr>
<td class="org-left">SIGTSTP</td>
<td class="org-left">交互式停止信号,当用户在终端上按挂起键(C-z)时产生,并发送至前台进程组中的 <b>所有进程</b></td>
</tr>

<tr>
<td class="org-left">SIGTTIN</td>
<td class="org-left">当后台进程组中的进程试图读取控制终端时产生. 但若 <b>读取进程所属的进程组为孤儿进程组,此时操作返回出错,且errno为EIO</b></td>
</tr>

<tr>
<td class="org-left">SIGTTOU</td>
<td class="org-left">当后台进程组中的进程试图写到其控制终端时产生. 若 <b>终端设置为不允许写且写进程所属进程组为孤儿进程组,则写操作返回出错,errnro为EIO</b></td>
</tr>

<tr>
<td class="org-left">SIGURG</td>
<td class="org-left">通知进程已发生一个紧急情况</td>
</tr>

<tr>
<td class="org-left">SIGUSR1</td>
<td class="org-left">用户自定义进程</td>
</tr>

<tr>
<td class="org-left">SIGUSR2</td>
<td class="org-left">用户自定义进程</td>
</tr>

<tr>
<td class="org-left">SIGVTALRM</td>
<td class="org-left">setitimer函数设置的虚拟间隔时间到期时产生此信号</td>
</tr>

<tr>
<td class="org-left">SIGXCPU</td>
<td class="org-left">进程超过其软CPU时间限制</td>
</tr>

<tr>
<td class="org-left">SIGXFSZ</td>
<td class="org-left">进程超过了其软文件长度限制</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org14279d7" class="outline-2">
<h2 id="org14279d7"><span class="section-number-2">5</span> 注册信号处理函数</h2>
<div class="outline-text-2" id="text-5">
</div>
<div id="outline-container-orgcbef666" class="outline-3">
<h3 id="orgcbef666"><span class="section-number-3">5.1</span> signal</h3>
<div class="outline-text-3" id="text-5-1">
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;signal.h&gt;</span>

<span class="org-keyword">typedef</span> <span class="org-type">void</span> (*<span class="org-type">SIGN_HANDER_P</span>)(<span class="org-type">int</span>);

<span class="org-comment-delimiter">/* </span><span class="org-comment">signal&#20989;&#25968;&#30340;&#36820;&#22238;&#20540;&#26159;&#20043;&#21069;&#30340;&#20449;&#21495;&#22788;&#29702;&#20989;&#25968;&#25351;&#38024;,&#33509;&#22833;&#36133;,&#36820;&#22238;SIG_ERR</span><span class="org-comment-delimiter"> */</span>
<span class="org-type">SIGN_HANDER_P</span> <span class="org-function-name">signal</span>(<span class="org-type">int</span> <span class="org-variable-name">signo</span>,<span class="org-type">SIGN_HANDER_P</span> <span class="org-variable-name">func</span>);
</pre>
</div>
<ul class="org-ul">
<li>signal函数由ISO C定义. 因为ISO C不涉及多进程,进程组以及终端IO等,所以它对信号的定义非常模糊,以至于 <b>对UNIX系统而言几乎毫无用处</b></li>
<li>signal的语义与实现有关,所以最好使用sigaction函数代替signal函数</li>
<li>系统预先定义了SIG_IGN和SIG_DEF两个信号处理函数.</li>
<li>signal函数的一个缺陷在于,不改变信号的处理方式,就无法确定信号的当前处理方式.</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org439cef5" class="outline-2">
<h2 id="org439cef5"><span class="section-number-2">6</span> 不可靠的信号</h2>
<div class="outline-text-2" id="text-6">
<p>
早期UNIX中的信号是不可靠的,即信号可能会丢失
</p>
<ul class="org-ul">
<li>当发生信号到调用信号处理函数之间又发生另一次中断信号,这时程序会转去执行第二个中断点的处理函数</li>
<li>当信号发生时,进程只能选择立即处理该信号或忽略该信号, <b>而无法让内核暂时记录下该信号</b></li>
</ul>
</div>
</div>
<div id="outline-container-org8a245f4" class="outline-2">
<h2 id="org8a245f4"><span class="section-number-2">7</span> 可重入函数与不可重入函数</h2>
<div class="outline-text-2" id="text-7">
<p>
进程在捕获到信号后,会中断正在执行的指令序列,转而调用该信号的处理程序,然后再接着执行在捕捉到信号时进程正在执行的正常命令序列.
</p>

<p>
若函数被中断后接着执行指令序列会照成函数处理失败,则该函数为不可重入函数,否则叫做可重入函数.
</p>

<p>
同样的,由于多线程也会中断一个线程的执行,转而执行另一个线程的内容,因此也跟信号中断类似.
</p>

<p>
不可重入函数的特点有:
</p>
<ol class="org-ol">
<li>使用了静态数据结构</li>
<li>使用了全局数据结构 <b>标准IO库的很多实现都以不可重入方式使用了全局数据结构</b></li>
<li>调用了malloc或free</li>
</ol>

<p>
此外,为了防止中断处理函数改变errno变量,因此作为一个通用规则,当在信号函数中调用可重入函数时,应当将errno的值先保存,然后再恢复.
</p>
</div>
</div>
<div id="outline-container-org7a70890" class="outline-2">
<h2 id="org7a70890"><span class="section-number-2">8</span> 抛出信号</h2>
<div class="outline-text-2" id="text-8">
<p>
kill函数将信号发送給进程或进程组. raise函数允许进程向 <b>自身</b> 发送信号
</p>
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;signal.h&gt;</span>

<span class="org-comment-delimiter">/* </span><span class="org-comment">&#25104;&#21151;&#36820;&#22238;0,&#20986;&#38169;&#36820;&#22238;-1</span><span class="org-comment-delimiter"> */</span>
<span class="org-type">int</span> <span class="org-function-name">kill</span>(<span class="org-type">pid_t</span> <span class="org-variable-name">pid</span>,<span class="org-type">init</span> <span class="org-variable-name">signo</span>);
<span class="org-comment-delimiter">/* </span><span class="org-comment">&#25104;&#21151;&#36820;&#22238;0,&#20986;&#38169;&#36820;&#22238;-1</span><span class="org-comment-delimiter"> */</span>
<span class="org-type">int</span> <span class="org-function-name">raise</span>(<span class="org-type">int</span> <span class="org-variable-name">signo</span>);
</pre>
</div>

<p>
kill的pid参数有4种不同的情况:
</p>
<dl class="org-dl">
<dt>pid &gt; 0</dt><dd>将信号发送給进程号为pid的进程</dd>
<dt>pid == 0</dt><dd>将信号发送給与该进程 <b>同一个进程组的</b> 的所有进程.(不包括系统定义的系统进程集)</dd>
<dt>pid &lt; 0</dt><dd>发送信号給 <b>进程组ID为pid绝对值</b> 的所有进程</dd>
<dt>pid == -1</dt><dd>将信号发送给 <b>系统中有权限向它们发送信号的所有进程</b>. 同样不包括系统进程</dd>
</dl>

<p>
进程不能随意对其他进程发起信号,发起信号的规则是:
</p>
<ul class="org-ul">
<li>超级用户权限的进程可以对任一进程发起信号</li>
<li>发送者的实际或有效用户ID必须等于接受者的实际或有效用户ID</li>
<li>若系统支持_POSIX_SAVED_IDS,则系统检查接受者的实际用户ID和保存设置用户ID</li>
<li>若发送的信号是 <b>SIGCONT</b> 则进程可以将它发送給属于 <b>同一会话</b> 的任何其他进程</li>
</ul>

<p>
若signo参数为0,则kill仍检查是否能发送信号給指定进程,但并不实际发送信号. 
这通常用来确定一个特定进程是否仍然存在. 若不存在则kill返回-1,并将errno设置为ESRCH
但,由于这种测试不具有原子性,在kill向调用者返回结果的过程中,被测试进程可能已经终止,因此这种测试意义不大.
</p>
</div>
</div>
<div id="outline-container-orgd7742bd" class="outline-2">
<h2 id="orgd7742bd"><span class="section-number-2">9</span> alarm设置计时器</h2>
<div class="outline-text-2" id="text-9">
<p>
alarm函数设置一个定时器,当定时器超时后会产生SIGALRM信号. 系统的默认动作是终止调用该alarm函数的进程
</p>
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;unistd.h&gt;</span>

<span class="org-comment-delimiter">/* </span><span class="org-comment">&#36820;&#22238;0,&#25110;&#20197;&#21069;&#35774;&#32622;&#30340;&#38393;&#38083;&#26102;&#38388;&#30340;&#21097;&#20313;&#31186;&#25968;</span><span class="org-comment-delimiter"> */</span>
<span class="org-type">unsigned</span> <span class="org-type">int</span> <span class="org-function-name">alarm</span>(<span class="org-type">unsigned</span> <span class="org-type">int</span> <span class="org-variable-name">seconds</span>);
</pre>
</div>

<ul class="org-ul">
<li>需要注意的是,由于信号由内核产生,再加上进程调度的延迟,所以进程真正收到信号还需要一些时间.</li>

<li><b>每个进程只能有一个闹铃</b></li>

<li><b>若参数seconds值为0,则表示取消以前的闹铃</b>,并返回剩余秒数</li>
</ul>
</div>
</div>
<div id="outline-container-orge7702dd" class="outline-2">
<h2 id="orge7702dd"><span class="section-number-2">10</span> pause函数挂起进程</h2>
<div class="outline-text-2" id="text-10">
<p>
pause函数使调用进程挂起直至捕获到一个信号
</p>
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;unistd.h&gt;</span>

<span class="org-comment-delimiter">/* </span><span class="org-comment">&#36820;&#22238;-1,&#19988;errno&#20026;EINTR</span><span class="org-comment-delimiter"> */</span>
<span class="org-type">int</span> <span class="org-function-name">pause</span>();
</pre>
</div>

<p>
只有执行了一个信号处理函数并从其返回时,pause函数返回. 并且返回值为-1,errno为EINTR
</p>

<p>
使用alarm和pause,进程可以使自己休眠一段时间,但是要注意调用alarm和pause之间有一个竞争条件. 即有可能alarm在调用pause之前就超时了.
</p>

<p>
除了用来实现sleep函数外,alarm还常用于对可能阻塞的操作设置时间上限值.
</p>
</div>
</div>
<div id="outline-container-org78960bc" class="outline-2">
<h2 id="org78960bc"><span class="section-number-2">11</span> 信号集</h2>
<div class="outline-text-2" id="text-11">
<p>
当我们在调用sigprocmask来告诉内核暂时阻塞哪些信号传递給进程时,需要一种方式来一次传递多个信号的集合. 
</p>

<p>
由于信号种类的数量可能超过一个整型量所包含的位数,所以不能用整型量中的一位代表一种信号,也就不能用一个整型量表示信号集. 
</p>

<p>
POSIX.1定义了数据类型 <b>sigset_t</b> 来表示信号集,并定义了下列5个处理信号集的函数
</p>
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;signal.h&gt;</span>

<span class="org-comment-delimiter">/* </span><span class="org-comment">&#20197;&#28165;&#31354;&#25152;&#26377;&#20449;&#21495;&#30340;&#26041;&#24335;,&#21021;&#22987;&#21270;&#20449;&#21495;&#38598;</span><span class="org-comment-delimiter"> */</span>
<span class="org-type">int</span> <span class="org-function-name">sigemptyset</span>(<span class="org-type">sigset_t</span> *<span class="org-variable-name">set</span>);

<span class="org-comment-delimiter">/* </span><span class="org-comment">&#20197;&#21253;&#21547;&#25152;&#26377;&#20449;&#21495;&#30340;&#26041;&#24335;,&#21021;&#22987;&#21270;&#20449;&#21495;&#38598;</span><span class="org-comment-delimiter"> */</span>
<span class="org-type">int</span> <span class="org-function-name">sigfillset</span>(<span class="org-type">sigset_t</span> *<span class="org-variable-name">set</span>);

<span class="org-comment-delimiter">/* </span><span class="org-comment">&#28155;&#21152;&#29305;&#23450;&#20449;&#21495;</span><span class="org-comment-delimiter"> */</span>
<span class="org-type">int</span> <span class="org-function-name">sigaddset</span>(<span class="org-type">sigset_t</span>* <span class="org-variable-name">set</span>,<span class="org-type">int</span> <span class="org-variable-name">signo</span>);

<span class="org-comment-delimiter">/* </span><span class="org-comment">&#21024;&#38500;&#29305;&#23450;&#20449;&#21495;</span><span class="org-comment-delimiter"> */</span>
<span class="org-type">int</span> <span class="org-function-name">sigdelset</span>(<span class="org-type">sigset_t</span>* <span class="org-variable-name">set</span>,<span class="org-type">int</span> <span class="org-variable-name">signo</span>);

<span class="org-comment-delimiter">/* </span><span class="org-comment">signo&#26159;&#21542;&#21253;&#21547;&#22312;set&#20449;&#21495;&#38598;&#20013;</span><span class="org-comment-delimiter"> */</span>
<span class="org-type">int</span> <span class="org-function-name">sigismember</span>(<span class="org-keyword">const</span> <span class="org-type">sigset_t</span>* <span class="org-variable-name">set</span>,<span class="org-type">int</span> <span class="org-variable-name">signo</span>);

</pre>
</div>
</div>
</div>
<div id="outline-container-org038ce1a" class="outline-2">
<h2 id="org038ce1a"><span class="section-number-2">12</span> sigprocmask函数</h2>
<div class="outline-text-2" id="text-12">
<p>
sigprocmask函数可以检测或更改进程的信号屏蔽字,该进程屏蔽字告诉内核阻塞哪些信号传递給该进程.
</p>
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;signal.h&gt;</span>

<span class="org-type">int</span> <span class="org-function-name">sigprocmask</span>(<span class="org-type">int</span> <span class="org-variable-name">how</span>, <span class="org-keyword">const</span> <span class="org-type">sigset_t</span>* <span class="org-variable-name">set</span>,<span class="org-type">sigset_t</span>* <span class="org-variable-name">old_set</span>);
</pre>
</div>
<ul class="org-ul">
<li>若old_set不为NULL,则通过old_set返回进程当前的信号屏蔽字</li>
<li><p>
若set不为NULL,则参数how指明了如何修改当前信号屏蔽字.
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">how</th>
<th scope="col" class="org-left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">SIG_BLOCK</td>
<td class="org-left">新阻塞set表示的信号集</td>
</tr>

<tr>
<td class="org-left">SIG_UNBLOCK</td>
<td class="org-left">不再阻塞set表示的信号集</td>
</tr>

<tr>
<td class="org-left">SIG_SETMASK</td>
<td class="org-left">设置进程的新信号屏蔽字为set所表示的信号集</td>
</tr>
</tbody>
</table></li>
<li>若参数set为NULL,则并不改变该进程的信号屏蔽字,参数how也无意义.</li>
<li><p>
<b>在调用sigprocmask后,如果有任何未决的,不再阻塞的信号,则在sigprocmask返回前,至少将其中一个信号递送給该进程(不明白什么意思&#x2026;)</b>
</p>
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;signal.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;unistd.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;stdio.h&gt;</span>

<span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">sig_quit</span>(<span class="org-type">int</span>);

<span class="org-type">int</span> <span class="org-function-name">main</span>()
{
  <span class="org-type">sigset_t</span> <span class="org-variable-name">newmask</span>,<span class="org-variable-name">oldmask</span>,<span class="org-variable-name">pendmask</span>;

  signal(SIGQUIT,sig_quit);
  sigemptyset(&amp;newmask);
  sigaddset(&amp;newmask,SIGQUIT);

  sigprocmask(SIG_BLOCK,&amp;newmask,&amp;oldmask); <span class="org-comment-delimiter">/* </span><span class="org-comment">&#38459;&#22622;SIGQUIT</span><span class="org-comment-delimiter"> */</span>

  raise(SIGQUIT);               <span class="org-comment-delimiter">/* </span><span class="org-comment">&#20135;&#29983;SIGQUIT&#20449;&#21495;</span><span class="org-comment-delimiter"> */</span>

  sigpending(&amp;pendmask);        <span class="org-comment-delimiter">/* </span><span class="org-comment">&#26597;&#30475;&#21738;&#20123;&#20449;&#21495;&#34987;&#38459;&#22622;</span><span class="org-comment-delimiter"> */</span>

  <span class="org-keyword">if</span>(sigismember(&amp;pendmask,SIGQUIT)){
    printf(<span class="org-string">"SIGQUIT pending\n"</span>);
  }

  sigprocmask(SIG_SETMASK,&amp;oldmask,<span class="org-constant">NULL</span>); <span class="org-comment-delimiter">/* </span><span class="org-comment">&#22312;&#35813;&#20989;&#25968;&#36820;&#22238;&#21069;,raise&#20135;&#29983;&#30340;SIGQUIT&#20250;&#21457;&#36865;&#21040;&#35813;&#36827;&#31243;,&#36827;&#32780;&#35302;&#21457;&#20989;&#25968;sig_quit</span><span class="org-comment-delimiter"> */</span>
  printf(<span class="org-string">"SIGQUIT unblocked\n"</span>);
  <span class="org-keyword">return</span> 0;
}

<span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">sig_quit</span>(<span class="org-type">int</span> <span class="org-variable-name">signo</span>)
{
  printf(<span class="org-string">"caught SIGOUT\n"</span>);
}
</pre>
</div></li>

<li><b>sigprocmask是线程不安全的!</b></li>
</ul>
</div>
</div>

<div id="outline-container-org821b12e" class="outline-2">
<h2 id="org821b12e"><span class="section-number-2">13</span> sigpendng函数</h2>
<div class="outline-text-2" id="text-13">
<p>
sigpending函数返回当前应该传递給进程但被阻塞的信号集合
</p>
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;signal.h&gt;</span>

<span class="org-type">int</span> <span class="org-function-name">sigpending</span>(<span class="org-type">sigset_t</span>* <span class="org-variable-name">set</span>);
</pre>
</div>
<p>
注意区分与sigprocmask函数的区别
</p>
<ul class="org-ul">
<li>sigprocmask返回的是哪些信号将会被阻塞</li>
<li>ssigpending函数返回的是哪些函数已经被阻塞了.</li>
</ul>
</div>
</div>

<div id="outline-container-org69a2c84" class="outline-2">
<h2 id="org69a2c84"><span class="section-number-2">14</span> sigaction函数</h2>
<div class="outline-text-2" id="text-14">
<p>
sigaction函数检查或修改与指定信号相关联的处理动作, 其被取代UNIX早期版本中的signal函数
</p>
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;signal.h&gt;</span>

<span class="org-type">int</span> <span class="org-function-name">sigaction</span>(<span class="org-type">int</span> <span class="org-variable-name">signo</span>,<span class="org-keyword">const</span> <span class="org-keyword">struct</span> <span class="org-type">sigaction</span>* <span class="org-variable-name">act</span>,<span class="org-keyword">struct</span> <span class="org-type">sigaction</span>* <span class="org-variable-name">old_act</span>);
<span class="org-keyword">struct</span> <span class="org-type">sigaction</span>{
  <span class="org-type">void</span> (*<span class="org-function-name">sa_handler</span>)(<span class="org-type">int</span> <span class="org-variable-name">signo</span>);      <span class="org-comment-delimiter">/* </span><span class="org-comment">signal&#22788;&#29702;&#20989;&#25968;&#30340;&#22320;&#22336;,&#25110;SIG_IGN,SIG_DFL</span><span class="org-comment-delimiter"> */</span>
  <span class="org-type">sigset_t</span> <span class="org-variable-name">sa_mask</span>;             <span class="org-comment-delimiter">/* </span><span class="org-comment">&#35843;&#29992;sa_handler&#26102;&#35201;&#26032;&#38459;&#22622;&#30340;&#20449;&#21495;&#38598;</span><span class="org-comment-delimiter"> */</span>
  <span class="org-type">int</span> <span class="org-variable-name">sa_flags</span>;                 <span class="org-comment-delimiter">/* </span><span class="org-comment">&#20854;&#20182;&#25805;&#20316;&#26631;&#24535;</span><span class="org-comment-delimiter"> */</span>
  <span class="org-type">void</span> (*<span class="org-function-name">sa_sigaction</span>)(<span class="org-type">int</span> <span class="org-variable-name">signo</span>,<span class="org-type">siginfo_t</span>* <span class="org-variable-name">iinfo</span>,<span class="org-type">void</span>* <span class="org-variable-name">context</span>);
};
</pre>
</div>
<ul class="org-ul">
<li>参数signo是要检测或修改其具体动作的信号编号</li>
<li>若参数act不为NULL,则根据act修改信号signo的处理函数.</li>
<li>若参数old_act不为NULL,则保存该信号的原处理函数.</li>
</ul>
</div>
<div id="outline-container-org1fecbbf" class="outline-3">
<h3 id="org1fecbbf"><span class="section-number-3">14.1</span> 参数act的说明</h3>
<div class="outline-text-3" id="text-14-1">
<ul class="org-ul">
<li>sa_handler为信号处理函数的地址,当收到信号signo时,转到该函数来处理</li>
<li>参数sa_mask为一个信号集,该信号集会在调用sa_handler之前被 <b>临时加入到进程的信号屏蔽字中,并在从sa_handler返回时再将进程的信号屏蔽字还原</b>. 这样在调用信号处理函数时就能阻塞某些信号.</li>
<li>为了防止sa_handler在处理信号signo时,该信号再次发生造成信号丢失,sa_handler被调用时,操作系统建立的新信号屏蔽字会包含正在传递的信号signo</li>
<li><p>
sa_flags指定了对信号进行处理的各个选项,各选项可以使用`|'组合
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">sa_flag</td>
<td class="org-left">说明</td>
</tr>

<tr>
<td class="org-left">SA_INTERRUPT</td>
<td class="org-left">被信号中断的系统调用不会自动重启动</td>
</tr>

<tr>
<td class="org-left">SA_NOCLDSTOP</td>
<td class="org-left">当子进程停止时不产生SIGCHLD信号,同时若停止的进程继续运行时,也不发送SIGCHLD信号</td>
</tr>

<tr>
<td class="org-left">SA_NOCLDWAIT</td>
<td class="org-left">子进程终止时,并不创建僵死进程,并不发送SIGCHLD信号</td>
</tr>

<tr>
<td class="org-left">SA_NODEFER</td>
<td class="org-left">在执行sa_handler时,并不自动阻塞当前signo,此时的操作对应于早期的不可靠信号</td>
</tr>

<tr>
<td class="org-left">SA_ONSTACK</td>
<td class="org-left">若sigaltstack函数声明了替换栈,则将该信号发送到替换栈上的进程</td>
</tr>

<tr>
<td class="org-left">SA_RESETHAND</td>
<td class="org-left">在执行sa_handler前,将信号处理方式复位为SIG_DFL,并清除SA_SIGINFO标志</td>
</tr>

<tr>
<td class="org-left">SA_RESTART</td>
<td class="org-left">被信号中断的系统调用会自动重启动, <b>默认不重启!</b></td>
</tr>

<tr>
<td class="org-left">SA_SIGINFO</td>
<td class="org-left">该选项使用sa_sigaction代替sa_handler作为信号处理函数.</td>
</tr>
</tbody>
</table></li>
</ul>
</div>
</div>
<div id="outline-container-org0e66722" class="outline-3">
<h3 id="org0e66722"><span class="section-number-3">14.2</span> 函数sa_sigaction说明</h3>
<div class="outline-text-3" id="text-14-2">
<p>
当在sigaction结构中使用了SA_SIGINFO标志时,使用sa_sigaction信号处理程序. 该函数接收两个附加参数:
</p>
<ul class="org-ul">
<li><p>
siginfo结构的指针包含了信号产生的原因相关信息
</p>
<div class="org-src-container">
<pre class="src src-C"><span class="org-keyword">struct</span> <span class="org-type">siginfo</span>{
  <span class="org-type">int</span> <span class="org-variable-name">si_signo</span>;                 <span class="org-comment-delimiter">/* </span><span class="org-comment">signal&#32534;&#21495;</span><span class="org-comment-delimiter"> */</span>
  <span class="org-type">int</span> <span class="org-variable-name">si_errno</span>;
  <span class="org-type">int</span> <span class="org-variable-name">si_code</span>;                  <span class="org-comment-delimiter">/* </span><span class="org-comment">signal&#30340;&#36827;&#19968;&#27493;&#35828;&#26126;</span><span class="org-comment-delimiter"> */</span>
  <span class="org-type">pid_t</span> <span class="org-variable-name">si_pid</span>;                 <span class="org-comment-delimiter">/* </span><span class="org-comment">&#21457;&#36865;&#20449;&#21495;&#30340;&#36827;&#31243;&#21495;</span><span class="org-comment-delimiter"> */</span>
  <span class="org-type">uid_t</span> <span class="org-variable-name">si_uid</span>;                 <span class="org-comment-delimiter">/* </span><span class="org-comment">&#21457;&#36865;&#20449;&#21495;&#36827;&#31243;&#30340;&#23454;&#38469;&#29992;&#25143;id</span><span class="org-comment-delimiter"> */</span>
  <span class="org-type">void</span>* <span class="org-variable-name">si_addr</span>;                <span class="org-comment-delimiter">/* </span><span class="org-comment">&#24341;&#36215;fault&#30340;&#20869;&#23384;&#22320;&#22336;</span><span class="org-comment-delimiter"> */</span>
  <span class="org-type">int</span> <span class="org-variable-name">si_status</span>;                <span class="org-comment-delimiter">/* </span><span class="org-comment">signal&#32534;&#21495;&#25110;&#36864;&#20986;&#20540;</span><span class="org-comment-delimiter"> */</span>
  <span class="org-type">long</span> <span class="org-variable-name">si_band</span>;                 <span class="org-comment-delimiter">/* </span><span class="org-comment">SIGPOLL&#30340;band number,&#21363;STREAMS&#28040;&#24687;&#30340;&#20248;&#20808;&#32423;&#27573;</span><span class="org-comment-delimiter"> */</span>
};
</pre>
</div></li>
<li>一个指向进程上下文标识符的指针,可强制转换为ucntext_t结构类型</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org6625a11" class="outline-2">
<h2 id="org6625a11"><span class="section-number-2">15</span> sigsetjmp和siglongjmp函数</h2>
<div class="outline-text-2" id="text-15">
<p>
在可靠的信号机制中,当进程捕捉到信号,进入信号处理函数时,当前信号会被自动地加到进程的信号屏蔽字中,此时,若信号处理函数中用longjmp跳出信号处理函数,那么 <b>对此进程的信号屏蔽字是否回退是未定义的</b>.
</p>

<p>
在信号处理函数中进行非局部跳转时 <b>应该使用sigsetjmp和siglongjmp函数代替</b>
</p>
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;setjmp.h&gt;</span>

<span class="org-comment-delimiter">/* </span><span class="org-comment">&#30452;&#25509;&#35843;&#29992;&#36820;&#22238;0,&#20174;siglongjmp&#35843;&#29992;&#36820;&#22238;&#36820;&#22238;&#38750;0</span><span class="org-comment-delimiter"> */</span>
<span class="org-type">ing</span> <span class="org-function-name">sigsetjmp</span>(<span class="org-type">sigjmp_buf</span> <span class="org-variable-name">env</span>, <span class="org-type">int</span> <span class="org-variable-name">savemask</span>);

<span class="org-type">void</span> <span class="org-function-name">siglongjmp</span>(<span class="org-type">sigjmp_buf</span> <span class="org-variable-name">env</span>,<span class="org-type">int</span> <span class="org-variable-name">val</span>);
</pre>
</div>

<p>
这两个函数与setjmp和longjmp之间的唯一区别是sigsetjmp增加了一个参数savemask用于标识是否在env中保存进程的当前信号屏蔽字.
</p>

<p>
若使用非0的savemask参数调用sigsetjmp,则siglongjmp跳转后,会恢复保存的信号屏蔽字
</p>

<p>
由于信号在任何时候都可能发生,因此在信号处理函数中需要用到siglongjmp的话,都需要提供一种保护措施,只有在设置了sigsetjmp后才能用siglongjmp来跳转.
这种保护措施一般通过定义一个 <b>全局的voliatile sig_atomic_t类型的变量</b> 来实现. 仅在调用sigsetjmp后才将该变量设置为非0,在信号处理函数中则检查该值,只有当它非0时才调用siglongjmp
</p>

<p>
数据类型sig_atomic_t是ISO C标准定义的变量类型,这种类型的变量不会被中断.
<b>这种类型的变量总是包括ISO类型修饰符volatile</b>,原因是该变量将由main函数和信号处理函数两个不同的控制线程访问.
</p>
</div>
</div>

<div id="outline-container-orge597d83" class="outline-2">
<h2 id="orge597d83"><span class="section-number-2">16</span> sigsuspend</h2>
<div class="outline-text-2" id="text-16">
<p>
若希望对一个信号接触阻塞,然后通过pause函数休眠以等待被阻塞的信号发生,该如何实现呢?
</p>

<p>
若通过先修改进程信号屏蔽字,再调用pause函数的方法来进行,则由于可能在调用pause函数之前就已经收到信号,从而造成该信号丢失,使得进程永远阻塞下去.
</p>

<p>
解决的方法是提供一个 <b>原子操作,先修改信号屏蔽字,并信号被捕获之前就挂起该进程</b>
</p>
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;signal.h&gt;</span>

<span class="org-comment-delimiter">/* </span><span class="org-comment">&#36820;&#22238;-1,&#24182;&#23558;errno&#35774;&#20026;EINTR</span><span class="org-comment-delimiter"> */</span>
<span class="org-type">int</span> <span class="org-function-name">sigsuspend</span>(<span class="org-keyword">const</span> <span class="org-type">sigset_t</span> *<span class="org-variable-name">sigmask</span>);
</pre>
</div>
<p>
sigsuspend函数临时将进程的信号屏蔽字设置为由sigmask指向的值. 并在捕捉到一个信号或发生了一个会终止该进程的信号之前挂起该进程.
</p>

<p>
该函数仅在进程捕获到信号后返回,并会 <b>恢复原信号屏蔽字</b>
</p>

<p>
<b>但该函数仅当进程等待信号区间休眠时才有用,若想在等待信号期间还能调用其他系统函数,则无法实现完美的解决方案</b>
</p>
</div>
</div>
<div id="outline-container-org6cec838" class="outline-2">
<h2 id="org6cec838"><span class="section-number-2">17</span> abort函数</h2>
<div class="outline-text-2" id="text-17">
<p>
abort函数发送SIGABRT信号到调用进程,并且 <b>不管信号处理函数如何处理,abort都使进程异常终止.</b>
</p>
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;stdlib.h&gt;</span>

<span class="org-type">void</span> <span class="org-function-name">abort</span>();
</pre>
</div>
<p>
一般捕获SIGABRT的目的是执行进程终止之前的清理操作.
</p>
</div>
</div>
<div id="outline-container-org6bd1215" class="outline-2">
<h2 id="org6bd1215"><span class="section-number-2">18</span> 其他特性</h2>
<div class="outline-text-2" id="text-18">
<p>
这些特性依赖于具体的实现
</p>
<ul class="org-ul">
<li><p>
sys_siglist数组变量
</p>
<div class="org-src-container">
<pre class="src src-C"><span class="org-keyword">extern</span> <span class="org-type">char</span>* <span class="org-variable-name">sys_siglist</span>[];
</pre>
</div>
<p>
数组下表是信号编号,指向一个信号字符串名称
</p></li>
<li><p>
psignal函数
</p>
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;signal.h&gt;</span>

<span class="org-type">void</span> <span class="org-function-name">psignal</span>(<span class="org-type">int</span> <span class="org-variable-name">signo</span>,<span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">msg</span>);
</pre>
</div>
<p>
类似perror,将字符串msg输出到stderr,后接`: ',再接对信号的说明,最后一个回车
</p></li>
<li><p>
strsignal函数
</p>
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;string.h&gt;</span>

<span class="org-type">char</span>* <span class="org-function-name">strsignal</span>(<span class="org-type">int</span> <span class="org-variable-name">signo</span>);
</pre>
</div>
<p>
类似strerrno,根据信号编号返回说明信号的字符串
</p></li>
</ul>
</div>
<div id="outline-container-org79a7f02" class="outline-3">
<h3 id="org79a7f02"><span class="section-number-3">18.1</span> </h3>
</div>
</div>

</div>
</div>
<div>
  <div class="post-meta">
    <span title="post date" class="post-info">2015-05-22</span>
    <span title="last modification date" class="post-info">2016-10-24</span>
    <span title="tags" class="post-info">N/A</span>
    <span title="author" class="post-info">DarkSun</span>
  </div>
  <script src="../../../../../media/js/jquery-2.1.3.min.js"></script>
  <script src="../../../../../media/js/md5.min.js"></script>
  <section>
      <div id="gitalk-container"></div>
      <script type="text/javascript">
       var gitalk = new Gitalk({
           clientID: 'fdcb5d9da3f4acb4862c',
           clientSecret: 'dd0a16312a206782cb7669dcec5e96874ab48170',
           repo: 'lujun9972.github.com',
           owner: 'lujun9972',
           admin: ['lujun9972'],
           id: md5(location.pathname),      // Ensure uniqueness and length less than 50
           distractionFreeMode: false  // Facebook-like distraction free mode
       })
       gitalk.render('gitalk-container')
      </script>
  </section>
  <script src="../../../../../media/js/kdComment.js"></script>
      <script>
       var _hmt = _hmt || [];
       (function() {
           var hm = document.createElement("script");
           hm.src = "https://hm.baidu.com/hm.js?7bac4fd0247f69c27887e0d4e3aee41e";
           var s = document.getElementsByTagName("script")[0]; 
           s.parentNode.insertBefore(hm, s);
       })();
      </script>
  <div class="footer">
    <p>Generated by <a href="http://www.gnu.org/software/emacs/">Emacs</a> 27.x(<a href="http://orgmode.org">Org mode</a> 9.x)</p>
    <p>
      Copyright &copy; 2014 - <span id="footerYear"></span> <a href="mailto:travis &lt;at&gt; travis-job-adabab64-65f3-4ed4-bd6c-a1638c380b0d">DarkSun</a>
      &nbsp;&nbsp;-&nbsp;&nbsp;
      Powered by <a href="https://github.com/emacs-china/EGO" target="_blank">EGO</a><br/>
      Themed with <a href="https://github.com/kuangdash/emacs_love" target="_blank">emacs_love</a>
        <a href="http://creativecommons.org/licenses/by-sa/3.0/" rel="license"><img src="https://licensebuttons.net/l/by-sa/3.0/88x31.png" style="border-width:0" alt="Creative Commons License" class="center"></a>
      <script type="text/javascript">document.getElementById("footerYear").innerHTML = (new Date()).getFullYear();</script>
    </p>
  </div>
    </div>

  </body>
</html>
