<!DOCTYPE html>
<html lang="en">
<head>
  <title>文件和目录 - 暗无天日</title>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <meta name="author" content="DarkSun" />
  <style>
   #ds-thread #ds-reset .ds-comment-body p {color: #ffffff;}
   #disqus_thread a {color: #00ffff;}
  </style>
  <link rel="stylesheet" media="screen" href="../../../../../media/css/font.css" rel="stylesheet" type="text/css"/>
  <link rel="stylesheet" href="../../../../../media/css/main.css" type="text/css">
  <link rel="stylesheet" href="../../../../../media/css/org-src-fontify.css" type="text/css">
  <link rel="stylesheet" href="../../../../../media/css/kdComment.css" type="text/css">
  <script type="text/javascript"
          src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
  <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
</head>

  <body class="container">
<div>
  <header class="masthead">
    <h1 class="masthead-title"><a href="../../../../../">暗无天日</a></h1>
    <p>=============&gt;随便,谢谢</p>
    <nav class="site-nav">
      <div class="menu-icon">
      </div>
      <ul class="trigger">
              <li><a href="../../../../../years/">Years</a></li>
              <li><a href="../../../../../tags/">Tags</a></li>
              <li><a href="../../../../../about/">About</a></li>
              <li><a href="https://github.com/lujun9972/lujun9972.github.com.git">Github</a></li>
              <li><a href="../../../../../rss.xml">RSS</a></li>
      </ul>
    </nav>
    <form method="get" id="searchform" action="http://www.google.com/search">
        <input type="text" class="field" name="q" id="s" placeholder="Search">
        <input type="hidden" name="as_sitesearch" value="lujun9972.github.io">
    </form>
  </header>
</div>

<div>
<div class="post">
<h1 class="title">文件和目录</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgdd992ff">1. stat,fstat和lstat函数</a></li>
<li><a href="#orgc31fd6c">2. UNIX中的文件类型</a></li>
<li><a href="#orgc62839f">3. 关于文件的访问权限</a>
<ul>
<li><a href="#org97d11bc">3.1. 用户ID与组ID</a>
<ul>
<li><a href="#orgc69f351">3.1.1. 与一个进程相关联的ID有:</a></li>
</ul>
</li>
<li><a href="#orgd9334cb">3.2. 访问权限与测试宏</a></li>
<li><a href="#org51b21de">3.3. 关于访问权限的一些说明</a></li>
<li><a href="#org9a356e7">3.4. access函数:使用实际权限执行权限测试</a></li>
<li><a href="#org0eade9e">3.5. umask函数:为进程设置创建文件权限的屏蔽字</a></li>
<li><a href="#orgcb5e86a">3.6. chmod/fchmod函数:更改现有文件的访问权限</a></li>
<li><a href="#org02a261b">3.7. 关于粘住位的说明</a></li>
<li><a href="#org3e00444">3.8. chown/fchown/lchown函数更改文件的用户ID和组DI</a></li>
</ul>
</li>
<li><a href="#org26f5221">4. 关于文件长度</a>
<ul>
<li><a href="#orga45ef4c">4.1. 文件中的空洞</a></li>
<li><a href="#org63d287b">4.2. truncate函数:截断文件</a></li>
</ul>
</li>
<li><a href="#org92d9d31">5. 关于文件操作</a>
<ul>
<li><a href="#orgc454ed2">5.1. link函数:创建指向现有文件的链接</a></li>
<li><a href="#orgad20c16">5.2. unlink函数:删除指向文件的链接</a></li>
<li><a href="#org7331b81">5.3. remove函数:删除一个对文件或目录的链接</a></li>
<li><a href="#org08d0883">5.4. remove函数:对文件进行改名</a></li>
</ul>
</li>
<li><a href="#org5dc59e5">6. 符号链接</a>
<ul>
<li><a href="#org21d6dec">6.1. symlink函数:创建符号链接</a></li>
<li><a href="#org30a9ff0">6.2. readlink函数:读取符号链接本身</a></li>
</ul>
</li>
<li><a href="#org75d99eb">7. 文件的时间</a>
<ul>
<li><a href="#orgd6c9a9d">7.1. 三个时间属性的意义</a></li>
<li><a href="#org429e968">7.2. utime函数:修改文件数据的访问时间和修改时间</a></li>
</ul>
</li>
<li><a href="#org877d146">8. 目录操作</a>
<ul>
<li><a href="#orgaa32240">8.1. mkdir:创建目录</a></li>
<li><a href="#org4d11a78">8.2. rmdir:删除目录</a></li>
<li><a href="#orgb7afd46">8.3. 读目录参数</a></li>
<li><a href="#org31a4f4c">8.4. chdir/fchdir:修改进程的当前工作目录</a></li>
<li><a href="#org44f0806">8.5. getcwd:获取当前工作目录</a></li>
</ul>
</li>
<li><a href="#org5953516">9. 设备特殊文件</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgdd992ff" class="outline-2">
<h2 id="orgdd992ff"><span class="section-number-2">1</span> stat,fstat和lstat函数</h2>
<div class="outline-text-2" id="text-1">
<p>
stat系列函数返回与文件相关的信息结构
</p>
<div class="org-src-container">
<pre class="src src-c"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;sys/stat.h&gt;</span>

<span class="org-type">int</span> <span class="org-function-name">stat</span>(<span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">path</span>,<span class="org-keyword">struct</span> <span class="org-type">stat</span>* <span class="org-variable-name">buf</span>);
<span class="org-type">int</span> <span class="org-function-name">fstat</span>(<span class="org-type">int</span> <span class="org-variable-name">filedes</span>,<span class="org-keyword">struct</span> <span class="org-type">stat</span>* <span class="org-variable-name">buf</span>);
<span class="org-type">int</span> <span class="org-function-name">lstat</span>(<span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">path</span>,<span class="org-keyword">struct</span> <span class="org-type">stat</span>* <span class="org-variable-name">buf</span>);
</pre>
</div>

<p>
其中fstat通过文件描述符来获取文件信息.
</p>

<p>
lstat在读取符号连接文件时,获取符号连接文件本身的属性.
</p>
</div>
</div>

<div id="outline-container-orgc31fd6c" class="outline-2">
<h2 id="orgc31fd6c"><span class="section-number-2">2</span> UNIX中的文件类型</h2>
<div class="outline-text-2" id="text-2">
<dl class="org-dl">
<dt>普通文件</dt><dd>S_ISREG(st_mode)判断</dd>
<dt>目录文件</dt><dd>S_ISDIR(st_mode)判断</dd>
<dt>块特殊文件</dt><dd>S_ISCHR(st_mode)判断</dd>
<dt>字符特殊文件</dt><dd>S_ISBLK(st_mode)判断</dd>
<dt>FIFO命名管道文件</dt><dd>S_ISFIFO(st_mode)判断</dd>
<dt>socket套接字文件</dt><dd>S_ISLNK(st_mode)判断</dd>
<dt>符号链接文件</dt><dd>S_ISSOCK(st_mode)判断</dd>
<dt>消息队列</dt><dd>S_TYPEISMQ(stat*)判断</dd>
<dt>信号量</dt><dd>S_TYPEISSEM(stat*)判断</dd>
<dt>共享存储对象</dt><dd>S_TYPEISSHM(stat*)判断</dd>
</dl>
</div>
</div>
<div id="outline-container-orgc62839f" class="outline-2">
<h2 id="orgc62839f"><span class="section-number-2">3</span> 关于文件的访问权限</h2>
<div class="outline-text-2" id="text-3">
</div>
<div id="outline-container-org97d11bc" class="outline-3">
<h3 id="org97d11bc"><span class="section-number-3">3.1</span> 用户ID与组ID</h3>
<div class="outline-text-3" id="text-3-1">
</div>
<div id="outline-container-orgc69f351" class="outline-4">
<h4 id="orgc69f351"><span class="section-number-4">3.1.1</span> 与一个进程相关联的ID有:</h4>
<div class="outline-text-4" id="text-3-1-1">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">实际用户ID</td>
<td class="org-left">我们实际上是谁?</td>
</tr>

<tr>
<td class="org-left">实际组ID</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">有效用户ID</td>
<td class="org-left">用于文件访问权限检查</td>
</tr>

<tr>
<td class="org-left">有效组ID</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">附加组ID</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">保存的设置用户ID</td>
<td class="org-left">由exec函数保存的有效用户ID</td>
</tr>

<tr>
<td class="org-left">保存的设置组ID</td>
<td class="org-left">由exec函数保存的有效用户组ID</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div id="outline-container-orgd9334cb" class="outline-3">
<h3 id="orgd9334cb"><span class="section-number-3">3.2</span> 访问权限与测试宏</h3>
<div class="outline-text-3" id="text-3-2">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">意义</th>
<th scope="col" class="org-left">st_mode宏</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">用户-读</td>
<td class="org-left">S_IRUSR</td>
</tr>

<tr>
<td class="org-left">用户-写</td>
<td class="org-left">S_IWUSR</td>
</tr>

<tr>
<td class="org-left">用户-执行</td>
<td class="org-left">S_IXUSR</td>
</tr>

<tr>
<td class="org-left">组-读</td>
<td class="org-left">S_IRGRP</td>
</tr>

<tr>
<td class="org-left">组-写</td>
<td class="org-left">S_IWGRP</td>
</tr>

<tr>
<td class="org-left">组-执行</td>
<td class="org-left">S_IXGRP</td>
</tr>

<tr>
<td class="org-left">其他-读</td>
<td class="org-left">S_IROTH</td>
</tr>

<tr>
<td class="org-left">其他-写</td>
<td class="org-left">S_IWOTH</td>
</tr>

<tr>
<td class="org-left">其他-执行</td>
<td class="org-left">S_IXOTH</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-org51b21de" class="outline-3">
<h3 id="org51b21de"><span class="section-number-3">3.3</span> 关于访问权限的一些说明</h3>
<div class="outline-text-3" id="text-3-3">
<ul class="org-ul">
<li>目录的读权限允许我们获得在该目录中所有文件名的列表,但要访问其中的文件时,则需要有该目录的 <b>执行</b> 权限.</li>
<li>必须对目录具有 <b>写和执行</b> 权限,才能增加/删除目录下的文件</li>
<li>删除一个文件,不需要对文件本身具有读写权限</li>
<li>若某进程时文件的所有者,则只会根据用户权限判断对文件的操作是否合法, <b>而不会查看组访问权限和其他访问权限</b>. 类似的若进程属于文件的某个组,则根据组权限判断对文件的操作是否合法, <b>而不去判断</b></li>
<li>当用进程取创建新文件/目录时,文件/目录的用户ID为进程的 <b>有效用户ID</b></li>
<li>当用进程取创建新文件/目录时,文件/目录的组ID为 <b>进程的有效组ID</b> 或 <b>所在目录的组ID</b></li>
</ul>
</div>
</div>
<div id="outline-container-org9a356e7" class="outline-3">
<h3 id="org9a356e7"><span class="section-number-3">3.4</span> access函数:使用实际权限执行权限测试</h3>
<div class="outline-text-3" id="text-3-4">
<p>
默认情况下,进程使用有效用户ID/有效组ID来执行对文件的权限测试. 但也可以使用access函数来让进程根据 <b>实际用户/组权限</b> 进行测试:
</p>
<div class="org-src-container">
<pre class="src src-c"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;unistd.h&gt;</span>
<span class="org-type">int</span> <span class="org-function-name">access</span> (<span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">path</span>,<span class="org-type">int</span> <span class="org-variable-name">mode</span>)
</pre>
</div>

<p>
其中mode的可选值为:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">mode</th>
<th scope="col" class="org-left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">R_OK</td>
<td class="org-left">测试读权限</td>
</tr>

<tr>
<td class="org-left">W_OK</td>
<td class="org-left">测试写权限</td>
</tr>

<tr>
<td class="org-left">X_OK</td>
<td class="org-left">测试执行权限</td>
</tr>

<tr>
<td class="org-left">F_OK</td>
<td class="org-left">测试文件是否存在</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-org0eade9e" class="outline-3">
<h3 id="org0eade9e"><span class="section-number-3">3.5</span> umask函数:为进程设置创建文件权限的屏蔽字</h3>
<div class="outline-text-3" id="text-3-5">
<p>
umask函数为进程设置文件模式创建屏蔽字,并返回以前的值
</p>
<div class="org-src-container">
<pre class="src src-c"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;sys/stat.h&gt;</span>

<span class="org-type">mode_t</span> <span class="org-function-name">umask</span>(<span class="org-type">mode_t</span> <span class="org-variable-name">cmask</span>);
</pre>
</div>
<p>
其中cmask为访问权限那9个st_mode常量中的一个或多个的"或"构成
</p>

<p>
当使用create/open函数创建新文件时,即使mode参数中有设置某个参数,但若使用umask设置了屏蔽该权限,则创建的新文件也不会有该参数.
</p>

<p>
<b>但umask可能会也可能不会修改由内核直接产生的core文件</b>
</p>
</div>
</div>
<div id="outline-container-orgcb5e86a" class="outline-3">
<h3 id="orgcb5e86a"><span class="section-number-3">3.6</span> chmod/fchmod函数:更改现有文件的访问权限</h3>
<div class="outline-text-3" id="text-3-6">
<div class="org-src-container">
<pre class="src src-c"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;sys/stat.h&gt;</span>

<span class="org-type">int</span> <span class="org-function-name">chmod</span>(<span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">path</span>,<span class="org-type">mode_t</span> <span class="org-variable-name">mode</span>);

<span class="org-type">int</span> <span class="org-function-name">fchmod</span>(<span class="org-type">int</span> <span class="org-variable-name">filedes</span>,<span class="org-type">mode_t</span> <span class="org-variable-name">mode</span>);
</pre>
</div>

<p>
chmod函数在指定文件上进程操作,而fchmod函数则对已打开的文件进行操作
</p>

<p>
为了改变文件权限,进程的 <b>有效ID</b> 必须等于文件的所有者ID,或进程具有超级用户权限
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">意义</th>
<th scope="col" class="org-left">st_mode宏</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">用户-读</td>
<td class="org-left">S_IRUSR</td>
</tr>

<tr>
<td class="org-left">用户-写</td>
<td class="org-left">S_IWUSR</td>
</tr>

<tr>
<td class="org-left">用户-执行</td>
<td class="org-left">S_IXUSR</td>
</tr>

<tr>
<td class="org-left">组-读</td>
<td class="org-left">S_IRGRP</td>
</tr>

<tr>
<td class="org-left">组-写</td>
<td class="org-left">S_IWGRP</td>
</tr>

<tr>
<td class="org-left">组-执行</td>
<td class="org-left">S_IXGRP</td>
</tr>

<tr>
<td class="org-left">其他-读</td>
<td class="org-left">S_IROTH</td>
</tr>

<tr>
<td class="org-left">其他-写</td>
<td class="org-left">S_IWOTH</td>
</tr>

<tr>
<td class="org-left">其他-执行</td>
<td class="org-left">S_IXOTH</td>
</tr>

<tr>
<td class="org-left">执行时设置用户ID</td>
<td class="org-left">S_ISUID</td>
</tr>

<tr>
<td class="org-left">执行时设置组ID</td>
<td class="org-left">S_ISGID</td>
</tr>

<tr>
<td class="org-left">设置粘住位</td>
<td class="org-left">S_ISVTX</td>
</tr>
</tbody>
</table>

<p>
注意:由于新建文件的组ID可能时父目录的组ID,因此新创建的组ID可能并不是调用进程所示的组. 因此,为了安全,当新文件的组ID不属于进程的有效组ID或进程附加组ID中的一个,或进程没有超级用户权限时,那么设置组ID位会自动被关闭. 这就防止了用户创建一个设置组ID文件,而该文件是由并非该用户所属的组所拥有的.
</p>
</div>
</div>
<div id="outline-container-org02a261b" class="outline-3">
<h3 id="org02a261b"><span class="section-number-3">3.7</span> 关于粘住位的说明</h3>
<div class="outline-text-3" id="text-3-7">
<p>
若对一个可执行文件设置了粘住位,则该程序第一次执行并结束后,其程序的指令部分仍然会保存在交换区中,由于交换区占用连续的磁盘空间,因此下次载入该程序会更快一些.
</p>

<p>
若对一个目录设置了粘住位,则只有对该目录具有写权限的用户满足以下之一的条件时才允许或更名该目录下的文件
</p>
<ul class="org-ul">
<li>拥有此文件</li>
<li>拥有此目录</li>
<li>是超级用户</li>
</ul>

<p>
对目录设置粘住位的一个典型目录是/tmp目录,任何人都能够在其目录下创建文件,但用户不能删除/更名其他用户的文件.
</p>
</div>
</div>
<div id="outline-container-org3e00444" class="outline-3">
<h3 id="org3e00444"><span class="section-number-3">3.8</span> chown/fchown/lchown函数更改文件的用户ID和组DI</h3>
<div class="outline-text-3" id="text-3-8">
<div class="org-src-container">
<pre class="src src-c"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;unistd.h&gt;</span>

<span class="org-type">int</span> <span class="org-function-name">chown</span>(<span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">path</span>,<span class="org-type">uid_t</span> <span class="org-variable-name">owner</span>,<span class="org-type">gid_t</span> <span class="org-variable-name">group</span>)
<span class="org-type">int</span> <span class="org-function-name">fchown</span>(<span class="org-type">int</span> <span class="org-variable-name">filedes</span>,<span class="org-type">uid_t</span> <span class="org-variable-name">owner</span>,<span class="org-type">gid_t</span> <span class="org-variable-name">group</span>)
<span class="org-type">int</span> <span class="org-function-name">lchown</span>(<span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">path</span>,<span class="org-type">uid_t</span> <span class="org-variable-name">owner</span>,<span class="org-type">gid_t</span> <span class="org-variable-name">group</span>)
</pre>
</div>

<p>
三者的区别类似stat,fstgat和lstat
</p>

<p>
若参数owner/group为-1,则表示对应ID不变.
</p>
</div>
</div>
</div>
<div id="outline-container-org26f5221" class="outline-2">
<h2 id="org26f5221"><span class="section-number-2">4</span> 关于文件长度</h2>
<div class="outline-text-2" id="text-4">
<ul class="org-ul">
<li>对于普通文件,文件长度为文件内容的多少(包括文件中的空洞)</li>
<li>对于目录,文件长度通常是一个数(例如16或512)的倍数</li>
<li>对于符号链接,文件长度是链接所指向的 <b>文件名长度</b> (注意,因为符号链接文件长度总是由st_size表示,所以它并不包含通常C语言中用作字符串结尾的null字符)</li>
</ul>
</div>
<div id="outline-container-orga45ef4c" class="outline-3">
<h3 id="orga45ef4c"><span class="section-number-3">4.1</span> 文件中的空洞</h3>
<div class="outline-text-3" id="text-4-1">
<p>
空洞是由所设置的偏移量超过文件尾端,并写了数据后照成了. 
</p>

<p>
文件中的空洞可能占有也可能不占用磁盘空间,但当复制该文件时,那么新文件会填满这些空洞.
</p>
</div>
</div>
<div id="outline-container-org63d287b" class="outline-3">
<h3 id="org63d287b"><span class="section-number-3">4.2</span> truncate函数:截断文件</h3>
<div class="outline-text-3" id="text-4-2">
<div class="org-src-container">
<pre class="src src-c"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;unistd.h&gt;</span>

<span class="org-type">int</span> <span class="org-function-name">truncate</span>(<span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">path</span>,<span class="org-type">off_t</span> <span class="org-variable-name">len</span>);
<span class="org-type">int</span> <span class="org-function-name">ftruncate</span>(<span class="org-type">int</span> <span class="org-variable-name">filedes</span>,<span class="org-type">off_t</span> <span class="org-variable-name">len</span>);
</pre>
</div>

<p>
若原文件的长度大于参数len,则超过len之前的数据就不能再访问.
</p>

<p>
若原文件的长度小于len,则实现效果与系统相关.
</p>
</div>
</div>
</div>
<div id="outline-container-org92d9d31" class="outline-2">
<h2 id="org92d9d31"><span class="section-number-2">5</span> 关于文件操作</h2>
<div class="outline-text-2" id="text-5">
</div>
<div id="outline-container-orgc454ed2" class="outline-3">
<h3 id="orgc454ed2"><span class="section-number-3">5.1</span> link函数:创建指向现有文件的链接</h3>
<div class="outline-text-3" id="text-5-1">
<div class="org-src-container">
<pre class="src src-c"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;unistd.h&gt;</span>

<span class="org-type">int</span> <span class="org-function-name">link</span>(<span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">exist_path</span>,<span class="org-keyword">const</span> <span class="org-type">char</span> *<span class="org-variable-name">new_path</span>);
</pre>
</div>
</div>
</div>
<div id="outline-container-orgad20c16" class="outline-3">
<h3 id="orgad20c16"><span class="section-number-3">5.2</span> unlink函数:删除指向文件的链接</h3>
<div class="outline-text-3" id="text-5-2">
<div class="org-src-container">
<pre class="src src-c"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;unistd.h&gt;</span>

<span class="org-type">int</span> <span class="org-function-name">unlink</span>(<span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">path</span>)
</pre>
</div>

<p>
该函数删除目录项,并将由path所引用的文件的链接计数减1. 
</p>

<p>
只有当链接计数为0时,该文件的内容才正真被删除.(注意: <b>若有进程打开了该文件,则即使该文件的链接计数为0,也不会真正释放磁盘空间. 只有当关闭该文件后,内核检查其链接数为0,才删除该文件内容.</b> )
</p>

<p>
unlink的这种特性,可以用来创建临时文件: 进程创建临时文件后,立刻调用unlink. 该文件因为是打开的,所以内容不会被删除,但当进程退出时,该文件的内容被删除.
</p>

<p>
一般来说,参数path指向的是一个 <b>文件</b> ,但若是超级用户权限,则参数path可以指向一个目录. 但通常应该使用rmdir函数代替.
</p>
</div>
</div>
<div id="outline-container-org7331b81" class="outline-3">
<h3 id="org7331b81"><span class="section-number-3">5.3</span> remove函数:删除一个对文件或目录的链接</h3>
<div class="outline-text-3" id="text-5-3">
<div class="org-src-container">
<pre class="src src-c"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;stdio.h&gt;</span>

<span class="org-type">int</span> <span class="org-function-name">remove</span>(<span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">path</span>)
</pre>
</div>

<p>
若path为文件路径,则remove与unlink类似.
</p>

<p>
若path为目录路径,则remove与rmdir类型.
</p>
</div>
</div>
<div id="outline-container-org08d0883" class="outline-3">
<h3 id="org08d0883"><span class="section-number-3">5.4</span> remove函数:对文件进行改名</h3>
<div class="outline-text-3" id="text-5-4">
<div class="org-src-container">
<pre class="src src-c"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;stdio.h&gt;</span>

<span class="org-type">int</span> <span class="org-function-name">rename</span>(<span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">oldname</span>,<span class="org-keyword">const</span> <span class="org-type">chaar</span>* <span class="org-variable-name">newname</span>);
</pre>
</div>

<ul class="org-ul">
<li>oldname和newname要么同时指向文件,要么同时指向目录, <b>不能一个为文件,一个为目录</b></li>
<li>若newname为目录,则必须是空目录.</li>
<li>若oldname和newname为符号链接,则处理的是符号链接本身,而不是它所引用的文件</li>
<li>若oldname和newname指向同一个文件,则函数不作任何更改返回成功.</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org5dc59e5" class="outline-2">
<h2 id="org5dc59e5"><span class="section-number-2">6</span> 符号链接</h2>
<div class="outline-text-2" id="text-6">
<p>
用open打开文件时,如果传递给open函数的路径指定了一个符号链接,那么open跟随链接找到所指向的文件. 若符号链接所指向的文件并不存在,则open返回出错.
</p>
</div>

<div id="outline-container-org21d6dec" class="outline-3">
<h3 id="org21d6dec"><span class="section-number-3">6.1</span> symlink函数:创建符号链接</h3>
<div class="outline-text-3" id="text-6-1">
<div class="org-src-container">
<pre class="src src-c"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;unistd.h&gt;</span>

<span class="org-type">int</span> <span class="org-function-name">symlink</span>(<span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">actual_path</span>,<span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">sym_path</span>)
</pre>
</div>

<p>
创建一个指向actual_path的符号链接sym_path. <b>并不要求acutal_path已近存在</b>
</p>
</div>
</div>

<div id="outline-container-org30a9ff0" class="outline-3">
<h3 id="org30a9ff0"><span class="section-number-3">6.2</span> readlink函数:读取符号链接本身</h3>
<div class="outline-text-3" id="text-6-2">
<div class="org-src-container">
<pre class="src src-c"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;unistd.h&gt;</span>

<span class="org-type">ssize_t</span> <span class="org-function-name">readlink</span>(<span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">pathname</span>,<span class="org-type">char</span>* <span class="org-variable-name">buf</span>,<span class="org-type">size_t</span> <span class="org-variable-name">bufsize</span>)
</pre>
</div>
<p>
<b>open函数会跟随符号链接打开其指向的实际文件</b> 若要打开链接本身,则需要使用readlink函数
</p>
</div>
</div>
</div>

<div id="outline-container-org75d99eb" class="outline-2">
<h2 id="org75d99eb"><span class="section-number-2">7</span> 文件的时间</h2>
<div class="outline-text-2" id="text-7">
</div>
<div id="outline-container-orgd6c9a9d" class="outline-3">
<h3 id="orgd6c9a9d"><span class="section-number-3">7.1</span> 三个时间属性的意义</h3>
<div class="outline-text-3" id="text-7-1">
<p>
每个文件都保持有三个时间属性,它们的意义为:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">字段</th>
<th scope="col" class="org-left">说明</th>
<th scope="col" class="org-left">例子</th>
<th scope="col" class="org-left">ls命令选项</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">st_atime</td>
<td class="org-left">文件数据的最后访问时间</td>
<td class="org-left">read</td>
<td class="org-left">-u</td>
</tr>

<tr>
<td class="org-left">st_mtime</td>
<td class="org-left">文件数据的最后修改时间</td>
<td class="org-left">write</td>
<td class="org-left">默认</td>
</tr>

<tr>
<td class="org-left">st_ctime</td>
<td class="org-left">i节点状态的最后更改时间</td>
<td class="org-left">chmod,chown</td>
<td class="org-left">-C</td>
</tr>
</tbody>
</table>

<p>
注意:系统并不保存对一个i节点的最后一次访问时间.
</p>
</div>
</div>

<div id="outline-container-org429e968" class="outline-3">
<h3 id="org429e968"><span class="section-number-3">7.2</span> utime函数:修改文件数据的访问时间和修改时间</h3>
<div class="outline-text-3" id="text-7-2">
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;utime.h&gt;</span>

<span class="org-type">int</span> <span class="org-function-name">utime</span>(<span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">path</span>,<span class="org-keyword">const</span> <span class="org-keyword">struct</span> <span class="org-type">utimbuf</span>* <span class="org-variable-name">times</span>);

<span class="org-keyword">struct</span> <span class="org-type">utimbuf</span>{
  <span class="org-type">time_t</span> <span class="org-variable-name">actime</span>;                <span class="org-comment-delimiter">/* </span><span class="org-comment">access time</span><span class="org-comment-delimiter"> */</span>
  <span class="org-type">time_t</span> <span class="org-variable-name">modtime</span>;               <span class="org-comment-delimiter">/* </span><span class="org-comment">modification time</span><span class="org-comment-delimiter"> */</span>
}
</pre>
</div>
<ul class="org-ul">
<li><p>
如果times参数为一个空指针,则访问时间和修改时间都设置为当前时间.
</p>

<p>
此时要求进程的有效用户ID必须等于文件的所有者ID,或进程对文件具有写权限
</p></li>

<li><p>
如果times是非空指针,则访问时间和修改时间被设置为times所指向结构中的值.
</p>

<p>
此时,进程的有效ID必须等于文件的所有者ID,或者进程为超级用户进程. <b>对文件只具有写权限是不够的</b>
</p></li>

<li><b>我们不能对更改i节点状态时间st_ctime指定一个值,当调用utime函数时,该字段自动更新</b></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org877d146" class="outline-2">
<h2 id="org877d146"><span class="section-number-2">8</span> 目录操作</h2>
<div class="outline-text-2" id="text-8">
</div>
<div id="outline-container-orgaa32240" class="outline-3">
<h3 id="orgaa32240"><span class="section-number-3">8.1</span> mkdir:创建目录</h3>
<div class="outline-text-3" id="text-8-1">
<div class="org-src-container">
<pre class="src src-c"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;sys/stat.h&gt;</span>

<span class="org-type">int</span> <span class="org-function-name">mkdir</span>(<span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">path</span>,<span class="org-type">mode_t</span> <span class="org-variable-name">mode</span>);
</pre>
</div>

<p>
指定的文件访问权限mode参数,会收到进程的文件模式创建屏蔽字的修改.
</p>

<p>
需要注意的是:对于目录, <b>一般至少要设置一个执行权限位</b> ,以允许访问该目录的文件名.
</p>
</div>
</div>

<div id="outline-container-org4d11a78" class="outline-3">
<h3 id="org4d11a78"><span class="section-number-3">8.2</span> rmdir:删除目录</h3>
<div class="outline-text-3" id="text-8-2">
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;unistd.h&gt;</span>

<span class="org-type">int</span> <span class="org-function-name">rmdir</span>(<span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">path</span>);
</pre>
</div>

<p>
被删除的目录必须为空
</p>
</div>
</div>

<div id="outline-container-orgb7afd46" class="outline-3">
<h3 id="orgb7afd46"><span class="section-number-3">8.3</span> 读目录参数</h3>
<div class="outline-text-3" id="text-8-3">
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;dirent.h&gt;</span>

<span class="org-type">DIR</span> *<span class="org-function-name">opendir</span>(<span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">pathname</span>);
<span class="org-keyword">struct</span> <span class="org-type">dirent</span>* <span class="org-function-name">readdir</span>(<span class="org-type">DIR</span>* <span class="org-variable-name">dp</span>);
<span class="org-type">void</span> <span class="org-function-name">rewinddir</span>(<span class="org-type">DIR</span>* <span class="org-variable-name">dp</span>);
<span class="org-type">int</span> <span class="org-function-name">closedir</span>(<span class="org-type">DIR</span>* <span class="org-variable-name">dp</span>);
<span class="org-type">long</span> <span class="org-function-name">telldir</span>(<span class="org-type">DIR</span>* <span class="org-variable-name">dp</span>);
<span class="org-type">void</span> <span class="org-function-name">seekdir</span>(<span class="org-type">DIR</span>* <span class="org-variable-name">dp</span>,<span class="org-type">long</span> <span class="org-variable-name">loc</span>);

<span class="org-keyword">struct</span> <span class="org-type">dirent</span>{
  <span class="org-type">ino_t</span> <span class="org-variable-name">d_ino</span>;
  <span class="org-type">char</span> <span class="org-variable-name">d_name</span>[NAME_MAX + 1];
}
</pre>
</div>

<p>
使用readdir读取目录中的目录项,目录中的各目录项的顺序与实现有关,它们通常并不按照字母顺序排列.
</p>
</div>
</div>

<div id="outline-container-org31a4f4c" class="outline-3">
<h3 id="org31a4f4c"><span class="section-number-3">8.4</span> chdir/fchdir:修改进程的当前工作目录</h3>
<div class="outline-text-3" id="text-8-4">
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;unistd.h&gt;</span>

<span class="org-type">int</span> <span class="org-function-name">chdir</span>(<span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">path</span>);

<span class="org-type">int</span> <span class="org-function-name">chdir</span>(<span class="org-type">int</span> <span class="org-variable-name">filedes</span>);
</pre>
</div>
</div>
</div>

<div id="outline-container-org44f0806" class="outline-3">
<h3 id="org44f0806"><span class="section-number-3">8.5</span> getcwd:获取当前工作目录</h3>
<div class="outline-text-3" id="text-8-5">
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;unistd.h&gt;</span>

<span class="org-type">char</span>* <span class="org-function-name">getcwd</span>(<span class="org-type">char</span>* <span class="org-variable-name">buf</span>,<span class="org-type">size_t</span> <span class="org-variable-name">size</span>);
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org5953516" class="outline-2">
<h2 id="org5953516"><span class="section-number-2">9</span> 设备特殊文件</h2>
<div class="outline-text-2" id="text-9">
<ul class="org-ul">
<li>可以使用major和minor宏来获取dev_t中的主设备号和次设备号</li>
<li>系统中与每个文件名关联的st_dev值是文件系统的设备号,该文件设备包含了这一文件名以及与其对应的i节点</li>
<li>只有字符特殊文件和块特殊文件才有st_rdev值,该值为实际设备的设备号.</li>
</ul>
</div>
</div>

</div>
</div>
<div>
  <div class="post-meta">
    <span title="post date" class="post-info">2015-05-14</span>
    <span title="last modification date" class="post-info">2016-10-24</span>
    <span title="tags" class="post-info">N/A</span>
    <span title="author" class="post-info">DarkSun</span>
  </div>
  <script src="../../../../../media/js/jquery-2.1.3.min.js"></script>
  <script src="../../../../../media/js/md5.min.js"></script>
  <section>
      <div id="gitalk-container"></div>
      <script type="text/javascript">
       var gitalk = new Gitalk({
           clientID: 'fdcb5d9da3f4acb4862c',
           clientSecret: 'dd0a16312a206782cb7669dcec5e96874ab48170',
           repo: 'lujun9972.github.com',
           owner: 'lujun9972',
           admin: ['lujun9972'],
           id: md5(location.pathname),      // Ensure uniqueness and length less than 50
           distractionFreeMode: false  // Facebook-like distraction free mode
       })
       gitalk.render('gitalk-container')
      </script>
  </section>
  <script src="../../../../../media/js/kdComment.js"></script>
      <script>
       var _hmt = _hmt || [];
       (function() {
           var hm = document.createElement("script");
           hm.src = "https://hm.baidu.com/hm.js?7bac4fd0247f69c27887e0d4e3aee41e";
           var s = document.getElementsByTagName("script")[0]; 
           s.parentNode.insertBefore(hm, s);
       })();
      </script>
  <div class="footer">
    <p>Generated by <a href="http://www.gnu.org/software/emacs/">Emacs</a> 27.x(<a href="http://orgmode.org">Org mode</a> 9.x)</p>
    <p>
      Copyright &copy; 2014 - <span id="footerYear"></span> <a href="mailto:travis &lt;at&gt; travis-job-7220d9c3-803c-4aac-83af-763d9aa824b2">DarkSun</a>
      &nbsp;&nbsp;-&nbsp;&nbsp;
      Powered by <a href="https://github.com/emacs-china/EGO" target="_blank">EGO</a><br/>
      Themed with <a href="https://github.com/kuangdash/emacs_love" target="_blank">emacs_love</a>
        <a href="http://creativecommons.org/licenses/by-sa/3.0/" rel="license"><img src="https://licensebuttons.net/l/by-sa/3.0/88x31.png" style="border-width:0" alt="Creative Commons License" class="center"></a>
      <script type="text/javascript">document.getElementById("footerYear").innerHTML = (new Date()).getFullYear();</script>
    </p>
  </div>
    </div>

  </body>
</html>
