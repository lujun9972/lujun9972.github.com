<!DOCTYPE html>
<html lang="en">
<head>
  <title>线程 - 暗无天日</title>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <meta name="author" content="DarkSun" />
  <style>
   #ds-thread #ds-reset .ds-comment-body p {color: #ffffff;}
   #disqus_thread a {color: #00ffff;}
  </style>
  <link rel="stylesheet" media="screen" href="../../../../../media/css/font.css" rel="stylesheet" type="text/css"/>
  <link rel="stylesheet" href="../../../../../media/css/main.css" type="text/css">
  <link rel="stylesheet" href="../../../../../media/css/org-src-fontify.css" type="text/css">
  <link rel="stylesheet" href="../../../../../media/css/kdComment.css" type="text/css">
  <script type="text/javascript"
          src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
  <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
</head>

  <body class="container">
<div>
  <header class="masthead">
    <h1 class="masthead-title"><a href="../../../../../">暗无天日</a></h1>
    <p>=============&gt;随便,谢谢</p>
    <nav class="site-nav">
      <div class="menu-icon">
      </div>
      <ul class="trigger">
              <li><a href="../../../../../years/">Years</a></li>
              <li><a href="../../../../../tags/">Tags</a></li>
              <li><a href="../../../../../about/">About</a></li>
              <li><a href="https://github.com/lujun9972/lujun9972.github.com.git">Github</a></li>
              <li><a href="../../../../../rss.xml">RSS</a></li>
      </ul>
    </nav>
    <form method="get" id="searchform" action="http://www.google.com/search">
        <input type="text" class="field" name="q" id="s" placeholder="Search">
        <input type="hidden" name="as_sitesearch" value="lujun9972.github.io">
    </form>
    <img class="avatar" src="https://avatar.csdnimg.cn/6/2/4/1_lujun9972.jpg" />
  </header>
</div>

<div>
<div class="post">
<h1 class="title">线程</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org6af2ed6">1. 线程的好处</a></li>
<li><a href="#orgf482824">2. 线程的组成部分</a>
<ul>
<li><a href="#org69f3dd4">2.1. 线程ID</a></li>
<li><a href="#orgeac98ac">2.2. 一组寄存器值</a></li>
<li><a href="#org4ae6b13">2.3. 栈</a></li>
<li><a href="#orge738e05">2.4. 调度优先级</a></li>
<li><a href="#org4b0edc2">2.5. 策略</a></li>
<li><a href="#org0040e09">2.6. 信号屏蔽字</a></li>
<li><a href="#org9588930">2.7. errno变量</a></li>
<li><a href="#org37abddd">2.8. 线程私有数据</a></li>
</ul>
</li>
<li><a href="#orgc682ddd">3. 线程的创建</a>
<ul>
<li><a href="#org151dd26">3.1. pthread_create</a></li>
</ul>
</li>
<li><a href="#orgb8f6797">4. 线程终止</a>
<ul>
<li><a href="#org6826d15">4.1. pthread_exit函数说明</a></li>
<li><a href="#orgca2e7a9">4.2. pthread_join函数说明</a></li>
<li><a href="#orgc76d2fa">4.3. pthread_cancel</a></li>
<li><a href="#orga71c88a">4.4. 线程清理函数</a></li>
<li><a href="#org160af00">4.5. pthread_detach(pthread_t tid)</a></li>
</ul>
</li>
<li><a href="#org2b80880">5. 线程同步</a>
<ul>
<li><a href="#org873f504">5.1. 互斥量</a>
<ul>
<li><a href="#orga4688cc">5.1.1. 互斥量的初始化与销毁</a></li>
<li><a href="#org29a3e70">5.1.2. 互斥量的加锁与解锁</a></li>
<li><a href="#org72cee2c">5.1.3. 避免死锁</a></li>
<li><a href="#orga3598bf">5.1.4. 对互斥量的一个简单C++封装</a></li>
</ul>
</li>
<li><a href="#orgc0b946e">5.2. 读写锁(共享/独占锁)</a>
<ul>
<li><a href="#org6a6af6d">5.2.1. 读写锁的初始化与销毁</a></li>
<li><a href="#org2b92257">5.2.2. 读写锁的加锁与解锁</a></li>
</ul>
</li>
<li><a href="#orgea1007b">5.3. 条件变量</a>
<ul>
<li><a href="#org34b6f55">5.3.1. 条件变量的初始化与销毁</a></li>
<li><a href="#org8a0f45c">5.3.2. 等待条件变量变为真</a></li>
<li><a href="#orgd49814d">5.3.3. 唤醒线程函数</a></li>
</ul>
</li>
<li><a href="#org73ed925">5.4. 使用pthread_once函数保证函数只执行一次</a></li>
</ul>
</li>
<li><a href="#org95d9ab6">6. 线程限制</a></li>
<li><a href="#orgee69b49">7. 线程属性</a>
<ul>
<li><a href="#orgc502c8f">7.1. 初始化/销毁线程属性</a></li>
<li><a href="#orge70fcdf">7.2. 线程属性的获取与修改</a>
<ul>
<li><a href="#org974616b">7.2.1. detachstate(线程的分离状态属性)</a></li>
<li><a href="#org7777d31">7.2.2. statcsize(线程栈的大小)</a></li>
<li><a href="#orgfd56537">7.2.3. stackaddr(线程栈的最低地址)</a></li>
<li><a href="#org5c9e338">7.2.4. guardsize(线程栈末尾的警戒缓冲区大小)</a></li>
<li><a href="#org03cd497">7.2.5. 可取消状态</a></li>
<li><a href="#org6376d60">7.2.6. 可取消类型</a></li>
<li><a href="#org8dc8ddd">7.2.7. 并发度</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org7d41080">8. 同步属性</a>
<ul>
<li><a href="#org2b4ca72">8.1. 互斥量属性</a>
<ul>
<li><a href="#org465becb">8.1.1. 互斥量属性的初始化/销毁</a></li>
<li><a href="#org3979e68">8.1.2. 互斥量的共享属性</a></li>
<li><a href="#org71d4af5">8.1.3. 互斥量的类型属性</a></li>
</ul>
</li>
<li><a href="#org62a8a2d">8.2. 读写锁属性</a>
<ul>
<li><a href="#orga38c1a2">8.2.1. 读写锁初始化/销毁</a></li>
<li><a href="#org6920c08">8.2.2. 进程共享属性</a></li>
</ul>
</li>
<li><a href="#orge7c587c">8.3. 条件变量属性</a>
<ul>
<li><a href="#org5331ae7">8.3.1. 条件变量初始化/销毁</a></li>
<li><a href="#orgddbf0e4">8.3.2. 进程共享属性</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgd4ec2a9">9. 多线程环境下的信号处理</a>
<ul>
<li><a href="#org88676c8">9.1. 多线程与进程中使用信号机制的区别.</a></li>
<li><a href="#org9c38ff0">9.2. 设置线程的信号屏蔽字</a></li>
<li><a href="#org2516bfa">9.3. 线程等待信号发生</a></li>
<li><a href="#org5be2a1b">9.4. 发送信号給线程</a></li>
</ul>
</li>
<li><a href="#orge4efd76">10. 多线程环境下的fork</a>
<ul>
<li><a href="#orge46dbcd">10.1. 多线程环境下fork的问题</a></li>
</ul>
</li>
<li><a href="#org9d2eedf">11. 线程的私有数据(Thread-specific Data)</a>
<ul>
<li><a href="#orgb9f1b0b">11.1. pthread_key_create</a></li>
<li><a href="#orgf74259b">11.2. pthread_key_delete</a></li>
<li><a href="#org4a46f20">11.3. pthread_setspecific/pthread_getspecific</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org6af2ed6" class="outline-2">
<h2 id="org6af2ed6"><span class="section-number-2">1</span> 线程的好处</h2>
<div class="outline-text-2" id="text-1">
<ul class="org-ul">
<li>通过为每个事件类型的处理分配单独的线程,能够简化处理异步事件的代码,同步编程模式比异步编程模式简单得多</li>
<li>进程所有信息对该进程的所有线程都是共享的,包括 <b>可执行的程序文本,程序的全局内存和堆内存,栈以及文件描述符</b>,而多进程必须通过操作系统的复杂机制才能实现</li>
<li>交互式的程序可以使用多线程改善程序响应.</li>
</ul>
</div>
</div>

<div id="outline-container-orgf482824" class="outline-2">
<h2 id="orgf482824"><span class="section-number-2">2</span> 线程的组成部分</h2>
<div class="outline-text-2" id="text-2">
</div>
<div id="outline-container-org69f3dd4" class="outline-3">
<h3 id="org69f3dd4"><span class="section-number-3">2.1</span> 线程ID</h3>
<div class="outline-text-3" id="text-2-1">
<p>
线程ID只在所属的进程环境中有效,其使用pthread_t数据类型来表示. 
</p>

<p>
线程获取自己线程ID的函数是pthread_self
</p>
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;pthread.h&gt;</span>

<span class="org-type">pthread_t</span> <span class="org-function-name">pthread_self</span>();
</pre>
</div>

<p>
由于pthread_t的实现方式可能为结构体,因此需要使用专门的pthread_equal来比较两个pthread_t是否相等.
</p>
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;pthread.h&gt;</span>

<span class="org-comment-delimiter">/* </span><span class="org-comment">&#33509;&#30456;&#31561;&#36820;&#22238;&#38750;0,&#21542;&#21017;&#36820;&#22238;0</span><span class="org-comment-delimiter"> */</span>
<span class="org-type">int</span> <span class="org-function-name">pthread_equal</span>(<span class="org-type">pthread_t</span> <span class="org-variable-name">tid1</span>,<span class="org-type">pthread_t</span> <span class="org-variable-name">tid2</span>);
</pre>
</div>

<p>
<b>用结构表示pthread_t数据类型的一个不好的后果是:不能用一种可移植的方式打印该数据类型的值</b>
</p>
</div>
</div>
<div id="outline-container-orgeac98ac" class="outline-3">
<h3 id="orgeac98ac"><span class="section-number-3">2.2</span> 一组寄存器值</h3>
</div>
<div id="outline-container-org4ae6b13" class="outline-3">
<h3 id="org4ae6b13"><span class="section-number-3">2.3</span> 栈</h3>
</div>
<div id="outline-container-orge738e05" class="outline-3">
<h3 id="orge738e05"><span class="section-number-3">2.4</span> 调度优先级</h3>
</div>
<div id="outline-container-org4b0edc2" class="outline-3">
<h3 id="org4b0edc2"><span class="section-number-3">2.5</span> 策略</h3>
</div>
<div id="outline-container-org0040e09" class="outline-3">
<h3 id="org0040e09"><span class="section-number-3">2.6</span> 信号屏蔽字</h3>
</div>
<div id="outline-container-org9588930" class="outline-3">
<h3 id="org9588930"><span class="section-number-3">2.7</span> errno变量</h3>
</div>
<div id="outline-container-org37abddd" class="outline-3">
<h3 id="org37abddd"><span class="section-number-3">2.8</span> 线程私有数据</h3>
</div>
</div>
<div id="outline-container-orgc682ddd" class="outline-2">
<h2 id="orgc682ddd"><span class="section-number-2">3</span> 线程的创建</h2>
<div class="outline-text-2" id="text-3">
</div>
<div id="outline-container-org151dd26" class="outline-3">
<h3 id="org151dd26"><span class="section-number-3">3.1</span> pthread_create</h3>
<div class="outline-text-3" id="text-3-1">
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;pthread.h&gt;</span>

<span class="org-comment-delimiter">/* </span><span class="org-comment">&#25104;&#21151;&#36820;&#22238;0,&#21542;&#21017;&#36820;&#22238;&#38169;&#35823;&#32534;&#21495;</span><span class="org-comment-delimiter"> */</span>
<span class="org-type">int</span> <span class="org-function-name">pthread_create</span>(<span class="org-type">pthread_t</span>* <span class="org-variable-name">tidp</span>,<span class="org-keyword">const</span> <span class="org-type">pthread_attr_t</span>* <span class="org-variable-name">attr</span>,<span class="org-type">void</span>* (*<span class="org-function-name">start_rtn</span>)(<span class="org-type">void</span>*),<span class="org-type">void</span>* <span class="org-variable-name">arg</span>)
</pre>
</div>
<ul class="org-ul">
<li>tidp所指向的pthread_t数据结构被设置为新创建线程的线程ID</li>
<li>attr参数指定新线程的属性,NULL表示默认属性</li>
<li>start_rtn函数指针指明了新线程调用哪个函数,该函数只有一个void*参数arg,因此若需要向start_rtn函数传递的参数不止一个,则需要 <b>把参数放到一个结构中</b>.</li>
<li>新创建的线程继承调用线程的浮点环境和信号屏蔽字, <b>但该线程的未决信号集被清除</b></li>
<li>由于可能在主线程的pthread_create函数返回前就运行新线程了,因此在新线程中不能安全的使用tidp的值.</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgb8f6797" class="outline-2">
<h2 id="orgb8f6797"><span class="section-number-2">4</span> 线程终止</h2>
<div class="outline-text-2" id="text-4">
<p>
线程终止有4种方法:
</p>
<ul class="org-ul">
<li>调用exit,_Exit或_exit,但会使 <b>整个进程终结</b></li>
<li>线程从启动函数中返回, <b>返回值即为线程退出码</b></li>
<li>线程被同一进程的其他线程取消</li>
<li>线程调用pthread_exit函数.</li>
</ul>
</div>
<div id="outline-container-org6826d15" class="outline-3">
<h3 id="org6826d15"><span class="section-number-3">4.1</span> pthread_exit函数说明</h3>
<div class="outline-text-3" id="text-4-1">
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;pthread.h&gt;</span>

<span class="org-type">void</span> <span class="org-function-name">pthread_exit</span>(<span class="org-type">void</span>* <span class="org-variable-name">rtn_val</span>);
</pre>
</div>
<p>
其中参数rtn_val为线程退出的返回值. 其他进程可以使用`pthread_join'函数访问 <b>这个指针</b>.
</p>

<p>
实际使用时,rtn_val不一定就是指针类型,也可能被强制转换为整型. 
但若rtn_val为指针类型,则需要保证 <b>指针所指的内容在调用者完成调用后仍然有效(全局变量或在堆上分配空间)</b>
</p>
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;pthread.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;stdio.h&gt;</span>

<span class="org-type">void</span>* <span class="org-function-name">thread_func1</span>(<span class="org-type">void</span>* <span class="org-variable-name">arg</span>)
{
  printf(<span class="org-string">"thread running. "</span>);
  <span class="org-keyword">return</span> ((<span class="org-type">void</span>*) 1);           <span class="org-comment-delimiter">/* </span><span class="org-comment">&#36825;&#37324;&#23558;&#25972;&#22411;&#24378;&#21046;&#36716;&#25442;&#20026;&#25351;&#38024;</span><span class="org-comment-delimiter"> */</span>
}

<span class="org-type">void</span>* <span class="org-function-name">thread_func2</span>(<span class="org-type">void</span>* <span class="org-variable-name">arg</span>)
{
  printf(<span class="org-string">"thread running. "</span>);
  <span class="org-type">char</span>* <span class="org-variable-name">rtn</span> = malloc(<span class="org-keyword">sizeof</span>(<span class="org-string">"I am thread 2"</span>) + 1);
  strcpy(rtn,<span class="org-string">"I am thread 2"</span>);
  <span class="org-keyword">return</span> ((<span class="org-type">void</span>*) rtn);           <span class="org-comment-delimiter">/* </span><span class="org-comment">&#36825;&#37324;&#36820;&#22238;&#19968;&#20010;&#25351;&#21521;&#23383;&#31526;&#25968;&#32452;&#30340;&#25351;&#38024;</span><span class="org-comment-delimiter"> */</span>
}
<span class="org-type">int</span> <span class="org-function-name">main</span>()
{
  <span class="org-type">pthread_t</span> <span class="org-variable-name">tid</span>;
  <span class="org-type">void</span>* <span class="org-variable-name">thread_rtn</span>;

  pthread_create(&amp;tid,<span class="org-constant">NULL</span>,thread_func1,<span class="org-constant">NULL</span>);
  pthread_join(tid,&amp;thread_rtn);
  printf(<span class="org-string">"thread returns %d\n"</span>,(<span class="org-type">int</span>)thread_rtn);

  pthread_create(&amp;tid,<span class="org-constant">NULL</span>,thread_func2,<span class="org-constant">NULL</span>);
  pthread_join(tid,&amp;thread_rtn);
  printf(<span class="org-string">"thread returns %s\n"</span>,(<span class="org-type">char</span>*)thread_rtn);
  free((<span class="org-type">char</span>*)thread_rtn);
  <span class="org-keyword">return</span> 0;
}
</pre>
</div>

<p>
thread running. thread returns 1
thread running. thread returns I am thread 2
</p>
</div>
</div>

<div id="outline-container-orgca2e7a9" class="outline-3">
<h3 id="orgca2e7a9"><span class="section-number-3">4.2</span> pthread_join函数说明</h3>
<div class="outline-text-3" id="text-4-2">
<p>
默认情况下(非DETACH的情况下),线程终止后并不会自动释放线程所占用的资源,需要其他线程调用pthread_join函数来同步终止并释放资源(使指定线程变为DETACH状态).
</p>

<p>
pthread_join类似进程间的wait函数.
</p>
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;pthread.h&gt;</span>

<span class="org-type">int</span> <span class="org-function-name">pthread_join</span>(<span class="org-type">pthread_t</span> <span class="org-variable-name">thread</span>,<span class="org-type">void</span>** <span class="org-variable-name">rtn_val_p</span>);
</pre>
</div>
<ul class="org-ul">
<li>调用的线程会一直阻塞,直到指定的线程退出.</li>
<li>若参数rtn_val_p为非NULL,则会获得pthread_exit的返回指针. 即*rtn_val_p = rtn_val</li>
<li>但若指定的线程被取消运行,则*rtn_val_p == PTHREAD_CANCELD</li>
<li>若指定的线程已经处于分离状态,则pthread_join会调用失败,返回EINVAL.</li>
</ul>
</div>
</div>

<div id="outline-container-orgc76d2fa" class="outline-3">
<h3 id="orgc76d2fa"><span class="section-number-3">4.3</span> pthread_cancel</h3>
<div class="outline-text-3" id="text-4-3">
<p>
pthread_cancel函数用来 <b>请求(并不能强制)</b> 取消同一进程中的其他线程
</p>
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;pthread.h&gt;</span>

<span class="org-comment-delimiter">/* </span><span class="org-comment">&#25104;&#21151;&#36820;&#22238;0,&#21542;&#21017;&#36820;&#22238;&#38169;&#35823;&#32534;&#21495;</span><span class="org-comment-delimiter"> */</span>
<span class="org-type">int</span> <span class="org-function-name">pthread_cancel</span>(<span class="org-type">pthread_t</span> <span class="org-variable-name">tid</span>);
</pre>
</div>
<p>
默认情况下,pthread_cancel函数会使得指定线程的行为表现如同调用了`pthread_exit(PTHREAD_CANCELED)'. 但,线程可以选择 <b>忽略取消,或采用其他的取消方式</b>
</p>
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;pthread.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;stdio.h&gt;</span>

<span class="org-type">void</span>* <span class="org-function-name">thread_func</span>(<span class="org-type">void</span>* <span class="org-variable-name">arg</span>)
{
  printf(<span class="org-string">"thread running"</span>);
  sleep(10);
  <span class="org-keyword">return</span> (<span class="org-type">void</span>*) 100;
}

<span class="org-type">int</span> <span class="org-function-name">main</span>()
{
  <span class="org-type">pthread_t</span> <span class="org-variable-name">tid</span>;
  <span class="org-type">void</span>* <span class="org-variable-name">thread_rtn</span>;

  pthread_create(&amp;tid,<span class="org-constant">NULL</span>,thread_func,<span class="org-constant">NULL</span>);
  pthread_cancel(tid);
  pthread_join(tid,&amp;thread_rtn);
  <span class="org-keyword">if</span>(thread_rtn == PTHREAD_CANCELED)
    {
      printf(<span class="org-string">"thread returned PTHREAD_CANCELED"</span>);
    }
  <span class="org-keyword">else</span>
    {
      printf(<span class="org-string">"thread returned %d"</span>,(<span class="org-type">int</span>)thread_rtn);
    }
  <span class="org-keyword">return</span> 0;
}
</pre>
</div>

<p>
thread runningthread returned PTHREAD_CANCELED
</p>

<p>
另外需要注意的是, <b>默认情况下, 线程在取消请求发出后并不会立即退出,而是会继续运行,直到线程到达某个取消点</b>. 取消点常在线程调用某些函数时出现.
</p>

<p>
若应用程序在很长时间内都不会调用到产生取消点的函数,则可以调用`pthread_testcancel'函数在程序中自己添加取消点.
</p>
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;pthread.h&gt;</span>

<span class="org-type">void</span> <span class="org-function-name">pthread_testcancel</span>();
</pre>
</div>
</div>
</div>
<div id="outline-container-orga71c88a" class="outline-3">
<h3 id="orga71c88a"><span class="section-number-3">4.4</span> 线程清理函数</h3>
<div class="outline-text-3" id="text-4-4">
<p>
类似进程,线程也可以安排它退出时要调用的函数. 这些类似atexit的函数被称为线程清理处理函数.
</p>

<p>
线程也可以建立多个清理处理函数,它们的指向顺序与注册顺序相反.
</p>
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;pthread.h&gt;</span>

<span class="org-comment-delimiter">/* </span><span class="org-comment">&#27880;&#20876;&#28165;&#29702;&#20989;&#25968;,&#21450;&#21442;&#25968;</span><span class="org-comment-delimiter"> */</span>
<span class="org-type">void</span> <span class="org-function-name">pthread_cleanup_push</span>(<span class="org-type">void</span> (*<span class="org-function-name">clean_func</span>)(<span class="org-type">void</span>*),<span class="org-type">void</span>* <span class="org-variable-name">arg</span>);

<span class="org-comment-delimiter">/* </span><span class="org-comment">&#21024;&#38500;&#19978;&#27425;&#27880;&#20876;&#30340;&#28165;&#29702;&#20989;&#25968;,&#21442;&#25968;execute&#34920;&#31034;&#21024;&#38500;&#21069;&#30693;&#21542;&#25191;&#34892;&#36825;&#20123;&#28165;&#29702;&#20989;&#25968;</span><span class="org-comment-delimiter"> */</span>
<span class="org-type">void</span> <span class="org-function-name">pthread_cleanup_pop</span>(<span class="org-type">int</span> <span class="org-variable-name">execute</span>);
</pre>
</div>
<p>
在 <b>pthread_cleanup_push和pthread_cleanup_pop间的代码段</b> 中若有终止动作(包括被取消),都将执行pthread_cleanup_push()所注册的清理函数.
</p>

<p>
<b>pthread_cleanup_push和pthread_cleanup_pop必须成对出现!</b>
</p>
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;pthread.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;stdio.h&gt;</span>

<span class="org-type">void</span> <span class="org-function-name">cleanup</span>(<span class="org-type">void</span>* <span class="org-variable-name">arg</span>)
{
  printf(<span class="org-string">"cleanup:%s\n"</span>,(<span class="org-type">char</span>*)arg);
}

<span class="org-type">void</span>* <span class="org-function-name">thread_func</span>(<span class="org-type">void</span>* <span class="org-variable-name">arg</span>)
{
  pthread_cleanup_push(cleanup,(<span class="org-type">void</span>*)<span class="org-string">"thread first cleanup handler"</span>);
  pthread_cleanup_push(cleanup,(<span class="org-type">void</span>*)<span class="org-string">"thread second cleanup handler"</span>);
  printf(<span class="org-string">"running thread\n"</span>);
  pthread_cleanup_pop(1);      <span class="org-comment-delimiter">/* </span><span class="org-comment">&#27809;&#26377;&#36864;&#20986;,&#20294;execute&#20026;1&#34920;&#31034;&#24377;&#20986;&#31532;2&#20010;&#22788;&#29702;&#20989;&#25968;&#26102;&#20063;&#35201;&#25191;&#34892;&#35813;&#20989;&#25968;</span><span class="org-comment-delimiter"> */</span>
  <span class="org-keyword">if</span>(arg == <span class="org-constant">NULL</span>)
    {
      pthread_exit(arg);
      <span class="org-comment-delimiter">/* </span><span class="org-comment">return arg;</span><span class="org-comment-delimiter"> */</span>
    }
  pthread_cleanup_pop(0);
  <span class="org-keyword">return</span> arg;
}

<span class="org-type">int</span> <span class="org-function-name">main</span>()
{
  <span class="org-type">pthread_t</span> <span class="org-variable-name">tid</span>;
  <span class="org-type">void</span>* <span class="org-variable-name">rtn_value</span>;

  pthread_create(&amp;tid,<span class="org-constant">NULL</span>,thread_func,(<span class="org-type">void</span>*)<span class="org-constant">NULL</span>);
  pthread_join(tid,&amp;rtn_value);

  pthread_create(&amp;tid,<span class="org-constant">NULL</span>,thread_func,(<span class="org-type">void</span>*)1);
  pthread_join(tid,&amp;rtn_value);

  <span class="org-keyword">return</span> 0;
}
</pre>
</div>

<p>
running thread
cleanup:thread second cleanup handler
cleanup:thread first cleanup handler
running thread
cleanup:thread second cleanup handler
</p>
</div>
</div>

<div id="outline-container-org160af00" class="outline-3">
<h3 id="org160af00"><span class="section-number-3">4.5</span> pthread_detach(pthread_t tid)</h3>
<div class="outline-text-3" id="text-4-5">
<p>
pthread_detach可以让指定线程处于分离状态,若线程已经处于分离状态,则线程的低层存储资源会在线程终止时自动立即回收.
因此,并不能对分离的线程调用pthread_join函数
</p>
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;pthread.h&gt;</span>

<span class="org-type">int</span> <span class="org-function-name">pthread_detach</span>(<span class="org-type">pthread_t</span> <span class="org-variable-name">tid</span>);
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org2b80880" class="outline-2">
<h2 id="org2b80880"><span class="section-number-2">5</span> 线程同步</h2>
<div class="outline-text-2" id="text-5">
</div>
<div id="outline-container-org873f504" class="outline-3">
<h3 id="org873f504"><span class="section-number-3">5.1</span> 互斥量</h3>
<div class="outline-text-3" id="text-5-1">
</div>
<div id="outline-container-orga4688cc" class="outline-4">
<h4 id="orga4688cc"><span class="section-number-4">5.1.1</span> 互斥量的初始化与销毁</h4>
<div class="outline-text-4" id="text-5-1-1">
<p>
互斥量用于保证同一时间是由一个线程访问数据. 互斥变量的数据类型为pthread_mutex_t
</p>
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;pthread.h&gt;</span>

<span class="org-type">int</span> <span class="org-function-name">pthread_mutex_init</span>(<span class="org-type">pthread_mutex_t</span>* <span class="org-variable-name">mutex</span>,<span class="org-keyword">const</span> <span class="org-type">pthread_mutexattr_t</span>* <span class="org-variable-name">attr</span>);

<span class="org-type">int</span> <span class="org-function-name">pthread_mutex_destroy</span>(<span class="org-type">pthread_mutex_t</span>* <span class="org-variable-name">mutex</span>);
</pre>
</div>
<ul class="org-ul">
<li>使用互斥量之前需要调用pthread_mutex_init对它进行初始化.</li>
<li>pthread_mutex_init的参数attr指明了初始化互斥量时的属性,NULL表示默认属性</li>
<li>但对于静态分配的互斥量可以直接赋值为常量`PTHREAD_MUTEX_INITIALIZER',而无需pthread_mutex_init初始化</li>
<li>如果是在堆上分配的互斥量(malloc或new产生的),那么释放内存前 <b>需要调用pthread_mutex_destroy</b></li>
</ul>
</div>
</div>
<div id="outline-container-org29a3e70" class="outline-4">
<h4 id="org29a3e70"><span class="section-number-4">5.1.2</span> 互斥量的加锁与解锁</h4>
<div class="outline-text-4" id="text-5-1-2">
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;pthread.h&gt;</span>

<span class="org-comment-delimiter">/* </span><span class="org-comment">&#20197;&#38459;&#22622;&#30340;&#26041;&#24335;&#23545;mutex&#21152;&#38145;</span><span class="org-comment-delimiter"> */</span>
<span class="org-type">int</span> <span class="org-function-name">pthread_mutex_lock</span>(<span class="org-type">pthread_mutex_t</span>* <span class="org-variable-name">mutex</span>);

<span class="org-comment-delimiter">/* </span><span class="org-comment">&#20197;&#38750;&#38459;&#22622;&#30340;&#26041;&#24335;&#23545;mutex&#21152;&#38145;,&#33509;&#21152;&#38145;&#25104;&#21151;&#36820;&#22238;0,&#22833;&#36133;&#36820;&#22238;EBUSY</span><span class="org-comment-delimiter"> */</span>
<span class="org-type">int</span> <span class="org-function-name">pthread_mutex_trylock</span>(<span class="org-type">pthread_mutex_t</span>* <span class="org-variable-name">mutex</span>);

<span class="org-comment-delimiter">/* </span><span class="org-comment">&#23545;mutex&#35299;&#38145;</span><span class="org-comment-delimiter"> */</span>
<span class="org-type">int</span> <span class="org-function-name">pthread_mutex_unlock</span>(<span class="org-type">pthread_mutex_t</span>* <span class="org-variable-name">mutex</span>);
</pre>
</div>
</div>
</div>
<div id="outline-container-org72cee2c" class="outline-4">
<h4 id="org72cee2c"><span class="section-number-4">5.1.3</span> 避免死锁</h4>
<div class="outline-text-4" id="text-5-1-3">
<ul class="org-ul">
<li>线程内不要对一个互斥量加锁两次</li>
<li>小心地空值多个线程间使用一致的顺序来避免死锁的发生</li>
<li>使用pthread_mutex_trylock接口避免死锁,并且在超出一段时间未能获取到互斥量后,考虑先释放已占用锁,过段事件后再重试</li>
</ul>
</div>
</div>
<div id="outline-container-orga3598bf" class="outline-4">
<h4 id="orga3598bf"><span class="section-number-4">5.1.4</span> 对互斥量的一个简单C++封装</h4>
<div class="outline-text-4" id="text-5-1-4">
<div class="org-src-container">
<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">.h&#25991;&#20214;</span>
<span class="org-keyword">class</span> <span class="org-type">CMutex</span>
{
<span class="org-keyword">public</span>:
        <span class="org-function-name">CMutex</span>();
        ~<span class="org-function-name">CMutex</span>();

        <span class="org-type">int</span> <span class="org-function-name">tryLock</span>();
        <span class="org-type">int</span> <span class="org-function-name">lock</span>();
        <span class="org-type">int</span> <span class="org-function-name">unLock</span>();

        <span class="org-type">pthread_mutex_t</span> <span class="org-variable-name">m_Mutex</span>;
};

<span class="org-keyword">class</span> <span class="org-type">CScopeLock</span>
{
<span class="org-keyword">public</span>:
        <span class="org-function-name">CScopeLock</span>(<span class="org-type">CMutex</span>&amp; <span class="org-variable-name">cMutex</span>, <span class="org-type">bool</span> <span class="org-variable-name">IsTry</span> = <span class="org-constant">false</span>);
        <span class="org-keyword">virtual</span> ~<span class="org-function-name">CScopeLock</span>(<span class="org-type">void</span>);

<span class="org-keyword">private</span>:
        <span class="org-type">CMutex</span>&amp; <span class="org-variable-name">m_Mutex</span>;
};

<span class="org-comment-delimiter">// </span><span class="org-comment">.cpp&#25991;&#20214;</span>
<span class="org-constant">CMutex</span>::<span class="org-function-name">CMutex</span>()
{
        pthread_mutex_init(&amp;m_Mutex, <span class="org-constant">NULL</span>);
}

<span class="org-constant">CMutex</span>::~<span class="org-function-name">CMutex</span>()
{
        pthread_mutex_destroy(&amp;m_Mutex);
}

<span class="org-type">int</span> <span class="org-constant">CMutex</span>::<span class="org-function-name">lock</span>()
{
        <span class="org-keyword">return</span> pthread_mutex_lock(&amp;m_Mutex);
}

<span class="org-type">int</span> <span class="org-constant">CMutex</span>::<span class="org-function-name">tryLock</span>()
{
        <span class="org-keyword">return</span> pthread_mutex_trylock(&amp;m_Mutex);
}

<span class="org-type">int</span> <span class="org-constant">CMutex</span>::<span class="org-function-name">unLock</span>()
{
        <span class="org-keyword">return</span> pthread_mutex_unlock(&amp;m_Mutex);
}

<span class="org-constant">CScopeLock</span>::<span class="org-function-name">CScopeLock</span>(<span class="org-type">CMutex</span>&amp; <span class="org-variable-name">cMutex</span>, <span class="org-type">bool</span> <span class="org-variable-name">IsTry</span>): <span class="org-function-name">m_Mutex</span>(cMutex)
{
        <span class="org-keyword">if</span>(IsTry)
        {
                m_Mutex.tryLock();
        }
        <span class="org-keyword">else</span>
        {
                m_Mutex.lock();
        }
}

<span class="org-constant">CScopeLock</span>::~<span class="org-function-name">CScopeLock</span>()
{
        m_Mutex.unLock();
}

</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgc0b946e" class="outline-3">
<h3 id="orgc0b946e"><span class="section-number-3">5.2</span> 读写锁(共享/独占锁)</h3>
<div class="outline-text-3" id="text-5-2">
<p>
读写锁有三个状态:加读锁,加写锁和不加锁.
</p>

<p>
一次只能有一个线程可以加写锁,但可以有多个线程同时加读锁
</p>

<p>
对一个有写锁的资源上不能加任何锁. 对一个有读锁的资源上可以加读锁,但不能加写锁.
在实际的实现中,当 <b>有加写锁请求被阻塞后,随后的加读锁请求也会被阻塞</b>,这样是为了避免读锁长期占用,而等待的加写锁请求一直得不到满足
</p>

<p>
由于读写锁对读锁和写锁的这种处理,读写锁非常适合于对数据结构的读次数远大于写的情况.
</p>
</div>
<div id="outline-container-org6a6af6d" class="outline-4">
<h4 id="org6a6af6d"><span class="section-number-4">5.2.1</span> 读写锁的初始化与销毁</h4>
<div class="outline-text-4" id="text-5-2-1">
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;pthread.h&gt;</span>

<span class="org-type">int</span> <span class="org-function-name">pthread_rwlock_init</span>(<span class="org-type">pthread_rwlock_t</span>* <span class="org-variable-name">rwlock</span>,<span class="org-keyword">const</span> <span class="org-type">pthread_rwlockattr_t</span>* <span class="org-variable-name">attr</span>);

<span class="org-type">int</span> <span class="org-function-name">pthread_rwlock_destroy</span>(<span class="org-type">pthread_rwlock_t</span>* <span class="org-variable-name">rwlock</span>);
</pre>
</div>
<ul class="org-ul">
<li>参数attr为NULL表示使用默认的属性</li>
</ul>
</div>
</div>
<div id="outline-container-org2b92257" class="outline-4">
<h4 id="org2b92257"><span class="section-number-4">5.2.2</span> 读写锁的加锁与解锁</h4>
<div class="outline-text-4" id="text-5-2-2">
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;pthread.h&gt;</span>

<span class="org-comment-delimiter">/* </span><span class="org-comment">&#20197;&#38459;&#22622;&#26041;&#24335;&#21152;&#35835;&#38145;</span><span class="org-comment-delimiter"> */</span>
<span class="org-type">int</span> <span class="org-function-name">pthread_rwlock_rdlock</span>(<span class="org-type">pthread_rwlock_t</span>* <span class="org-variable-name">rwlock</span>);
<span class="org-comment-delimiter">/* </span><span class="org-comment">&#20197;&#38750;&#38459;&#22622;&#26041;&#24335;&#21152;&#35835;&#38145;</span><span class="org-comment-delimiter"> */</span>
<span class="org-type">int</span> <span class="org-function-name">pthread_rwlock_tryrdlock</span>(<span class="org-type">pthread_rwlock_t</span>* <span class="org-variable-name">rwlock</span>);

<span class="org-comment-delimiter">/* </span><span class="org-comment">&#20197;&#38459;&#22622;&#26041;&#24335;&#21152;&#20889;&#38145;</span><span class="org-comment-delimiter"> */</span>
<span class="org-type">int</span> <span class="org-function-name">pthread_rwlock_wrlock</span>(<span class="org-type">pthread_rwlock_t</span>* <span class="org-variable-name">rwlock</span>);
<span class="org-comment-delimiter">/* </span><span class="org-comment">&#20197;&#38750;&#38459;&#22622;&#26041;&#24335;&#21152;&#20889;&#38145;</span><span class="org-comment-delimiter"> */</span>
<span class="org-type">int</span> <span class="org-function-name">pthread_rwlock_trywrlock</span>(<span class="org-type">pthread_rwlock_t</span>* <span class="org-variable-name">rwlock</span>);

<span class="org-comment-delimiter">/* </span><span class="org-comment">&#35299;&#38145;</span><span class="org-comment-delimiter"> */</span>
<span class="org-type">int</span> <span class="org-function-name">pthread_rwlock_unlock</span>(<span class="org-type">pthread_rwlock_t</span>* <span class="org-variable-name">rwlock</span>);
</pre>
</div>
<ul class="org-ul">
<li>某些实现对加读锁的时候,可能会对锁的数量进行限制,因此需要检查加锁的返回值是否正确.</li>
<li>加写锁和解锁的函数,只有在不正确地使用读写锁时才回有错误返回,因此如果 <b>锁设计合理的话,可以不需要检查返回值</b></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgea1007b" class="outline-3">
<h3 id="orgea1007b"><span class="section-number-3">5.3</span> 条件变量</h3>
<div class="outline-text-3" id="text-5-3">
<p>
条件变量是利用线程间共享的全局变量进行同步的一种机制,主要包括两个动作:
</p>
<ul class="org-ul">
<li>多个线程在某个条件不为真时调用`pthread_cond_wait'函数而被阻塞</li>
<li>另一个线程处理完后,改变条件状态,并通过`pthread_cond_signal'唤醒等待该条件变量的其他线程. 其他线程重新计算条件是否满足并决定是继续阻塞还是运行</li>
</ul>

<p>
条件变量与互斥量一起使用时,运行线程以无竞争的方式等待特定的条件发生
</p>

<p>
条件变量本身需要互斥量的保护,即 <b>线程在改变条件变量时必须先锁住互斥量</b>
</p>

<p>
条件变量的数据类型为pthread_cond_t
</p>
</div>
<div id="outline-container-org34b6f55" class="outline-4">
<h4 id="org34b6f55"><span class="section-number-4">5.3.1</span> 条件变量的初始化与销毁</h4>
<div class="outline-text-4" id="text-5-3-1">
<p>
静态分配的条件变量可以直接赋值为常量PTHREAD_COND_INITIALIZER.
</p>

<p>
动态分配的条件变量必须使用pthread_mutex_destroy函数进行初始化
</p>
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;pthread.h&gt;</span>

<span class="org-type">int</span> <span class="org-function-name">pthread_cond_init</span>(<span class="org-type">pthread_cond_t</span>* <span class="org-variable-name">cond</span>,<span class="org-type">pthread_condattr_t</span>* <span class="org-variable-name">attr</span>);

<span class="org-type">int</span> <span class="org-function-name">pthread_cond_destroy</span>(<span class="org-type">pthread_cond_t</span>* <span class="org-variable-name">cond</span>);
</pre>
</div>
<p>
参数attr为NULL,表示创建一个默认属性的条件变量
</p>
</div>
</div>
<div id="outline-container-org8a0f45c" class="outline-4">
<h4 id="org8a0f45c"><span class="section-number-4">5.3.2</span> 等待条件变量变为真</h4>
<div class="outline-text-4" id="text-5-3-2">
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;pthread.h&gt;</span>

<span class="org-type">int</span> <span class="org-function-name">pthread_cond_wait</span>(<span class="org-type">pthread_cond_t</span>* <span class="org-variable-name">cond</span>,<span class="org-type">pthread_mutex_t</span>* <span class="org-variable-name">mutex</span>);

<span class="org-comment-delimiter">/* </span><span class="org-comment">&#33509;&#36229;&#36807;&#26102;&#38388;&#26410;&#31561;&#21040;&#26465;&#20214;&#21464;&#37327;&#20026;&#30495;,&#21017;&#36820;&#22238;ETIMEOUT</span><span class="org-comment-delimiter"> */</span>
<span class="org-type">int</span> <span class="org-function-name">pthread_cond_timedwait</span>(<span class="org-type">pthread_cond_t</span>* <span class="org-variable-name">cond</span>,<span class="org-type">pthread_mutex_t</span>* <span class="org-variable-name">mutex</span>,<span class="org-keyword">const</span> <span class="org-keyword">struct</span> <span class="org-type">timespec</span>* <span class="org-variable-name">timeout</span>);

<span class="org-keyword">struct</span> <span class="org-type">timespec</span>{
  <span class="org-type">time_t</span> <span class="org-variable-name">tv_sec</span>;                <span class="org-comment-delimiter">/* </span><span class="org-comment">&#31186;</span><span class="org-comment-delimiter"> */</span>
  <span class="org-type">long</span> <span class="org-variable-name">tv_nsec</span>;                 <span class="org-comment-delimiter">/* </span><span class="org-comment">&#32435;&#31186;</span><span class="org-comment-delimiter"> */</span>
};
</pre>
</div>
<p>
传递給等待函数的mutex变量应该由 <b>多个等待同一条件变量的线程所共享</b>,且必须 <b>由本线程加锁后再传递給等待函数</b>. 
</p>

<p>
函数内部将调用线程记入等待条件变量的线程列表中,然后对互斥量解锁.即线程在阻塞期间,mutex变量是被解锁的,可以被其他线程再加锁.
</p>

<p>
函数内部将件检查和线程进入休眠状态等待条件变化这两个操作实现为原子操作,即两个操作间无等待时间,这样线程就不会错过条件的任何变化.
</p>

<p>
pthread_cond_wait返回时,互斥量再次被锁定.
</p>

<p>
<b>需要注意的是,从等待函数返回后,线程需要重新计算条件是否满足要求,因为其他的线程可能在运行期间改变了条件,因此等待函数一般在while循环中</b>
</p>
</div>
</div>
<div id="outline-container-orgd49814d" class="outline-4">
<h4 id="orgd49814d"><span class="section-number-4">5.3.3</span> 唤醒线程函数</h4>
<div class="outline-text-4" id="text-5-3-3">
<p>
某线程改变条件状态后,需要再唤醒其他阻塞的线程,让它们重新计算一次条件是否变得满足要求.
</p>
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;pthread.h&gt;</span>

<span class="org-type">int</span> <span class="org-function-name">pthread_cond_signal</span>(<span class="org-type">pthread_cond_t</span>* <span class="org-variable-name">cond</span>);

<span class="org-type">int</span> <span class="org-function-name">pthread_cond_broadcast</span>(<span class="org-type">pthread_cond_t</span>* <span class="org-variable-name">cond</span>);
</pre>
</div>
<ul class="org-ul">
<li>pthread_cond_signal函数唤醒具体等待条件变量的某个线程</li>

<li>pthread_cond_broadcast函数唤醒等待条件变量的所有线程,一般采用这种方式.</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org73ed925" class="outline-3">
<h3 id="org73ed925"><span class="section-number-3">5.4</span> 使用pthread_once函数保证函数只执行一次</h3>
<div class="outline-text-3" id="text-5-4">
<p>
若某个函数(多为初始化函数)在多个线程中都出现,但只需要在某个线程中执行一次即可,则可以使用`pthread_once'函数来保证.
</p>
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;pthread.h&gt;</span>

<span class="org-comment-delimiter">/* </span><span class="org-comment">initflag&#24517;&#39035;&#20026;&#38750;&#26412;&#22320;&#21464;&#37327;,&#21363;&#20840;&#23616;&#21464;&#37327;&#25110;&#38745;&#24577;&#21464;&#37327;</span><span class="org-comment-delimiter"> */</span>
<span class="org-type">pthread_once_t</span> <span class="org-variable-name">initflag</span> = PTHREAD_ONCE_INIT;

<span class="org-comment-delimiter">/* </span><span class="org-comment">&#25104;&#21151;&#36820;&#22238;0,&#22833;&#36133;&#36820;&#22238;&#38169;&#35823;&#32534;&#21495;</span><span class="org-comment-delimiter"> */</span>
<span class="org-type">int</span> <span class="org-function-name">pthread_once</span>(<span class="org-type">pthread_once_t</span>* <span class="org-variable-name">initflag</span>,<span class="org-type">void</span>(<span class="org-function-name">init_func</span>)(<span class="org-type">void</span>));
</pre>
</div>
<ul class="org-ul">
<li>由于initflag必须給多个线程共用,因此它必须为非本地变量,即全局变量或静态变量</li>
<li>initflag的初始化值必须是PTHREAD_ONCE_INIT</li>
<li>每个线程都调用pthread_once,就能保证init_func只被执行一次.</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org95d9ab6" class="outline-2">
<h2 id="org95d9ab6"><span class="section-number-2">6</span> 线程限制</h2>
<div class="outline-text-2" id="text-6">
<p>
可以使用`sysconf'获取系统实现中线程相关的限制
</p>
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;unistd.h&gt;</span>

<span class="org-type">long</span> <span class="org-type">int</span> <span class="org-function-name">sysconf</span>(<span class="org-type">int</span> <span class="org-variable-name">Name</span>);
</pre>
</div>
<p>
其中参数Name可以是:
</p>
<dl class="org-dl">
<dt>_SC_THREAD_DESTRUCTOR_ITERATIONS</dt><dd>线程退出时,操作系统试图销毁线程私有数据的最大次数</dd>
<dt>_SC_THREAD_KEYS_MAX</dt><dd>进程创建key的最大数目</dd>
<dt>_SC_THREAD_STACK_MIN</dt><dd>一个线程栈可用的最小字节数</dd>
<dt>_SC_THREAD_THREADS_MAX</dt><dd>进程可以创建的最大线程数</dd>
</dl>
</div>
</div>
<div id="outline-container-orgee69b49" class="outline-2">
<h2 id="orgee69b49"><span class="section-number-2">7</span> 线程属性</h2>
<div class="outline-text-2" id="text-7">
<p>
可以使用pthread_attr_t结构修改线程默认属性,并把这些属性与创建的线程联系起来.
</p>
</div>
<div id="outline-container-orgc502c8f" class="outline-3">
<h3 id="orgc502c8f"><span class="section-number-3">7.1</span> 初始化/销毁线程属性</h3>
<div class="outline-text-3" id="text-7-1">
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;pthread.h&gt;</span>

<span class="org-type">int</span> <span class="org-function-name">pthread_attr_init</span>(<span class="org-type">pthread_attr_t</span>* <span class="org-variable-name">attr</span>);

<span class="org-type">int</span> <span class="org-function-name">pthread_attr_destory</span>(<span class="org-type">pthread_attr_t</span>* <span class="org-variable-name">attr</span>);
</pre>
</div>
<p>
调用pthread_attr_init以后,pthread_attr_t结构所包含的内容就是操作系统实现支持的线程所有属性的默认值.
</p>
</div>
</div>
<div id="outline-container-orge70fcdf" class="outline-3">
<h3 id="orge70fcdf"><span class="section-number-3">7.2</span> 线程属性的获取与修改</h3>
<div class="outline-text-3" id="text-7-2">
</div>
<div id="outline-container-org974616b" class="outline-4">
<h4 id="org974616b"><span class="section-number-4">7.2.1</span> detachstate(线程的分离状态属性)</h4>
<div class="outline-text-4" id="text-7-2-1">
<p>
如果在创建线程时就知道不需要了解线程的终止状态,则可以修改pthread_attr_t结构中的detachstate线程属性,让线程以分离状态启动.
</p>
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;pthread.h&gt;</span>

<span class="org-comment-delimiter">/* </span><span class="org-comment">&#33719;&#21462;&#32447;&#31243;&#23646;&#24615;&#20998;&#31163;&#29366;&#24577;</span><span class="org-comment-delimiter"> */</span>
<span class="org-type">int</span> <span class="org-function-name">pthread_attr_getdetachstate</span>(<span class="org-keyword">const</span> <span class="org-type">pthread_attr_t</span>* <span class="org-variable-name">attr</span>,<span class="org-type">int</span>* <span class="org-variable-name">detachstate</span>);

<span class="org-type">int</span> <span class="org-function-name">pthread_attr_setdetachstate</span>(<span class="org-type">pthread_attr</span>* <span class="org-variable-name">attr</span>,<span class="org-type">int</span> <span class="org-variable-name">detachstate</span>);
</pre>
</div>
<p>
其中detachstate的可选值为:
</p>
<dl class="org-dl">
<dt>PTHREAD_CREATE_DETACHED</dt><dd>以分离状态启动线程</dd>
<dt>PTHREAD_CREATE_JOINABLE</dt><dd>正常启动线程</dd>
</dl>
</div>
</div>
<div id="outline-container-org7777d31" class="outline-4">
<h4 id="org7777d31"><span class="section-number-4">7.2.2</span> statcsize(线程栈的大小)</h4>
<div class="outline-text-4" id="text-7-2-2">
<p>
可以在编译期间查看是否定义_POSIX_THREAD_ATTR_STACKSIZE来判断系统是否支持该线程属性.
</p>

<p>
对于多线程的进程来说,由于有多个线程栈共享一个进程的虚拟地址空间.
</p>
<ul class="org-ul">
<li>若应用程序使用了太多的线程,会导致线程栈的累计大小超过了可用的虚拟地址空间,这时就需要减少线程默认的栈大小.</li>
<li>若线程调用的函数分配了大量的自动变量,或调用的函数涉及很深的栈帧,则可能需要增加线程栈的大小.</li>
</ul>
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;pthread.h&gt;</span>

<span class="org-type">int</span> <span class="org-function-name">pthread_attr_getstacksize</span>(<span class="org-keyword">const</span> <span class="org-type">pthread_attr_t</span>* <span class="org-variable-name">attr</span>,<span class="org-type">size_t</span>* <span class="org-variable-name">stacksize</span>);

<span class="org-type">int</span> <span class="org-function-name">pthread_attr_setstacksize</span>(<span class="org-type">pthread_attr_t</span>* <span class="org-variable-name">attr</span>,<span class="org-type">size_t</span> <span class="org-variable-name">stacksize</span>);
</pre>
</div>
<p>
若希望改变线程栈的默认大小,但又不想自己处理线程栈的分配问题,这时使用pthread_attr_setstacksize函数就非常有用.
</p>
</div>
</div>
<div id="outline-container-orgfd56537" class="outline-4">
<h4 id="orgfd56537"><span class="section-number-4">7.2.3</span> stackaddr(线程栈的最低地址)</h4>
<div class="outline-text-4" id="text-7-2-3">
<p>
可以在编译阶段使用是否定义了_POSIX_THREAD_ATTR_STACKADDR来判断系统是否支持该线程栈属性
</p>

<p>
若进程的虚拟地址空间被用尽,可以使用malloc来在堆空间上为新线程栈分配空间,并用`pthread_attr_setstack'函数来改变新建线程的栈位置.
</p>
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;pthread.h&gt;</span>

<span class="org-type">int</span> <span class="org-function-name">pthread_attr_getstack</span>(<span class="org-keyword">const</span> <span class="org-type">pthread_attr_t</span>* <span class="org-variable-name">attr</span>,<span class="org-type">void</span>** <span class="org-variable-name">statckaddr</span>,<span class="org-type">size_t</span>* <span class="org-variable-name">stacksize</span>);

<span class="org-type">int</span> <span class="org-function-name">pthread_attr_setstack</span>(<span class="org-keyword">const</span> <span class="org-type">pthread_attr_t</span>* <span class="org-variable-name">attr</span>,<span class="org-type">void</span>* <span class="org-variable-name">stackaddr</span>,<span class="org-type">size_t</span>* <span class="org-variable-name">stacksize</span>);
</pre>
</div>
<p>
这两个函数实际上即用于管理stackaddr线程属性,也用于管理stacksize线程属性.
</p>

<p>
<b>参数stackaddr线程属性被定义为栈的内存单位的最低地址,但不必然是栈的开始位置</b>. 对某些处理器结构来说,栈是从高地址向低地址防线伸展的,那么stackaddr线程属性就是栈的结尾地址而不是开始地址.
</p>
</div>
</div>
<div id="outline-container-org5c9e338" class="outline-4">
<h4 id="org5c9e338"><span class="section-number-4">7.2.4</span> guardsize(线程栈末尾的警戒缓冲区大小)</h4>
<div class="outline-text-4" id="text-7-2-4">
<p>
线程属性guardsize控制着线程栈末尾之后用以避免栈溢出的扩展内存的大小. 这个属性默认值为PAGESIZE.
</p>

<p>
若将guardsize线程属性设为0,则表示不提供警戒缓冲区.
</p>

<p>
<b>若对线程属性stackaddr做了修改,系统假设由我们自己管理栈,不管guardsize线程属性是什么,都会使警戒栈缓冲区机制无效</b>
</p>
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;pthread.h&gt;</span>

<span class="org-type">int</span> <span class="org-function-name">pthread_attr_getguardsize</span>(<span class="org-keyword">const</span> <span class="org-type">pthread_attr_t</span>* <span class="org-variable-name">attr</span>,<span class="org-type">size_t</span>* <span class="org-variable-name">guardsize</span>);

<span class="org-type">int</span> <span class="org-function-name">pthread_attr_setguardsize</span>(<span class="org-type">pthread_attr_t</span>* <span class="org-variable-name">attr</span>,<span class="org-type">size_t</span> <span class="org-variable-name">guardsize</span>);
</pre>
</div>
<ul class="org-ul">
<li>操作系统实际设置警戒缓冲区大小时,可能不一定就是参数guardsize的大小,有可能会修改为页大小的整数倍.</li>
<li>如果线程的栈指针溢出到警戒区域,应用程序就可能通过信号接收到出错信息.</li>
</ul>
</div>
</div>
<div id="outline-container-org03cd497" class="outline-4">
<h4 id="org03cd497"><span class="section-number-4">7.2.5</span> 可取消状态</h4>
<div class="outline-text-4" id="text-7-2-5">
<p>
可取消状态决定了线程在接收到`pthread_cancel'请求后是否退出.
</p>
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;pthread.h&gt;</span>

<span class="org-type">int</span> <span class="org-function-name">pthread_setcancelstate</span>(<span class="org-type">int</span> <span class="org-variable-name">new_state</span>,<span class="org-type">int</span>* <span class="org-variable-name">old_state</span>);
</pre>
</div>
<p>
其中参数state的可选值为:
</p>
<dl class="org-dl">
<dt>PTHREAD_CANCEL_ENABLE</dt><dd>响应pthread_cancel请求,退出</dd>
<dt>PTHREAD_CANCEL_DISABLE</dt><dd>挂起pthread_cancel请求,不退出. <b>等下次取消状态改为ENABLE状态时再响应该请求</b>.</dd>
</dl>
</div>
</div>
<div id="outline-container-org6376d60" class="outline-4">
<h4 id="org6376d60"><span class="section-number-4">7.2.6</span> 可取消类型</h4>
<div class="outline-text-4" id="text-7-2-6">
<p>
可取消类型决定了对`pthread_cancel'请求做出响应后,什么时候退出. 
</p>

<p>
默认情况下是延迟取消,即等到下一个取消点出现时才退出. 但也可以通过`pthread_setcanceltype'设置为异步取消,即不用等退出点,立即退出.
</p>
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;pthread.h&gt;</span>

<span class="org-type">int</span> <span class="org-function-name">pthread</span> setcanceltype(<span class="org-type">int</span> <span class="org-variable-name">new_type</span>,<span class="org-type">int</span>* <span class="org-variable-name">old_type</span>);
</pre>
</div>
<p>
type参数可以为:
</p>
<dl class="org-dl">
<dt>PTHREAD_CANCEL_DEFERRED</dt><dd>延迟取消</dd>
<dt>PTHREAD_CANCEL_ASYNCHRONOUS</dt><dd>异步取消</dd>
</dl>
</div>
</div>
<div id="outline-container-org8dc8ddd" class="outline-4">
<h4 id="org8dc8ddd"><span class="section-number-4">7.2.7</span> 并发度</h4>
<div class="outline-text-4" id="text-7-2-7">
<p>
并发度控制着用户级线程可以映射到内核线程或进程的数量. 因为有些操作系统让多个用户级线程映射为一个内核级线程/进程,这时增加给定时间内可运行的用户级线程数,可能会改善性能.
</p>
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;pthread.h&gt;</span>

<span class="org-type">int</span> <span class="org-function-name">pthread_getconcurrency</span>();

<span class="org-type">int</span> <span class="org-function-name">pthread_setconcurrency</span>(<span class="org-type">int</span> <span class="org-variable-name">level</span>);
</pre>
</div>
<ul class="org-ul">
<li>若没改过并发度,则pthread_getconcurrency函数返回0</li>
<li>pthread_setconcurrency函数设定的并发度只是一个对系统的提示,不一定会被采用</li>
<li>給pthread_setconcurrency函数中的参数level设为0,表示采用系统默认的值.</li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-org7d41080" class="outline-2">
<h2 id="org7d41080"><span class="section-number-2">8</span> 同步属性</h2>
<div class="outline-text-2" id="text-8">
</div>
<div id="outline-container-org2b4ca72" class="outline-3">
<h3 id="org2b4ca72"><span class="section-number-3">8.1</span> 互斥量属性</h3>
<div class="outline-text-3" id="text-8-1">
</div>
<div id="outline-container-org465becb" class="outline-4">
<h4 id="org465becb"><span class="section-number-4">8.1.1</span> 互斥量属性的初始化/销毁</h4>
<div class="outline-text-4" id="text-8-1-1">
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;pthread.h&gt;</span>

<span class="org-comment-delimiter">/* </span><span class="org-comment">&#20351;&#29992;&#40664;&#35748;&#30340;&#20114;&#26021;&#37327;&#23646;&#24615;&#21021;&#22987;&#21270;pthread_mutexattr_t&#32467;&#26500;</span><span class="org-comment-delimiter"> */</span>
<span class="org-type">int</span> <span class="org-function-name">pthread_mutexattr_init</span>(<span class="org-type">pthread_mutexattr_t</span>* <span class="org-variable-name">attr</span>);

<span class="org-type">int</span> <span class="org-function-name">pthread_mutexattr_destroy</span>(<span class="org-type">pthread_mutexattr_t</span>* <span class="org-variable-name">attr</span>);
</pre>
</div>
</div>
</div>
<div id="outline-container-org3979e68" class="outline-4">
<h4 id="org3979e68"><span class="section-number-4">8.1.2</span> 互斥量的共享属性</h4>
<div class="outline-text-4" id="text-8-1-2">
<p>
默认情况下,mutex变量只能是同一进程的不同线程之间才能访问,这时互斥量的共享属性为默认的PTHREAD_PROCESS_PRIVATE
</p>

<p>
但存在某些机制,允许相互独立的多个进程共享同一内存区域,即有时需要多个进程之间同步共享数据,这时需要把互斥量的共享属性设置为PTHREAD_PROCESS_SHARED.
</p>
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;pthread.h&gt;</span>

<span class="org-type">int</span> <span class="org-function-name">pthread_mutexattr_getpshared</span>(<span class="org-keyword">const</span> <span class="org-type">pthread_mutexattr_t</span>* <span class="org-variable-name">attr</span>,<span class="org-type">int</span>* <span class="org-variable-name">pshared</span>);

<span class="org-type">int</span> <span class="org-function-name">pthread_mutexattr_setshared</span>(<span class="org-type">pthread_mutexattr_t</span>* <span class="org-variable-name">attr</span>,<span class="org-type">int</span> <span class="org-variable-name">pshared</span>);
</pre>
</div>
</div>
</div>
<div id="outline-container-org71d4af5" class="outline-4">
<h4 id="org71d4af5"><span class="section-number-4">8.1.3</span> 互斥量的类型属性</h4>
<div class="outline-text-4" id="text-8-1-3">
<p>
互斥量的类型属性控制着互斥量的特性. POSIX.1定义了四种类型的互斥量
</p>
<dl class="org-dl">
<dt>PTHREAD_MUTEX_NORMAL</dt><dd>标准的互斥量类型,不做任何特殊的错误检查或死锁检测</dd>
<dt>PTHREAD_MUTEX_ERRORCHECK</dt><dd>互斥量进行错误检查</dd>
<dt>PTHREAD_MUTEX_RECURSIVE</dt><dd>允许同一线程对互斥量进行重复加锁,但 <b>只有在解锁和加锁次数相同的情况下才会释放锁</b></dd>
<dt>PTHREAD_MUTEX_DEFUALT</dt><dd>用于请求的默认语义,操作系统可以把他实现为上面三种类型的任意一种.</dd>
</dl>
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;pthread.h&gt;</span>

<span class="org-type">int</span> <span class="org-function-name">pthread_mutexattr_gettype</span>(<span class="org-keyword">const</span> <span class="org-type">pthread_mutexattr_t</span>* <span class="org-variable-name">attr</span>, <span class="org-type">int</span>* <span class="org-variable-name">type</span>);

<span class="org-type">int</span> <span class="org-function-name">pthread_mutexattr_settype</span>(<span class="org-type">pthread_mutexattr_t</span>* <span class="org-variable-name">attr</span>,<span class="org-type">int</span> <span class="org-variable-name">type</span>);
</pre>
</div>
<p>
由于`pthread_cond_wait'函数中只会对mutex变量解一次锁,因此当传递递归互斥量到`pthread_cond_wait'时要注意它应该只被加锁一次.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">互斥量类型</th>
<th scope="col" class="org-left">没有解锁时重复加锁</th>
<th scope="col" class="org-left">解锁其他线程加锁的互斥量</th>
<th scope="col" class="org-left">对已解锁的互斥量进行解锁</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">PTHREAD_MUTEX_NORMAL</td>
<td class="org-left">死锁</td>
<td class="org-left">未定义</td>
<td class="org-left">未定义</td>
</tr>

<tr>
<td class="org-left">PTHREAD_MUTEX_ERRORCHECK</td>
<td class="org-left">返回错误</td>
<td class="org-left">返回错误</td>
<td class="org-left">返回错误</td>
</tr>

<tr>
<td class="org-left">PTHREAD_MUTEX_RECURSIVE</td>
<td class="org-left">允许</td>
<td class="org-left">返回错误</td>
<td class="org-left">返回错误</td>
</tr>

<tr>
<td class="org-left">PTHREAD_MUTEX_DEFAULT</td>
<td class="org-left">未定义</td>
<td class="org-left">未定义</td>
<td class="org-left">未定义</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>

<div id="outline-container-org62a8a2d" class="outline-3">
<h3 id="org62a8a2d"><span class="section-number-3">8.2</span> 读写锁属性</h3>
<div class="outline-text-3" id="text-8-2">
</div>
<div id="outline-container-orga38c1a2" class="outline-4">
<h4 id="orga38c1a2"><span class="section-number-4">8.2.1</span> 读写锁初始化/销毁</h4>
<div class="outline-text-4" id="text-8-2-1">
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;pthread.h&gt;</span>

<span class="org-type">int</span> <span class="org-function-name">pthread_rwlockattr_init</span>(<span class="org-type">pthread_rwlockattr_t</span>* <span class="org-variable-name">attr</span>);

<span class="org-type">int</span> <span class="org-function-name">pthread_rwlockattr_destroy</span>(<span class="org-type">pthread_rwlockattr</span>* <span class="org-variable-name">attr</span>);
</pre>
</div>
</div>
</div>
<div id="outline-container-org6920c08" class="outline-4">
<h4 id="org6920c08"><span class="section-number-4">8.2.2</span> 进程共享属性</h4>
<div class="outline-text-4" id="text-8-2-2">
<p>
类似互斥量的进程共享属性
</p>
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;pthread.h&gt;</span>

<span class="org-type">int</span> <span class="org-function-name">pthread_rwlockattr_getpshared</span>(<span class="org-keyword">const</span> <span class="org-type">pthread_rwlockattr_t</span>* <span class="org-variable-name">attr</span>,<span class="org-type">int</span>* <span class="org-variable-name">pshared</span>);

<span class="org-type">int</span> <span class="org-function-name">pthread_rwlockattr_setshared</span>(<span class="org-type">pthread_rwlockattr_t</span>* <span class="org-variable-name">attr</span>,<span class="org-type">int</span> <span class="org-variable-name">pshared</span>);
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orge7c587c" class="outline-3">
<h3 id="orge7c587c"><span class="section-number-3">8.3</span> 条件变量属性</h3>
<div class="outline-text-3" id="text-8-3">
</div>
<div id="outline-container-org5331ae7" class="outline-4">
<h4 id="org5331ae7"><span class="section-number-4">8.3.1</span> 条件变量初始化/销毁</h4>
<div class="outline-text-4" id="text-8-3-1">
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;pthread.h&gt;</span>

<span class="org-type">int</span> <span class="org-function-name">pthread_condattr_init</span>(<span class="org-type">pthread_condattr_t</span>* <span class="org-variable-name">attr</span>);

<span class="org-type">int</span> <span class="org-function-name">pthread_condattr_destroy</span>(<span class="org-type">pthread_condattr</span>* <span class="org-variable-name">attr</span>);
</pre>
</div>
</div>
</div>
<div id="outline-container-orgddbf0e4" class="outline-4">
<h4 id="orgddbf0e4"><span class="section-number-4">8.3.2</span> 进程共享属性</h4>
<div class="outline-text-4" id="text-8-3-2">
<p>
类似互斥量的进程共享属性
</p>
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;pthread.h&gt;</span>

<span class="org-type">int</span> <span class="org-function-name">pthread_condattr_getpshared</span>(<span class="org-keyword">const</span> <span class="org-type">pthread_condattr_t</span>* <span class="org-variable-name">attr</span>,<span class="org-type">int</span>* <span class="org-variable-name">pshared</span>);

<span class="org-type">int</span> <span class="org-function-name">pthread_condattr_setshared</span>(<span class="org-type">pthread_condattr_t</span>* <span class="org-variable-name">attr</span>,<span class="org-type">int</span> <span class="org-variable-name">pshared</span>);
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-orgd4ec2a9" class="outline-2">
<h2 id="orgd4ec2a9"><span class="section-number-2">9</span> 多线程环境下的信号处理</h2>
<div class="outline-text-2" id="text-9">
<p>
每个线程都有自己的信号屏蔽字,但 <b>必须共享同一个信号处理函数</b>. 
</p>

<p>
<b>当主线程创建新线程时,新线程会继承现有的信号屏蔽字</b>
</p>

<p>
进程中产生的信号只能传递給某一个线程中,而无法一次性发送給多个线程. 如果信号与硬件或计时器超时有关,该信号就被发送到引起该事件的线程中去, <b>其他信号则发送到任意一个线程</b>.
</p>
</div>
<div id="outline-container-org88676c8" class="outline-3">
<h3 id="org88676c8"><span class="section-number-3">9.1</span> 多线程与进程中使用信号机制的区别.</h3>
<div class="outline-text-3" id="text-9-1">
<p>
在进程环境中,使用信号的机制为先调用sigaction注册信号处理函数,当信号异步发生时,调用信号处理函数来处理信号,它是完全异步的.
</p>

<p>
而多线程环境中,信号处理的机制是将信号灯的异步处理转换为同步处理. 即使用一个线程专门来同步等待信号的到来(sigwait函数),然后检测到来的信号执行响应的处理. 而其他线程不受信号的影响.
</p>
</div>
</div>
<div id="outline-container-org9c38ff0" class="outline-3">
<h3 id="org9c38ff0"><span class="section-number-3">9.2</span> 设置线程的信号屏蔽字</h3>
<div class="outline-text-3" id="text-9-2">
<p>
进程用于设置信号屏蔽字的函数`sigprocmask'的行为在多线程环境中并未定义,多线程环境中必须使用`pthread_sigmask'代替
</p>
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;signal.h&gt;</span>

<span class="org-comment-delimiter">/* </span><span class="org-comment">&#25104;&#21151;&#36820;&#22238;0,&#22833;&#36133;&#30452;&#25509;&#36820;&#22238;&#38169;&#35823;&#32534;&#21495;</span><span class="org-comment-delimiter"> */</span>
<span class="org-type">int</span> <span class="org-function-name">pthread_sigmask</span>(<span class="org-type">int</span> <span class="org-variable-name">how</span>,<span class="org-keyword">const</span> <span class="org-type">sigset_t</span>* <span class="org-variable-name">set</span>,<span class="org-type">sigset_t</span>* <span class="org-variable-name">old_set</span>);
</pre>
</div>
<p>
`pthread_sigmask'函数与`sigprocmask'函数基本相同,除了pthread_sigmask工作在线程中,并且失败时直接返回错误码,而不是像`sigprocmask'那样返回-1,再设置errno
</p>
</div>
</div>
<div id="outline-container-org2516bfa" class="outline-3">
<h3 id="org2516bfa"><span class="section-number-3">9.3</span> 线程等待信号发生</h3>
<div class="outline-text-3" id="text-9-3">
<p>
线程通过调用`sigwait'等待一个或多个信号发生
</p>
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;signal.h&gt;</span>

<span class="org-comment-delimiter">/* </span><span class="org-comment">&#25104;&#21151;&#36820;&#22238;0,&#21542;&#21017;&#36820;&#22238;&#38169;&#35823;&#32534;&#21495;</span><span class="org-comment-delimiter"> */</span>
<span class="org-type">int</span> <span class="org-function-name">sigwait</span>(<span class="org-keyword">const</span> <span class="org-type">sigset_t</span>* <span class="org-variable-name">set</span>,<span class="org-type">int</span>* <span class="org-variable-name">sig</span>)
</pre>
</div>
<p>
参数set为线程等待的信息集合. 
参数sig为等到的信号编号
</p>

<p>
为了避免信号在线程调用sigwait之前发生从而照成信号丢失,在线程调用sigwait之前,必须阻塞哪些它正在等待的信号. 
<b>sigwait函数会自动取消信号集的阻塞状态,并在等待信号返回前,恢复线程的信号屏蔽字</b>
</p>

<p>
<b>若多个线程调用sigwait等待同一个信号时,只有一个线程能收到信号,从而从sigwait中返回</b>
</p>

<p>
<b>如果即用sigaction注册了信号处理函数,线程又正在sigwait调用中等待同一信号,那么谁捕获到信号由操作系统决定</b>.
</p>
</div>
</div>
<div id="outline-container-org5be2a1b" class="outline-3">
<h3 id="org5be2a1b"><span class="section-number-3">9.4</span> 发送信号給线程</h3>
<div class="outline-text-3" id="text-9-4">
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;signal.h&gt;</span>

<span class="org-comment-delimiter">/* </span><span class="org-comment">&#33509;&#25104;&#21151;&#36820;&#22238;0,&#21542;&#21017;&#36820;&#22238;&#38169;&#35823;&#32534;&#21495;</span><span class="org-comment-delimiter"> */</span>
<span class="org-type">int</span> <span class="org-function-name">pthread_kill</span>(<span class="org-type">pthread_t</span> <span class="org-variable-name">thread</span>,<span class="org-type">int</span> <span class="org-variable-name">signo</span>);
</pre>
</div>
<ul class="org-ul">
<li>可以通过将signo设为0来检测线程是否存在</li>
<li>若信号默认处理动作为终止进程,那么即使是发送信号給某个线程, <b>也会杀掉整个进程</b></li>
<li><b>闹铃定时器是进程资源,由多个线程共享</b></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orge4efd76" class="outline-2">
<h2 id="orge4efd76"><span class="section-number-2">10</span> 多线程环境下的fork</h2>
<div class="outline-text-2" id="text-10">
<p>
父进程fork出的子进程会继承父进程的所有互斥量,读写锁和条件变量的状态,但是却只有线程,即父进程中调用fork的那个线程.
</p>

<p>
因此若父进程中的那些同步变量被其他线程占用,则子进程同样占有这些锁,但同时子进程并没有占有锁的其他线程存在,所以子进程需要在fork的同时清理掉那些被其他线程占用的锁(若子进程立即exec则无此必要)
</p>

<p>
要清除锁状态,需要在父进程中调用`pthread_atfork'函数创建fork处理程序.
</p>
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;pthread.h&gt;</span>

<span class="org-comment-delimiter">/* </span><span class="org-comment">&#25104;&#21151;&#36820;&#22238;0,&#21542;&#21017;&#36820;&#22238;&#38169;&#35823;&#32534;&#21495;</span><span class="org-comment-delimiter"> */</span>
<span class="org-type">int</span> <span class="org-function-name">pthread_atfork</span>(<span class="org-type">void</span> (*<span class="org-function-name">prepare</span>)(<span class="org-type">void</span>),
                   <span class="org-type">void</span> (*<span class="org-function-name">parent</span>)(<span class="org-type">void</span>),
                   <span class="org-type">void</span> (*<span class="org-function-name">child</span>)(<span class="org-type">void</span>));
</pre>
</div>

<ul class="org-ul">
<li>参数prepare会在父进程fork子进程前被调用,它的任务是获取父进程中 <b>所有线程中</b> 定义的 <b>所有锁</b></li>
<li>参数parent会在fork创建子进程后,但在fork返回前在 <b>父进程环境</b> 中调用的,它的任务是对prepare中获得的锁进行解锁</li>
<li>参数child会在fork创建子进程后,但在fork返回前在 <b>子进程环境</b> 中调用,它的任务也是对prepare中获得的锁进行解锁</li>
<li>若参数为NULL,则表示不设置该函数</li>
</ul>
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;stdio.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;pthread.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;unistd.h&gt;</span>

<span class="org-type">pthread_mutex_t</span> <span class="org-variable-name">lock1</span> = PTHREAD_MUTEX_INITIALIZER;
<span class="org-type">pthread_mutex_t</span> <span class="org-variable-name">lock2</span> = PTHREAD_MUTEX_INITIALIZER;

<span class="org-type">void</span> <span class="org-function-name">prepare</span>()
{
  printf(<span class="org-string">"preparing locks...\n"</span>);
  pthread_mutex_lock(&amp;lock1);   <span class="org-comment-delimiter">/* </span><span class="org-comment">&#33719;&#21462;&#38145;1</span><span class="org-comment-delimiter"> */</span>
  pthread_mutex_lock(&amp;lock2);   <span class="org-comment-delimiter">/* </span><span class="org-comment">&#33719;&#21462;&#38145;2</span><span class="org-comment-delimiter"> */</span>
}

<span class="org-type">void</span> <span class="org-function-name">parent</span>()
{
  printf(<span class="org-string">"parent unlocking locks...\n"</span>);
  pthread_mutex_unlock(&amp;lock1); <span class="org-comment-delimiter">/* </span><span class="org-comment">&#37322;&#25918;&#38145;1</span><span class="org-comment-delimiter"> */</span>
  pthread_mutex_unlock(&amp;lock2); <span class="org-comment-delimiter">/* </span><span class="org-comment">&#37322;&#25918;&#38145;2</span><span class="org-comment-delimiter"> */</span>
}

<span class="org-type">void</span> <span class="org-function-name">child</span>()
{
  printf(<span class="org-string">"child unlocking locks...\n"</span>);
  pthread_mutex_unlock(&amp;lock1); <span class="org-comment-delimiter">/* </span><span class="org-comment">&#37322;&#25918;&#38145;1</span><span class="org-comment-delimiter"> */</span>
  pthread_mutex_unlock(&amp;lock2); <span class="org-comment-delimiter">/* </span><span class="org-comment">&#37322;&#25918;&#38145;2</span><span class="org-comment-delimiter"> */</span>
}

<span class="org-type">void</span>* <span class="org-function-name">thread_func</span>(<span class="org-type">void</span>* <span class="org-variable-name">arg</span>)
{
  printf(<span class="org-string">"thread started...\n"</span>);
  pause();
  <span class="org-keyword">return</span> 0;
}

<span class="org-type">int</span> <span class="org-function-name">main</span>()
{
  pthread_atfork(prepare,parent,child);
  <span class="org-type">pthread_t</span> <span class="org-variable-name">tid</span>;
  pthread_create(&amp;tid,<span class="org-constant">NULL</span>,thread_func,0);
  sleep(2);
  printf(<span class="org-string">"parent about to fork...\n"</span>);
  <span class="org-type">pid_t</span> <span class="org-variable-name">pid</span>;
  <span class="org-keyword">if</span>((pid = fork())&lt; 0)
    printf(<span class="org-string">"fork failed\n"</span>);
  <span class="org-keyword">else</span> <span class="org-keyword">if</span>(pid == 0)
    printf(<span class="org-string">"child returned from fork\n"</span>);
  <span class="org-keyword">else</span>
    printf(<span class="org-string">"parent returned from fork\n"</span>);

  <span class="org-keyword">return</span> 0;
}
</pre>
</div>

<p>
thread started&#x2026;
parent about to fork&#x2026;
preparing locks&#x2026;
child unlocking locks&#x2026;
child returned from fork
thread started&#x2026;
parent about to fork&#x2026;
preparing locks&#x2026;
parent unlocking locks&#x2026;
parent returned from fork
</p>

<p>
可以多次调用pthread_at函数从而设置多套fork处理函数,但是每个参数被调用的顺序是不同的:
</p>
<ul class="org-ul">
<li>parent和child函数以它们注册的顺序进程调用</li>
<li>prepare处理函数的调用顺序与注册时的顺序相反</li>
</ul>
</div>
<div id="outline-container-orge46dbcd" class="outline-3">
<h3 id="orge46dbcd"><span class="section-number-3">10.1</span> 多线程环境下fork的问题</h3>
<div class="outline-text-3" id="text-10-1">
<ul class="org-ul">
<li>虽然`pthread_atfork'函数可以用来注册清理锁状态,但是条件变量的清理动作却是未定义的,有的操作系统实现不需要清理条件变量,有的操作系统实现fork之后无法再使用条件变量.</li>
<li>许多库函数的内部实现都用到了锁机制(例如malloc),对于这些库函数而言,`pthread_atfork'函数基本没用</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org9d2eedf" class="outline-2">
<h2 id="org9d2eedf"><span class="section-number-2">11</span> 线程的私有数据(Thread-specific Data)</h2>
<div class="outline-text-2" id="text-11">
<p>
线程私有数据常用于模拟线程私有的全局变量,即这个变量的值在不同线程中是不同,但可以被同一个线程中的多个函数所共享.
</p>

<p>
关于线程私有数据(TSD)的一个明显例子就是errno,每个线程都有自己的errno的值,但线程内部的函数共享一个errno的值
</p>
</div>
<div id="outline-container-orgb9f1b0b" class="outline-3">
<h3 id="orgb9f1b0b"><span class="section-number-3">11.1</span> pthread_key_create</h3>
<div class="outline-text-3" id="text-11-1">
<p>
在分配线程私有数据之前,需要创建与该数据相关联的键. 这个键将用于获取对线程私有函数的访问权. 使用`pthread_key_create'创建一个键
</p>
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;pthread.h&gt;</span>

<span class="org-comment-delimiter">/* </span><span class="org-comment">&#33509;&#25104;&#21151;&#36820;&#22238;0,&#21542;&#21017;&#36820;&#22238;&#38169;&#35823;&#32534;&#21495;</span><span class="org-comment-delimiter"> */</span>
<span class="org-type">int</span> <span class="org-function-name">pthread_key_create</span>(<span class="org-type">pthread_key_t</span>* <span class="org-variable-name">key</span>,<span class="org-type">void</span> (*<span class="org-function-name">destructor</span>)(<span class="org-type">void</span>*))
</pre>
</div>
<ul class="org-ul">
<li>参数key为新创建的键,这个key可以被进程中的所有线程使用,但每个线程都会为这个key与不同的线程私有数据地址相关联. 即不同进程对同一个键对应的数据是不同的.</li>
<li>刚新创建的key,每个线程中与之相关联的数据地址为NULL</li>
<li>析构函数参数destructor若为非NULL,则在线程正常退出时(<b>调用pthread_exit或线程执行返回为正常退出. 调用exit,_exit,_Exit,abort为非正常退出</b>)会用 <b>与该键关联的数据地址为参数来被调用</b></li>
<li>线程通常使用malloc为线程私有数据分配内存空间,并与键相关联. 析构函数通常用于释放已分配的内存</li>
<li>操作系统实现中能创建的最大键数为PTHREAD_KEYS_MAX</li>
<li><p>
由于`pthread_key_create'在多个线程中只需要执行一次就行,因此一般会使用`pthread_once'函数来确保.
</p>
<div class="org-src-container">
<pre class="src src-C"><span class="org-type">void</span> <span class="org-function-name">destructor</span>(<span class="org-type">void</span>*);

<span class="org-type">pthread_key_t</span> <span class="org-variable-name">key</span>;
<span class="org-type">pthread_once_t</span> <span class="org-variable-name">init_done</span> = PTHREAD_ONCE_INIT;

<span class="org-type">void</span> <span class="org-function-name">thread_init</span>()
{
  pthread_key_create(&amp;key,destructor);
}

<span class="org-type">int</span> <span class="org-function-name">thread_func</span>(<span class="org-type">void</span>* <span class="org-variable-name">arg</span>)
{
  pthread_once(&amp;init_done,thread_init);
}
</pre>
</div></li>
</ul>
</div>
</div>
<div id="outline-container-orgf74259b" class="outline-3">
<h3 id="orgf74259b"><span class="section-number-3">11.2</span> pthread_key_delete</h3>
<div class="outline-text-3" id="text-11-2">
<p>
对所有的线程,都可以通过调用`pthread_key_delete'来取消key与线程私有数据的关联. 但需要注意的是: <b>调用`pthread_key_delete'并不会触发与之关联的析构函数</b>
</p>
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;pthread.h&gt;</span>

<span class="org-comment-delimiter">/* </span><span class="org-comment">&#25104;&#21151;&#36820;&#22238;0,&#21542;&#21017;&#36820;&#22238;&#38169;&#35823;&#32534;&#21495;</span><span class="org-comment-delimiter"> */</span>
<span class="org-type">int</span> <span class="org-function-name">pthread_key_delete</span>(<span class="org-type">pthread_key_t</span>* <span class="org-variable-name">key</span>);
</pre>
</div>
</div>
</div>
<div id="outline-container-org4a46f20" class="outline-3">
<h3 id="org4a46f20"><span class="section-number-3">11.3</span> pthread_setspecific/pthread_getspecific</h3>
<div class="outline-text-3" id="text-11-3">
<p>
键一旦创建,就可以
</p>
<ul class="org-ul">
<li>通过调用pthread_setspecific函数把key和线程私有数据关联起来.</li>
<li>通过调用pthread_getspecific函数获得与key关联的线程私有数据地址</li>
</ul>
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;pthread.h&gt;</span>

<span class="org-type">void</span>* <span class="org-function-name">pthread_getspecific</span>(<span class="org-type">pthread_key_t</span> <span class="org-variable-name">key</span>);

<span class="org-type">int</span> <span class="org-function-name">pthread_setspecific</span>(<span class="org-type">pthread_key_t</span> <span class="org-variable-name">key</span>,<span class="org-keyword">const</span> <span class="org-type">void</span>* <span class="org-variable-name">value</span>);
</pre>
</div>
</div>
</div>
</div>

</div>
</div>
<div>
  <div class="post-meta">
    <span title="post date" class="post-info">2015-05-28</span>
    <span title="last modification date" class="post-info">2016-10-24</span>
    <span title="tags" class="post-info">N/A</span>
    <span title="author" class="post-info">DarkSun</span>
  </div>
  <script src="../../../../../media/js/jquery-2.1.3.min.js"></script>
  <script src="../../../../../media/js/md5.min.js"></script>
  <section>
      <div id="gitalk-container"></div>
      <script type="text/javascript">
       var gitalk = new Gitalk({
           clientID: 'fdcb5d9da3f4acb4862c',
           clientSecret: 'dd0a16312a206782cb7669dcec5e96874ab48170',
           repo: 'lujun9972.github.com',
           owner: 'lujun9972',
           admin: ['lujun9972'],
           id: md5(location.pathname),      // Ensure uniqueness and length less than 50
           distractionFreeMode: false  // Facebook-like distraction free mode
       })
       gitalk.render('gitalk-container')
      </script>
  </section>
  <script src="../../../../../media/js/kdComment.js"></script>
      <script>
       var _hmt = _hmt || [];
       (function() {
           var hm = document.createElement("script");
           hm.src = "https://hm.baidu.com/hm.js?7bac4fd0247f69c27887e0d4e3aee41e";
           var s = document.getElementsByTagName("script")[0]; 
           s.parentNode.insertBefore(hm, s);
       })();
      </script>
  <div class="footer">
    <p>Generated by <a href="http://www.gnu.org/software/emacs/">Emacs</a> 27.x(<a href="http://orgmode.org">Org mode</a> 9.x)</p>
    <p>
      Copyright &copy; 2014 - <span id="footerYear"></span> <a href="mailto:travis &lt;at&gt; travis-job-f8772794-b08b-46a0-b59c-8346357cb3da">DarkSun</a>
      &nbsp;&nbsp;-&nbsp;&nbsp;
      Powered by <a href="https://github.com/emacs-china/EGO" target="_blank">EGO</a><br/>
      Themed with <a href="https://github.com/kuangdash/emacs_love" target="_blank">emacs_love</a>
        <a href="http://creativecommons.org/licenses/by-sa/3.0/" rel="license"><img src="https://licensebuttons.net/l/by-sa/3.0/88x31.png" style="border-width:0" alt="Creative Commons License" class="center"></a>
      <script type="text/javascript">document.getElementById("footerYear").innerHTML = (new Date()).getFullYear();</script>
    </p>
  </div>
    </div>

  </body>
</html>
