<!DOCTYPE html>
<html lang="en">
<head>
  <title>网络IPC - 暗无天日</title>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <meta name="author" content="DarkSun" />
  <style>
   #ds-thread #ds-reset .ds-comment-body p {color: #ffffff;}
   #disqus_thread a {color: #00ffff;}
  </style>
  <link rel="stylesheet" media="screen" href="../../../../../media/css/font.css" rel="stylesheet" type="text/css"/>
  <link rel="stylesheet" href="../../../../../media/css/main.css" type="text/css">
  <link rel="stylesheet" href="../../../../../media/css/org-src-fontify.css" type="text/css">
  <link rel="stylesheet" href="../../../../../media/css/kdComment.css" type="text/css">
  <script type="text/javascript"
          src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
  <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
</head>

  <body class="container">
<div>
  <header class="masthead">
    <h1 class="masthead-title"><a href="../../../../../">暗无天日</a></h1>
    <p>=============&gt;随便,谢谢</p>
    <nav class="site-nav">
      <div class="menu-icon">
      </div>
      <ul class="trigger">
              <li><a href="../../../../../years/">Years</a></li>
              <li><a href="../../../../../tags/">Tags</a></li>
              <li><a href="../../../../../about/">About</a></li>
              <li><a href="https://github.com/lujun9972/lujun9972.github.com.git">Github</a></li>
              <li><a href="../../../../../rss.xml">RSS</a></li>
      </ul>
    </nav>
    <form method="get" id="searchform" action="http://www.google.com/search">
        <input type="text" class="field" name="q" id="s" placeholder="Search">
        <input type="hidden" name="as_sitesearch" value="lujun9972.github.io">
    </form>
    <img class="avatar" src="https://avatar.csdnimg.cn/6/2/4/1_lujun9972.jpg" />
  </header>
</div>

<div>
<div class="post">
<h1 class="title">网络IPC</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org4e3430a">1. 套接字描述符</a>
<ul>
<li><a href="#orgcb90acd">1.1. 创建套接字</a></li>
<li><a href="#org5533acb">1.2. 使用文件描述符函数操作套接字描述符</a></li>
<li><a href="#orgdbeccf1">1.3. shutdown函数</a></li>
</ul>
</li>
<li><a href="#org3f954de">2. 寻址</a>
<ul>
<li><a href="#org473ce8b">2.1. 处理器字节序与网络字节序的转换函数</a></li>
<li><a href="#org7ac2fc4">2.2. 地址格式</a></li>
<li><a href="#orgf662b5f">2.3. 地址格式转换</a></li>
<li><a href="#org1d75f18">2.4. 地址映射</a>
<ul>
<li><a href="#org19e1bcc">2.4.1. getaddrinfo</a></li>
<li><a href="#orgb8575e1">2.4.2. gai_strerror</a></li>
<li><a href="#org08cf54a">2.4.3. getnameinfo</a></li>
</ul>
</li>
<li><a href="#orgc10d106">2.5. 将套接字与地址关联</a>
<ul>
<li><a href="#org9661daf">2.5.1. 用bind函数来关联地址和套接字</a></li>
<li><a href="#orgbf31088">2.5.2. getsockname函数来发现绑定到套接字上的地址</a></li>
<li><a href="#orgb7e726c">2.5.3. getperrname函数查找对方的地址</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org5022573">3. 建立连接</a>
<ul>
<li><a href="#org2d4b346">3.1. 客户端建立连接</a></li>
<li><a href="#orgdd7cb24">3.2. 服务端建立连接</a></li>
</ul>
</li>
<li><a href="#org44d58a7">4. 数据传输</a>
<ul>
<li><a href="#org0400044">4.1. send和recv</a></li>
<li><a href="#orgba43bc9">4.2. sendto和recvfrom</a></li>
<li><a href="#org4f707bb">4.3. sendmsg和recvmsg</a></li>
</ul>
</li>
<li><a href="#orga7b9f35">5. 套接字选项</a>
<ul>
<li><a href="#orgfa78ebc">5.1. setsockopt函数设置套接字选项</a></li>
</ul>
</li>
<li><a href="#orgfef93cc">6. 带外数据</a></li>
</ul>
</div>
</div>

<div id="outline-container-org4e3430a" class="outline-2">
<h2 id="org4e3430a"><span class="section-number-2">1</span> 套接字描述符</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-orgcb90acd" class="outline-3">
<h3 id="orgcb90acd"><span class="section-number-3">1.1</span> 创建套接字</h3>
<div class="outline-text-3" id="text-1-1">
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;sys/socket.h&gt;</span>

<span class="org-comment-delimiter">/* </span><span class="org-comment">&#25104;&#21151;&#36820;&#22238;&#22871;&#25509;&#23383;&#25551;&#36848;&#31526;,&#20986;&#38169;&#36820;&#22238;-1</span><span class="org-comment-delimiter"> */</span>
<span class="org-type">int</span> <span class="org-function-name">socket</span>(<span class="org-type">int</span> <span class="org-variable-name">domain</span>,<span class="org-type">int</span> <span class="org-variable-name">type</span>,<span class="org-type">int</span> <span class="org-variable-name">protocol</span>);
</pre>
</div>
<ul class="org-ul">
<li><p>
参数domain确定通讯的特征,包括地址格式
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">domain</th>
<th scope="col" class="org-left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">AF_INET</td>
<td class="org-left">IPv4因特网域</td>
</tr>

<tr>
<td class="org-left">AF_INET6</td>
<td class="org-left">IPv6因特网域</td>
</tr>

<tr>
<td class="org-left">AF_UNIX</td>
<td class="org-left">UNIX域</td>
</tr>

<tr>
<td class="org-left">AF_UNSPEC</td>
<td class="org-left">未指定</td>
</tr>
</tbody>
</table></li>

<li><p>
参数type确定套接字的类型,进一步确定通讯特征
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">type</th>
<th scope="col" class="org-left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">SOCK_DGRAM</td>
<td class="org-left">长度固定的,无连接的不可靠报文传递</td>
</tr>

<tr>
<td class="org-left">SOCK_STREAM</td>
<td class="org-left">有序,可靠,双向的面向连接的字节流,数据传送前需使用connect()来建立连接状态</td>
</tr>

<tr>
<td class="org-left">SOCK_RAW</td>
<td class="org-left">原始的IP协议访问</td>
</tr>

<tr>
<td class="org-left">SOCK_SEQPACKET</td>
<td class="org-left">连续可依赖的数据报连接</td>
</tr>
</tbody>
</table>

<ul class="org-ul">
<li>对于SOCK_STREAM套接字是基于字节流服务的,应用程序无法直到对方发来了多少数据量,因此可能需要通过 <b>多次read调用</b> 才能获取完所有的发来的数据.</li>

<li>SOCK_SEQPACKET与SOCK_STREAM类似,但它是基于报文服务的,因此SOCK_SEQPACKET套接字 <b>一次读入的数据量与对方所发送的一致</b>.</li>

<li>SOCK_RAW套接字提供接口直接访问IP层,应用程序需要负责构造自己的协议首部.</li>
</ul></li>

<li><p>
参数protocol用来指定socket所使用的具体传输协议编号
</p>

<p>
参数protocol通常为0,表示按给给定的域(domain)和套接字类型(type)选择默认协议.
</p>

<p>
AF_INET域+SOCK_STREAM套接字类型的默认协议是TCP
</p>

<p>
AF_INET域+SOCK_DGRAM套接字类型的默认协议是UDP
</p></li>
</ul>
</div>
</div>
<div id="outline-container-org5533acb" class="outline-3">
<h3 id="org5533acb"><span class="section-number-3">1.2</span> 使用文件描述符函数操作套接字描述符</h3>
<div class="outline-text-3" id="text-1-2">
<p>
虽然套接字描述符本质上是一个文件描述符,但不是所有参数为文件描述符的函数都可以接受套接字描述符.
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">函数</th>
<th scope="col" class="org-left">处理套接字时的行为</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">close</td>
<td class="org-left">释放套接字</td>
</tr>

<tr>
<td class="org-left">dup,dup2</td>
<td class="org-left">和一般文件描述符一样复制</td>
</tr>

<tr>
<td class="org-left">fchdir</td>
<td class="org-left">失败,errno为ENOTDIR</td>
</tr>

<tr>
<td class="org-left">fchmod</td>
<td class="org-left">未定义</td>
</tr>

<tr>
<td class="org-left">fchown</td>
<td class="org-left">由实现定义</td>
</tr>

<tr>
<td class="org-left">fcntl</td>
<td class="org-left">支持某些命令,例如F_DUPFD,F_GETFD,F_GETFL,F_GETOWN,F_SETFD,F_SETFL,F_SETOWN</td>
</tr>

<tr>
<td class="org-left">fdatasync,fsync</td>
<td class="org-left">由实现定义</td>
</tr>

<tr>
<td class="org-left">fstat</td>
<td class="org-left">支持某些stat结构成员,但如何支持由实现定义</td>
</tr>

<tr>
<td class="org-left">ftruncate</td>
<td class="org-left">未定义</td>
</tr>

<tr>
<td class="org-left">getmsg,getpmsg</td>
<td class="org-left">若套接字由STREAMS实现则支持</td>
</tr>

<tr>
<td class="org-left">ioctl</td>
<td class="org-left">支持部分命令,依赖低层设备驱动</td>
</tr>

<tr>
<td class="org-left">lseek</td>
<td class="org-left">由实现定义(一般失败,errno为ESPIPE)</td>
</tr>

<tr>
<td class="org-left">nmap</td>
<td class="org-left">未定义</td>
</tr>

<tr>
<td class="org-left">poll</td>
<td class="org-left">正常工作</td>
</tr>

<tr>
<td class="org-left">putmsg,putpmsg</td>
<td class="org-left">若套接字由STREAMS实现则支持</td>
</tr>

<tr>
<td class="org-left">read,readv</td>
<td class="org-left">与没有任何标志位的recv等价</td>
</tr>

<tr>
<td class="org-left">select</td>
<td class="org-left">正常工作</td>
</tr>

<tr>
<td class="org-left">write,writev</td>
<td class="org-left">与没有任何标志位的send等价</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-orgdbeccf1" class="outline-3">
<h3 id="orgdbeccf1"><span class="section-number-3">1.3</span> shutdown函数</h3>
<div class="outline-text-3" id="text-1-3">
<p>
可以使用函数shutdown来禁止套接字上的输入/输出
</p>
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;sys/socket.h&gt;</span>

<span class="org-type">int</span> <span class="org-function-name">shutdown</span>(<span class="org-type">int</span> <span class="org-variable-name">sockfd</span>,<span class="org-type">int</span> <span class="org-variable-name">how</span>);
</pre>
</div>
<p>
参数how可以是:
</p>
<dl class="org-dl">
<dt>SHUT_RD</dt><dd>关闭读</dd>
<dt>SHUT_WR</dt><dd>关闭写</dd>
<dt>SHUT_RDWR</dt><dd>关闭读写</dd>
</dl>

<p>
shutdown与close的区别在于:
</p>
<ul class="org-ul">
<li>若通过dup等操作复制过套接字,则只有在最后一个套接字被关闭后才回释放网络通路.</li>
<li>shutdown不管有多少个套接字连接,都使得连接立即关闭</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org3f954de" class="outline-2">
<h2 id="org3f954de"><span class="section-number-2">2</span> 寻址</h2>
<div class="outline-text-2" id="text-2">
<p>
TCP/IP协议栈规定了采用大端字节序,而处理器字节序分大端和小端两种,因此应用程序需要在处理器的字节序与网络字节序之间进行转换.
</p>
</div>

<div id="outline-container-org473ce8b" class="outline-3">
<h3 id="org473ce8b"><span class="section-number-3">2.1</span> 处理器字节序与网络字节序的转换函数</h3>
<div class="outline-text-3" id="text-2-1">
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;arpa/inet.h&gt;</span>

<span class="org-comment-delimiter">/* </span><span class="org-comment">&#36820;&#22238;&#20197;&#32593;&#32476;&#23383;&#33410;&#24207;&#34920;&#31034;&#30340;32&#20301;&#25972;&#22411;&#25968;</span><span class="org-comment-delimiter"> */</span>
<span class="org-type">uint32_t</span> <span class="org-function-name">htonl</span>(<span class="org-type">uint32_t</span> <span class="org-variable-name">hostint32</span>);

<span class="org-comment-delimiter">/* </span><span class="org-comment">&#36820;&#22238;&#20197;&#32593;&#32476;&#23383;&#33410;&#24207;&#34920;&#31034;&#30340;16&#20301;&#25972;&#22411;&#25968;</span><span class="org-comment-delimiter"> */</span>
<span class="org-type">uint16_t</span> <span class="org-function-name">htons</span>(<span class="org-type">uint16_t</span> <span class="org-variable-name">hostint16</span>);

<span class="org-comment-delimiter">/* </span><span class="org-comment">&#36820;&#22238;&#20197;&#20027;&#26426;&#23383;&#33410;&#24207;&#34920;&#31034;&#30340;32&#20301;&#25972;&#22411;&#25968;</span><span class="org-comment-delimiter"> */</span>
<span class="org-type">uint32_t</span> <span class="org-function-name">ntohl</span>(<span class="org-type">uint32_t</span> <span class="org-variable-name">netint32</span>);

<span class="org-comment-delimiter">/* </span><span class="org-comment">&#36820;&#22238;&#20197;&#20027;&#26426;&#23383;&#33410;&#24207;&#34920;&#31034;&#30340;16&#20301;&#25972;&#22411;&#25968;</span><span class="org-comment-delimiter"> */</span>
<span class="org-type">uint16_t</span> <span class="org-function-name">ntohs</span>(<span class="org-type">uint16_t</span> <span class="org-variable-name">netint16</span>);

</pre>
</div>
</div>
</div>

<div id="outline-container-org7ac2fc4" class="outline-3">
<h3 id="org7ac2fc4"><span class="section-number-3">2.2</span> 地址格式</h3>
<div class="outline-text-3" id="text-2-2">
<p>
一个地址用于标识一个特定通讯域的套接字端点,因此地址格式与特定的通讯域相关.
</p>

<p>
为了使不同格式地址能够传入到套接字函数,地址会被 <b>强制转换为一个通用的地址结构sockaddr</b>:
</p>
<div class="org-src-container">
<pre class="src src-C"><span class="org-keyword">struct</span> <span class="org-type">sockaddr</span>{
  <span class="org-type">sa_family_t</span> <span class="org-variable-name">sa_family</span>;        <span class="org-comment-delimiter">/* </span><span class="org-comment">address&#30340;&#21327;&#35758;&#31181;&#31867;</span><span class="org-comment-delimiter"> */</span>
  <span class="org-type">char</span> <span class="org-variable-name">sa_data</span>[];               <span class="org-comment-delimiter">/* </span><span class="org-comment">&#22823;&#23567;&#21487;&#21464;&#30340;&#22320;&#22336;</span><span class="org-comment-delimiter"> */</span>
  <span class="org-comment-delimiter">/* </span><span class="org-comment">&#20854;&#20182;&#25104;&#21592;</span><span class="org-comment-delimiter"> */</span>
}
</pre>
</div>

<p>
因特网地址定义在&lt;netinet/in.h&gt;头文件中. 在IPv4因特网域(AF_INET)中,套接字的地址用结构sockaddr_in表示:
</p>
<div class="org-src-container">
<pre class="src src-C"><span class="org-keyword">struct</span> <span class="org-type">sockaddr_in</span>
{
  <span class="org-type">sa_family_t</span> <span class="org-variable-name">sin_family</span>;       <span class="org-comment-delimiter">/* </span><span class="org-comment">&#22320;&#22336;family</span><span class="org-comment-delimiter"> */</span>
  <span class="org-type">in_port_t</span> <span class="org-variable-name">sin_port</span>;           <span class="org-comment-delimiter">/* </span><span class="org-comment">&#31471;&#21475;&#21495;,&#23454;&#38469;&#19968;&#33324;&#20026;uint16_t</span><span class="org-comment-delimiter"> */</span>
  <span class="org-keyword">struct</span> <span class="org-type">in_addr</span> <span class="org-variable-name">sin_addr</span>;      <span class="org-comment-delimiter">/* </span><span class="org-comment">IPv4&#22320;&#22336;</span><span class="org-comment-delimiter"> */</span>
};

<span class="org-keyword">struct</span> <span class="org-type">in_addr</span>
{
  <span class="org-type">in_addr_t</span> <span class="org-variable-name">s_addr</span>;             <span class="org-comment-delimiter">/* </span><span class="org-comment">IPv4&#22320;&#22336;,&#23454;&#38469;&#19968;&#33324;&#20026;uint32_t</span><span class="org-comment-delimiter"> */</span>
};
</pre>
</div>

<p>
IPv6则用结构sockaddr_in6表示:
</p>
<div class="org-src-container">
<pre class="src src-C"><span class="org-keyword">struct</span> <span class="org-type">sockaddr_in6</span>{
  <span class="org-type">sa_family_t</span> <span class="org-variable-name">sin6_family</span>;      <span class="org-comment-delimiter">/* </span><span class="org-comment">&#22320;&#22336;family</span><span class="org-comment-delimiter"> */</span>
  <span class="org-type">in_port_t</span> <span class="org-variable-name">sin6_port</span>;          <span class="org-comment-delimiter">/* </span><span class="org-comment">&#31471;&#21475;&#21495;</span><span class="org-comment-delimiter"> */</span>
  <span class="org-type">uint32_t</span> <span class="org-variable-name">sin6_flowinfo</span>;       <span class="org-comment-delimiter">/* </span><span class="org-comment">traffic class and flow info</span><span class="org-comment-delimiter"> */</span>
  <span class="org-keyword">struct</span> <span class="org-type">in6_addr</span> <span class="org-variable-name">sin6_addr</span>;    <span class="org-comment-delimiter">/* </span><span class="org-comment">IPv6&#22320;&#22336;</span><span class="org-comment-delimiter"> */</span>
  <span class="org-type">uint32_t</span> <span class="org-variable-name">sin6_scope_id</span>;       <span class="org-comment-delimiter">/* </span><span class="org-comment">set of interfaces for scope</span><span class="org-comment-delimiter"> */</span>
};

<span class="org-keyword">struct</span> <span class="org-type">in6_addr</span>{
  <span class="org-type">uint8_t</span> <span class="org-variable-name">sa_addr</span>[16];          <span class="org-comment-delimiter">/* </span><span class="org-comment">IPv6&#22320;&#22336;</span><span class="org-comment-delimiter"> */</span>
};
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf662b5f" class="outline-3">
<h3 id="orgf662b5f"><span class="section-number-3">2.3</span> 地址格式转换</h3>
<div class="outline-text-3" id="text-2-3">
<p>
通过inet_ntop能把IPv4和IPv6的地址转换为人能理解的字符串格式
</p>
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;arpa/inet.h&gt;</span>

<span class="org-comment-delimiter">/* </span><span class="org-comment">&#25104;&#21151;&#36820;&#22238;&#22320;&#22336;&#23383;&#31526;&#20018;&#25351;&#38024;. &#26684;&#24335;&#26080;&#25928;&#36820;&#22238;0. &#20986;&#38169;&#36820;&#22238;-1</span><span class="org-comment-delimiter"> */</span>
<span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-function-name">inet_ntop</span>(<span class="org-type">int</span> <span class="org-variable-name">domain</span>,<span class="org-keyword">const</span> <span class="org-type">void</span>* <span class="org-variable-name">addr</span>,<span class="org-type">char</span>* <span class="org-variable-name">str</span>,<span class="org-type">socklen_t</span> <span class="org-variable-name">size</span>);
</pre>
</div>
<ul class="org-ul">
<li>参数domain仅支持AF_INET和AF_INET6</li>
<li>参数size指定了str缓存区的大小,INET_ADDRSTRLEN/INET6_ADDRSTRLEN定义了足够大的空间存放存放表示IPv4/IPv6地址的文本字符串.</li>
</ul>

<p>
通过inet_pton能把人理解的字符串格式转换成网络字节序的二进制格式.
</p>
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;arpa/inet.h&gt;</span>

<span class="org-comment-delimiter">/* </span><span class="org-comment">&#33509;&#25104;&#21151;,&#36820;&#22238;1;&#26684;&#24335;&#26080;&#25928;&#36820;&#22238;0;&#20986;&#38169;&#36820;&#22238;-1</span><span class="org-comment-delimiter"> */</span>
<span class="org-type">int</span> <span class="org-function-name">inet_pton</span>(<span class="org-type">int</span> <span class="org-variable-name">domian</span>,<span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">str</span>,<span class="org-type">void</span>* <span class="org-variable-name">addr</span>);
</pre>
</div>
</div>
</div>

<div id="outline-container-org1d75f18" class="outline-3">
<h3 id="org1d75f18"><span class="section-number-3">2.4</span> 地址映射</h3>
<div class="outline-text-3" id="text-2-4">
<p>
POSIX.1定义了若干新函数,用于将一个主机名和服务器名映射到一个地址或者反之.
</p>
</div>
<div id="outline-container-org19e1bcc" class="outline-4">
<h4 id="org19e1bcc"><span class="section-number-4">2.4.1</span> getaddrinfo</h4>
<div class="outline-text-4" id="text-2-4-1">
<p>
getaddrinfo函数允许将一个主机名和服务名映射到一个地址
</p>
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;sys/socket.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;netdb.h&gt;</span>

<span class="org-type">int</span> <span class="org-function-name">getaddrinfo</span>(<span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">host</span>,
                <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">service</span>,
                <span class="org-keyword">const</span> <span class="org-keyword">struct</span> <span class="org-type">addrinfo</span>* <span class="org-variable-name">hint</span>,
                <span class="org-keyword">struct</span> <span class="org-type">addrinfo</span>** <span class="org-variable-name">res</span>);

<span class="org-type">void</span> <span class="org-function-name">freeaddrinfo</span>(<span class="org-keyword">struct</span> <span class="org-type">addrinfo</span>* <span class="org-variable-name">ai</span>);

<span class="org-keyword">struct</span> <span class="org-type">addrinfo</span>
{
  <span class="org-type">int</span> <span class="org-variable-name">ai_flags</span>;                 <span class="org-comment-delimiter">/*  */</span>
  <span class="org-type">int</span> <span class="org-variable-name">ai_family</span>;                <span class="org-comment-delimiter">/* </span><span class="org-comment">&#22320;&#22336;&#26063;,&#22914;AF_INET,AF_INET6,AF_UNIX...</span><span class="org-comment-delimiter">*/</span>
  <span class="org-type">int</span> <span class="org-variable-name">ai_socktype</span>;              <span class="org-comment-delimiter">/* </span><span class="org-comment">socket&#31867;&#22411;,&#22914;SOCK_STREAM,SOCK_DGRAM,SOCK_SEQPACKET,SOCK_RAW</span><span class="org-comment-delimiter"> */</span>
  <span class="org-type">int</span> <span class="org-variable-name">ai_protocol</span>;              <span class="org-comment-delimiter">/* </span><span class="org-comment">&#21327;&#35758;,&#22914;IPPROTO_TCP,IPPROTO_UDP,IPPROTO_RAW</span><span class="org-comment-delimiter"> */</span>
  <span class="org-type">socklen_t</span> <span class="org-variable-name">ai_addrlen</span>;         <span class="org-comment-delimiter">/* </span><span class="org-comment">&#22320;&#22336;&#30340;&#23383;&#33410;&#38271;&#24230;</span><span class="org-comment-delimiter"> */</span>
  <span class="org-keyword">struct</span> <span class="org-type">sockaddr</span>* <span class="org-variable-name">ai_addr</span>;     <span class="org-comment-delimiter">/* </span><span class="org-comment">&#22320;&#22336;</span><span class="org-comment-delimiter"> */</span>
  <span class="org-type">char</span>* <span class="org-variable-name">ai_canonname</span>;           <span class="org-comment-delimiter">/* </span><span class="org-comment">&#20027;&#26426;&#30340;canonical name</span><span class="org-comment-delimiter"> */</span>
  <span class="org-keyword">struct</span> <span class="org-type">addrinfo</span>* <span class="org-variable-name">ai_next</span>;     <span class="org-comment-delimiter">/* </span><span class="org-comment">&#21015;&#34920;&#20013;&#30340;&#19979;&#19968;&#20010;addrinfo&#20803;&#32032;</span><span class="org-comment-delimiter"> */</span>
  <span class="org-comment-delimiter">/* </span><span class="org-comment">&#20854;&#20182;&#25104;&#21592;</span><span class="org-comment-delimiter"> */</span>
};
</pre>
</div>
<ul class="org-ul">
<li>参数host和service必须至少指定一个值,如果仅提供一个值,那么另一个必须是 <b>空指针</b></li>
<li>参数host可以是一个节点名或点分结构的主机地址</li>
<li>参数hint为一个过滤模板,用来选择符合特定条件的地址. 其包含ai_family,ai_flags,ai_protocol和ai_socktype字段, <b>剩余的整数字段必须设置为0,指针必须为NULL</b></li>
<li>结果res为一个元素为addrinfo的链表结构</li>
<li><p>
ai_flags字段中的标志意义为:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">标志</th>
<th scope="col" class="org-left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">AI_ADDRCONFIG</td>
<td class="org-left">查询配置的地址类型(IPv4/IPv6)</td>
</tr>

<tr>
<td class="org-left">AI_ALL</td>
<td class="org-left">查找IPv4和IPv6地址(仅用于AI_V4MAPPED)</td>
</tr>

<tr>
<td class="org-left">AI_CANONNAME</td>
<td class="org-left">需要一个规范的别名(非别名)</td>
</tr>

<tr>
<td class="org-left">AI_NUMERICHOST</td>
<td class="org-left">以数字格式指定主机地址</td>
</tr>

<tr>
<td class="org-left">AI_NUMERICSERV</td>
<td class="org-left">以数字端口号指定服务名</td>
</tr>

<tr>
<td class="org-left">AI_PASSIVE</td>
<td class="org-left">套接字地址用于监听绑定</td>
</tr>

<tr>
<td class="org-left">AI_V4MAPPED</td>
<td class="org-left">将IPv4的地址映射为IPv6</td>
</tr>
</tbody>
</table></li>
</ul>
</div>
</div>
<div id="outline-container-orgb8575e1" class="outline-4">
<h4 id="orgb8575e1"><span class="section-number-4">2.4.2</span> gai_strerror</h4>
<div class="outline-text-4" id="text-2-4-2">
<p>
<b>如果getaddrinfo失败,不能使用perror或strerror来生成错误信息,而需要用gai_strerror将返回值转换成错误信息</b>
</p>
<div class="org-src-container">
<pre class="src src-C"><span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-function-name">gai_strerror</span>(<span class="org-type">int</span> <span class="org-variable-name">error</span>);
</pre>
</div>
</div>
</div>
<div id="outline-container-org08cf54a" class="outline-4">
<h4 id="org08cf54a"><span class="section-number-4">2.4.3</span> getnameinfo</h4>
<div class="outline-text-4" id="text-2-4-3">
<p>
getnameinfo函数将一个地址转换成一个主机名和服务名
</p>
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;sys/socket.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;netdb.h&gt;</span>

<span class="org-type">int</span> <span class="org-function-name">getnameinfo</span>(<span class="org-keyword">const</span> <span class="org-keyword">struct</span> <span class="org-type">sockaddr</span>* <span class="org-variable-name">addr</span>, <span class="org-type">socklen_t</span> <span class="org-variable-name">alen</span>,
                <span class="org-type">char</span>* <span class="org-variable-name">host</span>, <span class="org-type">socklen_t</span> <span class="org-variable-name">hostlen</span>,
                <span class="org-type">char</span>* <span class="org-variable-name">service</span>,<span class="org-type">socklen_t</span> <span class="org-variable-name">servlen</span>,
                <span class="org-type">int</span> <span class="org-variable-name">flags</span>);
</pre>
</div>
<ul class="org-ul">
<li><p>
flags参数提供了一些控制翻译的方式
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">标志</th>
<th scope="col" class="org-left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">NI_DGRAM</td>
<td class="org-left">服务基于数据报而非流</td>
</tr>

<tr>
<td class="org-left">NI_NAMEREQD</td>
<td class="org-left">如果找不到主机名,则报错</td>
</tr>

<tr>
<td class="org-left">NI_NOFQDN</td>
<td class="org-left">对于本地主机,仅返回全限定域名的节点名部分</td>
</tr>

<tr>
<td class="org-left">NI_NUMERICHOST</td>
<td class="org-left">返回主机地址的数字形式,而非主机名</td>
</tr>

<tr>
<td class="org-left">NI_NUMERICSCOPE</td>
<td class="org-left">对于IPv6,返回返回ID的数字形式,而非名字</td>
</tr>

<tr>
<td class="org-left">NI_NUMERICSERV</td>
<td class="org-left">返回服务地址的数字形式(端口号),而非名字</td>
</tr>
</tbody>
</table></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgc10d106" class="outline-3">
<h3 id="orgc10d106"><span class="section-number-3">2.5</span> 将套接字与地址关联</h3>
<div class="outline-text-3" id="text-2-5">
</div>
<div id="outline-container-org9661daf" class="outline-4">
<h4 id="org9661daf"><span class="section-number-4">2.5.1</span> 用bind函数来关联地址和套接字</h4>
<div class="outline-text-4" id="text-2-5-1">
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;sys/socket.h&gt;</span>

<span class="org-type">int</span> <span class="org-function-name">bind</span>(<span class="org-type">int</span> <span class="org-variable-name">sockfd</span>,<span class="org-keyword">const</span> <span class="org-keyword">struct</span> <span class="org-type">sockaddr</span>* <span class="org-variable-name">addr</span>,<span class="org-type">socklen_t</span> <span class="org-variable-name">len</span>);
</pre>
</div>
<ul class="org-ul">
<li>绑定的地址必须是本地计算机的地址</li>
<li>地址格式必须与创建套接字时指定的地址族相匹配</li>
<li>地址中的端口号大于或等于1024,除非进程拥有root权限</li>
<li>bind操作是非必须的,若connect或listen时没有将地址绑定到套接字上,系统会选择一个地址绑定到套接字上</li>
</ul>
</div>
</div>
<div id="outline-container-orgbf31088" class="outline-4">
<h4 id="orgbf31088"><span class="section-number-4">2.5.2</span> getsockname函数来发现绑定到套接字上的地址</h4>
<div class="outline-text-4" id="text-2-5-2">
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;sys/socket.h&gt;</span>

<span class="org-type">int</span> <span class="org-function-name">getsockname</span>(<span class="org-type">int</span> <span class="org-variable-name">sockfd</span>,<span class="org-keyword">struct</span> <span class="org-type">sockaddr</span>* <span class="org-variable-name">addr</span>, <span class="org-type">socklen_t</span>* <span class="org-variable-name">alenp</span>);
</pre>
</div>
<p>
调用getsockname前,alenp指向一个整数,且该整数为缓冲区sockaddr的长度,返回时, <b>该整数会被设置成返回地址的大小</b>
</p>
</div>
</div>
<div id="outline-container-orgb7e726c" class="outline-4">
<h4 id="orgb7e726c"><span class="section-number-4">2.5.3</span> getperrname函数查找对方的地址</h4>
<div class="outline-text-4" id="text-2-5-3">
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;sys/socket.h&gt;</span>

<span class="org-type">int</span> <span class="org-function-name">getpeername</span>(<span class="org-type">int</span> <span class="org-variable-name">sockfd</span>,<span class="org-keyword">struct</span> <span class="org-type">sockaddr</span>* <span class="org-variable-name">addr</span>,<span class="org-type">socklen_t</span>* <span class="org-variable-name">alenp</span>)
</pre>
</div>
<p>
与getsockname类似,但sockfd需已经和对方建立连接,且返回的是对方的地址.
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org5022573" class="outline-2">
<h2 id="org5022573"><span class="section-number-2">3</span> 建立连接</h2>
<div class="outline-text-2" id="text-3">
</div>
<div id="outline-container-org2d4b346" class="outline-3">
<h3 id="org2d4b346"><span class="section-number-3">3.1</span> 客户端建立连接</h3>
<div class="outline-text-3" id="text-3-1">
<p>
在客户端上使用connect函数来建立与服务端之间的连接
</p>
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;sys/socket.h&gt;</span>

<span class="org-type">int</span> <span class="org-function-name">connect</span>(<span class="org-type">int</span> <span class="org-variable-name">sockfd</span>,<span class="org-keyword">const</span> <span class="org-keyword">struct</span> <span class="org-type">sockaddr</span>* <span class="org-variable-name">addr</span>,<span class="org-type">socklen_t</span> <span class="org-variable-name">len</span>);
</pre>
</div>
<ul class="org-ul">
<li>addr为服务器地址</li>
<li>参数len为结构体sockaddr的长度(sockaddr的长度是可变的,还记得吗?)</li>
<li>connect将sockfd与远程服务器连接,之后即可通过对sockfd进行读写的方式与远程服务器交互了.</li>
</ul>
</div>
</div>

<div id="outline-container-orgdd7cb24" class="outline-3">
<h3 id="orgdd7cb24"><span class="section-number-3">3.2</span> 服务端建立连接</h3>
<div class="outline-text-3" id="text-3-2">
<p>
在服务端调用listen函数监听端口
</p>
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;sys/socket.h&gt;</span>

<span class="org-comment-delimiter">/* </span><span class="org-comment">&#25104;&#21151;&#36820;&#22238;0,&#19981;&#25104;&#21151;&#36820;&#22238;-1</span><span class="org-comment-delimiter"> */</span>
<span class="org-type">int</span> <span class="org-function-name">listen</span>(<span class="org-type">int</span> <span class="org-variable-name">sockfd</span>,<span class="org-type">int</span> <span class="org-variable-name">backlog</span>);
</pre>
</div>
<ul class="org-ul">
<li>参数backlog指定了同时能处理的最大连接数,其上限由&lt;sys/socket.h&gt;中的SOMAXCONN指定</li>
<li>如果连接数目达到上限则client端将收到ECONNREFUSED操作</li>
<li>listen函数并未开始接受连接,它只是设置socket为listen模式,真正接受client端连接的是accept函数</li>
<li>通常的调用顺序为socket(),bind(),listen(),accept()</li>
</ul>


<p>
服务端使用accept函数获取连接请求并建立连接
</p>
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;sys/socket.h&gt;</span>

<span class="org-comment-delimiter">/* </span><span class="org-comment">&#33509;&#25104;&#21151;&#21017;&#36820;&#22238;&#26032;&#30340;&#24050;&#24314;&#31435;&#36830;&#25509;&#30340;&#22871;&#25509;&#23383;&#25551;&#36848;&#31526;</span><span class="org-comment-delimiter"> */</span>
<span class="org-type">int</span> <span class="org-function-name">accept</span>(<span class="org-type">int</span> <span class="org-variable-name">sockfd</span>,<span class="org-keyword">struct</span> <span class="org-type">sockaddr</span>* <span class="org-variable-name">addr</span>,<span class="org-type">socklen_t</span>* <span class="org-variable-name">len</span>);
</pre>
</div>
<ul class="org-ul">
<li>参数sockfd为调用listen之后的套接字</li>
<li>参数addr可以用来查看是哪个客户端发起的连接请求, <b>若对客户端无要求,可以将addr与len都设置为NULL</b></li>
<li>如果没有连接请求在等待,accept会阻塞直到一个请求的到来. 若sockfd为非阻塞模式,则accept返回-1,且errno为EAGAIN或EWOULDBLOCK.</li>
<li><b>服务器也可以使用poll或select来等待一个请求的到来,这时,一个带有等待连接请求的套接字会以可读的方式出现</b></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org44d58a7" class="outline-2">
<h2 id="org44d58a7"><span class="section-number-2">4</span> 数据传输</h2>
<div class="outline-text-2" id="text-4">
<p>
除了read和write外,还有三对为数据传递而设计的套接字函数
</p>
</div>

<div id="outline-container-org0400044" class="outline-3">
<h3 id="org0400044"><span class="section-number-3">4.1</span> send和recv</h3>
<div class="outline-text-3" id="text-4-1">
<p>
send和write很类似,但可以指定标志来改变传输数据的方式
</p>
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;sys/socket.h&gt;</span>

<span class="org-type">ssize_t</span> <span class="org-function-name">send</span>(<span class="org-type">int</span> <span class="org-variable-name">sockfd</span>,<span class="org-keyword">const</span> <span class="org-type">void</span>* <span class="org-variable-name">buf</span>,<span class="org-type">size_t</span> <span class="org-variable-name">nbytes</span>,<span class="org-type">int</span> <span class="org-variable-name">flags</span>);
</pre>
</div>
<ul class="org-ul">
<li><p>
flag参数说明
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">标志</th>
<th scope="col" class="org-left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">MSG_CONFIRM</td>
<td class="org-left">提供链路层以保持地址映射有效</td>
</tr>

<tr>
<td class="org-left">MSG_DONTROUTE</td>
<td class="org-left">不将数据报邮路出本地网络</td>
</tr>

<tr>
<td class="org-left">MSG_DONTWAIT</td>
<td class="org-left">非阻塞操作(等价于O_NONBLOCK)</td>
</tr>

<tr>
<td class="org-left">MSG_EOF</td>
<td class="org-left">发送数据后关闭套接字的发送端</td>
</tr>

<tr>
<td class="org-left">MSG_EOR</td>
<td class="org-left">如果协议支持,标记记录结束</td>
</tr>

<tr>
<td class="org-left">MSG_MORE</td>
<td class="org-left">延迟发送数据包,以允许写更多数据</td>
</tr>

<tr>
<td class="org-left">MSG_NOSIGNAL</td>
<td class="org-left">在写无连接的套接字时不产生SIGPIPE信号</td>
</tr>

<tr>
<td class="org-left">MSG_OOB</td>
<td class="org-left">如果协议支持,发送带外数据</td>
</tr>
</tbody>
</table></li>
<li>send函数返回,表示数据已经无错误地发送到网络驱动程序上,但 <b>不代表连接的另一端进程就接受了数据</b></li>
<li>对于支持报文边界的协议,如果尝试发送的单个报文的长度超过协议支持的最大长度,那么send会失败,且errno为EMSGSIZE</li>
<li>对于字节流协议,send会阻塞直到整个数据传输完成</li>
</ul>


<p>
recv函数与read类似,但recv可以指定标志来控制如何接受数据.
</p>
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;sys/socket.h&gt;</span>

<span class="org-type">ssize_t</span> <span class="org-function-name">recv</span>(<span class="org-type">int</span> <span class="org-variable-name">sockfd</span>,<span class="org-type">void</span>* <span class="org-variable-name">buf</span>,<span class="org-type">size_t</span> <span class="org-variable-name">nbytes</span>,<span class="org-type">int</span> <span class="org-variable-name">flags</span>);
</pre>
</div>
<ul class="org-ul">
<li><p>
参数flag说明
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">标志</th>
<th scope="col" class="org-left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">MSG_CMSG_CLOEXEC</td>
<td class="org-left">为UNIX域套接字上接收的文件描述符设置执行时关闭标志</td>
</tr>

<tr>
<td class="org-left">MSG_DONTWAIT</td>
<td class="org-left">非阻塞操作(类似O_NONBLOCK)</td>
</tr>

<tr>
<td class="org-left">MSG_ERRQUEUE</td>
<td class="org-left">接收错误信息作为辅助数据</td>
</tr>

<tr>
<td class="org-left">MSG_OOB</td>
<td class="org-left">如果协议支持,获取带外数据</td>
</tr>

<tr>
<td class="org-left">MSG_PEEK</td>
<td class="org-left">返回数据包内容,但不真正取走数据</td>
</tr>

<tr>
<td class="org-left">MSG_TRUNC</td>
<td class="org-left">即使数据包被截断,也返回数据包的实际长度</td>
</tr>

<tr>
<td class="org-left">MSG_WAITALL</td>
<td class="org-left">强迫接收到nbytes大小的数据后才返回(仅SOCK_STREAM),除非有错误或信号产生</td>
</tr>

<tr>
<td class="org-left">MSG_NOSIGNAL</td>
<td class="org-left">该操作不能被SIGPIPE信号中断</td>
</tr>
</tbody>
</table></li>
</ul>
</div>
</div>

<div id="outline-container-orgba43bc9" class="outline-3">
<h3 id="orgba43bc9"><span class="section-number-3">4.2</span> sendto和recvfrom</h3>
<div class="outline-text-3" id="text-4-2">
<p>
sendto和send很类似,区别在于sendto可以在无连接的套接字上指定一个目标地址.
</p>
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;sys/socket.h&gt;</span>

<span class="org-comment-delimiter">/* </span><span class="org-comment">&#33509;&#25104;&#21151;&#36820;&#22238;&#21457;&#36865;&#30340;&#23383;&#33410;&#25968;,&#20986;&#38169;&#36820;&#22238;-1</span><span class="org-comment-delimiter"> */</span>
<span class="org-type">ssize_t</span> <span class="org-function-name">sendto</span>(<span class="org-type">int</span> <span class="org-variable-name">sockfd</span>,<span class="org-keyword">const</span> <span class="org-type">void</span>* <span class="org-variable-name">buf</span>,<span class="org-type">size_t</span> <span class="org-variable-name">nbytes</span>,<span class="org-type">int</span> <span class="org-variable-name">flags</span>,
               <span class="org-keyword">const</span> <span class="org-keyword">struct</span> <span class="org-type">sockaddr</span>* <span class="org-variable-name">destaddr</span>,<span class="org-type">socklen_t</span> <span class="org-variable-name">destlen</span>);
</pre>
</div>
<ul class="org-ul">
<li>对于面向连接的套接字,目标地址参数被忽略,因为连接中隐含了目标地址. <b>因此sendto函数一般用于无连接的套接字</b></li>
</ul>

<p>
recvfrom也可以在无连接的套接字上指定一个目标地址
</p>
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;sys/socket.h&gt;</span>

<span class="org-type">ssize_t</span> <span class="org-function-name">recvfrom</span>(<span class="org-type">int</span> <span class="org-variable-name">sockfd</span>,<span class="org-type">void</span>* <span class="org-variable-name">buf</span>,<span class="org-type">size_t</span> <span class="org-variable-name">len</span>,<span class="org-type">int</span> <span class="org-variable-name">flags</span>,
                 <span class="org-keyword">struct</span> <span class="org-type">sockaddr</span>* <span class="org-variable-name">addr</span>,<span class="org-type">socklen_t</span>* <span class="org-variable-name">addrlen</span>);
</pre>
</div>
<ul class="org-ul">
<li>对于面向连接的套接字,目标地址参数被忽略,因为连接中隐含了目标地址. <b>因此recvfrom函数一般用于无连接的套接字</b></li>
</ul>
</div>
</div>

<div id="outline-container-org4f707bb" class="outline-3">
<h3 id="org4f707bb"><span class="section-number-3">4.3</span> sendmsg和recvmsg</h3>
<div class="outline-text-3" id="text-4-3">
<p>
调用msghdr结构的sendmsg可以指定多重缓冲区传输数据,这和writev函数很类似
</p>
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;sys/socket.h&gt;</span>

<span class="org-comment-delimiter">/* </span><span class="org-comment">&#25104;&#21151;&#36820;&#22238;&#21457;&#36865;&#30340;&#23383;&#33410;&#25968;,&#20986;&#38169;&#36820;&#22238;-1</span><span class="org-comment-delimiter"> */</span>
<span class="org-type">ssize_t</span> <span class="org-function-name">sendmsg</span>(<span class="org-type">int</span> <span class="org-variable-name">sockfd</span>,<span class="org-keyword">const</span> <span class="org-keyword">struct</span> <span class="org-type">msghdr</span>* <span class="org-variable-name">msg</span>,<span class="org-type">int</span> <span class="org-variable-name">flags</span>);

<span class="org-keyword">struct</span> <span class="org-type">msghd</span>
{
  <span class="org-type">void</span>* <span class="org-variable-name">msg_name</span>;               <span class="org-comment-delimiter">/* </span><span class="org-comment">optional address</span><span class="org-comment-delimiter"> */</span>
  <span class="org-type">socklen_t</span> <span class="org-variable-name">msg_namelen</span>;        <span class="org-comment-delimiter">/* </span><span class="org-comment">address size in bytes</span><span class="org-comment-delimiter"> */</span>
  <span class="org-keyword">struct</span> <span class="org-type">iovec</span>* <span class="org-variable-name">msg_iov</span>;        <span class="org-comment-delimiter">/* </span><span class="org-comment">array of IO buffer</span><span class="org-comment-delimiter"> */</span>
  <span class="org-type">int</span> <span class="org-variable-name">msg_iovlen</span>;               <span class="org-comment-delimiter">/* </span><span class="org-comment">number of elements in array</span><span class="org-comment-delimiter"> */</span>
  <span class="org-type">void</span>* <span class="org-variable-name">msg_control</span>;            <span class="org-comment-delimiter">/* </span><span class="org-comment">&#38468;&#21152;&#25968;&#25454;</span><span class="org-comment-delimiter"> */</span>
  <span class="org-type">socklen_t</span> <span class="org-variable-name">msg_controllen</span>;     <span class="org-comment-delimiter">/* </span><span class="org-comment">&#38468;&#21152;&#25968;&#25454;&#30340;&#23383;&#33410;&#38271;&#24230;</span><span class="org-comment-delimiter"> */</span>
  <span class="org-type">int</span> <span class="org-variable-name">msg_flags</span>;                <span class="org-comment-delimiter">/* </span><span class="org-comment">flags for received message</span><span class="org-comment-delimiter"> */</span>
  <span class="org-comment-delimiter">/* </span><span class="org-comment">&#20854;&#20182;&#25104;&#21592;</span><span class="org-comment-delimiter"> */</span>
};
</pre>
</div>


<p>
recvmsg类似readv,可以将接收到的数据送入多个缓冲区.
</p>
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;sys/socket.h&gt;</span>

<span class="org-type">ssize_t</span> <span class="org-function-name">recvmsg</span>(<span class="org-type">int</span> <span class="org-variable-name">sockfd</span>,<span class="org-keyword">struct</span> <span class="org-type">msghdr</span>* <span class="org-variable-name">msg</span>,<span class="org-type">int</span> <span class="org-variable-name">flags</span>);
</pre>
</div>
<ul class="org-ul">
<li><p>
进入recvmsg时,msghdr结构中的msg_flags字段被忽略,但在返回时, <b>它会被设置以表示所接收数据的各种特征</b>
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">msg_flags</th>
<th scope="col" class="org-left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">MSG_CTRUNC</td>
<td class="org-left">控制数据被截断</td>
</tr>

<tr>
<td class="org-left">MSG_EOR</td>
<td class="org-left">接收记录结束符</td>
</tr>

<tr>
<td class="org-left">MSG_ERRQUEUE</td>
<td class="org-left">接收错误信息作为辅助数据</td>
</tr>

<tr>
<td class="org-left">MSG_OOB</td>
<td class="org-left">接收带外数据</td>
</tr>

<tr>
<td class="org-left">MSG_TRUNC</td>
<td class="org-left">一般数据被截断</td>
</tr>
</tbody>
</table></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orga7b9f35" class="outline-2">
<h2 id="orga7b9f35"><span class="section-number-2">5</span> 套接字选项</h2>
<div class="outline-text-2" id="text-5">
<p>
套接字选项可以控制套接字行为,
</p>
</div>

<div id="outline-container-orgfa78ebc" class="outline-3">
<h3 id="orgfa78ebc"><span class="section-number-3">5.1</span> setsockopt函数设置套接字选项</h3>
<div class="outline-text-3" id="text-5-1">
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;sys/socket.h&gt;</span>

<span class="org-comment-delimiter">/* </span><span class="org-comment">&#25104;&#21151;&#36820;&#22238;0,&#22833;&#36133;&#36820;&#22238;-1</span><span class="org-comment-delimiter"> */</span>
<span class="org-type">int</span> <span class="org-function-name">setsockopt</span>(<span class="org-type">int</span> <span class="org-variable-name">sockfd</span>,<span class="org-type">int</span> <span class="org-variable-name">level</span>,<span class="org-type">int</span> <span class="org-variable-name">option</span>,<span class="org-keyword">const</span> <span class="org-type">void</span>* <span class="org-variable-name">val</span>,<span class="org-type">socklen_t</span> <span class="org-variable-name">len</span>);
</pre>
</div>
<ul class="org-ul">
<li><p>
参数level表示欲设置的网络层
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">level</th>
<th scope="col" class="org-left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">SOL_SOCKET</td>
<td class="org-left">通用的套接字层次选项</td>
</tr>

<tr>
<td class="org-left">IPPROTO_TCP</td>
<td class="org-left">TCP协议选项</td>
</tr>

<tr>
<td class="org-left">IPPROTO_IP</td>
<td class="org-left">IP协议选项</td>
</tr>
</tbody>
</table></li>
<li><p>
参数option表示选项,val表示该选项设置为那个值, <b>val的具体参数类型根据不同的option而不同.</b>
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">选项</th>
<th scope="col" class="org-left">参数val的类型</th>
<th scope="col" class="org-left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">SO_ACCEPTCONN</td>
<td class="org-left">int</td>
<td class="org-left">返回信息指示该套接字是否能被监听(仅getsockopt)</td>
</tr>

<tr>
<td class="org-left">SO_BROADCAST</td>
<td class="org-left">int</td>
<td class="org-left">若*val非0,则广播数据报</td>
</tr>

<tr>
<td class="org-left">SO_DEBUG</td>
<td class="org-left">int</td>
<td class="org-left">若*val非0,启用网络驱动调试功能</td>
</tr>

<tr>
<td class="org-left">SO_DONTROUTE</td>
<td class="org-left">int</td>
<td class="org-left">若*val非0,不将报文由路出网络</td>
</tr>

<tr>
<td class="org-left">SO_ERROR</td>
<td class="org-left">int</td>
<td class="org-left">返回挂起的套接字错误并清除(仅getsockopt)</td>
</tr>

<tr>
<td class="org-left">SO_KEEPALIVE</td>
<td class="org-left">int</td>
<td class="org-left">若*val非0,启用周期性keep-alive报文</td>
</tr>

<tr>
<td class="org-left">SO_LINGER</td>
<td class="org-left">struct linger</td>
<td class="org-left">确保数据安全且可靠的传送出去</td>
</tr>

<tr>
<td class="org-left">SO_OOBINLINE</td>
<td class="org-left">int</td>
<td class="org-left">若*val非0,将带外数据放在普通数据中</td>
</tr>

<tr>
<td class="org-left">SO_RCVBUF</td>
<td class="org-left">int</td>
<td class="org-left">接收缓冲区的字节长度</td>
</tr>

<tr>
<td class="org-left">SO_RCVLOWAT</td>
<td class="org-left">int</td>
<td class="org-left">接收调用中返回的最小数据字节数</td>
</tr>

<tr>
<td class="org-left">SO_RCVTIMEO</td>
<td class="org-left">struct timeval</td>
<td class="org-left">套接字接收调用超时值</td>
</tr>

<tr>
<td class="org-left">SO_REUSEADDR</td>
<td class="org-left">int</td>
<td class="org-left">若*val非0,重用bind中的地址</td>
</tr>

<tr>
<td class="org-left">SO_SNDBUF</td>
<td class="org-left">int</td>
<td class="org-left">发送缓冲区的字节长度</td>
</tr>

<tr>
<td class="org-left">SO_SNDLOWAT</td>
<td class="org-left">int</td>
<td class="org-left">发送调用中传送的最小数据字节数</td>
</tr>

<tr>
<td class="org-left">SO_SNDTIMEO</td>
<td class="org-left">struct timeval</td>
<td class="org-left">套接字发送调用超时值</td>
</tr>

<tr>
<td class="org-left">SO_TYPE</td>
<td class="org-left">int</td>
<td class="org-left">标识套接字类型(仅getsockopt)</td>
</tr>
</tbody>
</table></li>
<li>参数len指定了val指向的对象的大小.</li>
</ul>


<p>
可以使用getsockopt函数来查看选项的当前值
</p>
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;sys/socket.h&gt;</span>

<span class="org-type">int</span> <span class="org-function-name">getsockopt</span>(<span class="org-type">int</span> <span class="org-variable-name">sockfd</span>,<span class="org-type">int</span> <span class="org-variable-name">level</span>,<span class="org-type">int</span> <span class="org-variable-name">option</span>,<span class="org-type">void</span>* <span class="org-variable-name">val</span>,<span class="org-type">socklen_t</span>* <span class="org-variable-name">lenp</span>);
</pre>
</div>
<ul class="org-ul">
<li>参数lenp是一个指向整数的指针,在调用getsockopt之前该整数为val缓冲区的长度,调用后,该值更新为实际长度.</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgfef93cc" class="outline-2">
<h2 id="orgfef93cc"><span class="section-number-2">6</span> 带外数据</h2>
<div class="outline-text-2" id="text-6">
<p>
带外数据是一些通讯协议所支持的可选功能,它具有比普通数据更高优先级的数据传输. 因此带外数据也被成为紧急数据.
</p>

<p>
TCP支持一个字节的带外数据,但UDP不支持. 
</p>

<p>
为了产生带外数据,可以在3个send函数中的任何一个里指定MSG_OOB标志. 如果代MSG_OOB标志发送的字节数超过一个时,最后一个字节将被视为紧急数据字节.
</p>

<p>
如果通过套接字安排了信号的产生,那么紧急数据被接收时,会发送SIGURG信号.
</p>

<p>
当带外数据出现在套接字读取队列时,select函数会返回一个文件描述符并且有一个待处理的异常条件. 
</p>

<p>
可以在普通数据流上接收带外数据,也可以在recv函数中使用MSG_OOB标志优先接收紧急数据. <b>由于TCP队列仅使用一个字节的带外数据,因此若在接收当前的紧急数据字节之前,又有新的紧急数据到来,那么已有的字节会被丢弃</b>
</p>

<p>
使用函数sockatmark可以判断将要读取的下一个字节是否为带外数据
</p>
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;sys/socket.h&gt;</span>

<span class="org-comment-delimiter">/* </span><span class="org-comment">&#23558;&#35201;&#35835;&#21462;&#24102;&#22806;&#25968;&#25454;&#36820;&#22238;1,&#21542;&#21017;&#36820;&#22238;0,&#20986;&#38169;&#36820;&#22238;-1</span><span class="org-comment-delimiter"> */</span>
<span class="org-type">int</span> <span class="org-function-name">sockatmark</span>(<span class="org-type">int</span> <span class="org-variable-name">sockfd</span>);
</pre>
</div>
</div>
</div>

</div>
</div>
<div>
  <div class="post-meta">
    <span title="post date" class="post-info">2015-06-08</span>
    <span title="last modification date" class="post-info">2016-10-24</span>
    <span title="tags" class="post-info">N/A</span>
    <span title="author" class="post-info">DarkSun</span>
  </div>
  <script src="../../../../../media/js/jquery-2.1.3.min.js"></script>
  <script src="../../../../../media/js/md5.min.js"></script>
  <section>
      <div id="gitalk-container"></div>
      <script type="text/javascript">
       var gitalk = new Gitalk({
           clientID: 'fdcb5d9da3f4acb4862c',
           clientSecret: 'dd0a16312a206782cb7669dcec5e96874ab48170',
           repo: 'lujun9972.github.com',
           owner: 'lujun9972',
           admin: ['lujun9972'],
           id: md5(location.pathname),      // Ensure uniqueness and length less than 50
           distractionFreeMode: false  // Facebook-like distraction free mode
       })
       gitalk.render('gitalk-container')
      </script>
  </section>
  <script src="../../../../../media/js/kdComment.js"></script>
      <script>
       var _hmt = _hmt || [];
       (function() {
           var hm = document.createElement("script");
           hm.src = "https://hm.baidu.com/hm.js?7bac4fd0247f69c27887e0d4e3aee41e";
           var s = document.getElementsByTagName("script")[0]; 
           s.parentNode.insertBefore(hm, s);
       })();
      </script>
  <div class="footer">
    <p>Generated by <a href="http://www.gnu.org/software/emacs/">Emacs</a> 27.x(<a href="http://orgmode.org">Org mode</a> 9.x)</p>
    <p>
      Copyright &copy; 2014 - <span id="footerYear"></span> <a href="mailto:travis &lt;at&gt; travis-job-7681ff2a-872b-49f2-9385-cd1ed3ca84fc">DarkSun</a>
      &nbsp;&nbsp;-&nbsp;&nbsp;
      Powered by <a href="https://github.com/emacs-china/EGO" target="_blank">EGO</a><br/>
      Themed with <a href="https://github.com/kuangdash/emacs_love" target="_blank">emacs_love</a>
        <a href="http://creativecommons.org/licenses/by-sa/3.0/" rel="license"><img src="https://licensebuttons.net/l/by-sa/3.0/88x31.png" style="border-width:0" alt="Creative Commons License" class="center"></a>
      <script type="text/javascript">document.getElementById("footerYear").innerHTML = (new Date()).getFullYear();</script>
    </p>
  </div>
    </div>

  </body>
</html>
